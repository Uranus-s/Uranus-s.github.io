[{"title":"Jenkins自动部署","url":"/2021/10/17/Jenkins%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2/","content":"为什么要用Jenkins每次开发完成一个项目之后，需要打包部署，没用专门的运维人员，只能由开发人员打包程序，把线上的服务关了，把打包好的应用程序部署进服务器，这是一个繁琐的过程，而Jenkins正好帮助我们解决了这个问题，自动构建部署，非常方便。\nJenkinsJenkins是一个开源软件项目，是基于Java开发的一种持续集成工具，用于监控持续重复的工作，旨在提供一个开放易用的软件平台，使软件的持续集成变成可能。\nJenkins工作原理\n以上为基本工作原理，只是为了开发人员更好的理解画的，详情可查看官方文档：https://www.jenkins.io/zh/\n安装Jenkins首先准备一台服务器/虚拟机，安装好Docker，还有远程连接工具等辅助软件。\n\n从Docker中拉取Jenkins镜像\ndocker pull jenkinsci&#x2F;blueocean\n启动Jenkins服务\ndocker run \\\n  -u root \\\n\n  -d \\\n  -p 10240:8080 \\\n  -p 10241:50000 \\\n  -v jenkins-data:&#x2F;var&#x2F;jenkins_home \\\n  -v &#x2F;var&#x2F;run&#x2F;docker.sock:&#x2F;var&#x2F;run&#x2F;docker.sock \\\n  jenkinsci&#x2F;blueocean\n\n\n-u：使用root用户\n-rm：关闭时自动删除Docker容器。如果您需要退出Jenkins，这可以保持整洁。\n-d：在后台运行容器（即“分离”模式）并输出容器ID。如果您不指定此选项， 则在终端窗口中会输出正在运行的此容器的Docker日志。\n-p： 映射端口\n-v：目录挂载\n\n\n浏览器输入http://192.168.140.128:10240/看到如下界面表示成功\n\n\n\n\n\n等待一段时间，可以看到如下界面\n\n\n#进入容器\ndocker exec -it xxxxxxxxxxx /bin/bash\n#查看密钥\ncat /var/jenkins_home/secrets/initialAdminPassword\nxxxxxxxxxxxxxxxxxxxxxxxxxx\n\n复制上面的xxxxxxxxxxxxxxxxxxxxxxxxxx密钥拿到浏览器的编辑框黏贴,点击继续等待一段时间。\n\n安装插件\n\n\n选择安装推荐的插件即可\n然后根据步骤配置管理员账号和JenkinsURL保存并完成，然后就可以使用了\n\n\n注意：首次进入Jenkins部分菜单会还没有中文，需要重新启动。\n\n\n实现Jenkins+Docker部署项目\nJenkins安装maven打包插件：Jenkins -&gt; 系统管理 -&gt; 插件管理 -&gt; 可选插件，搜索Maven Integration和Docker\n\n\n\n\n等待安装即可\n\n进行全局工具配置；Jenkins -&gt; 系统管理 -&gt; 全局工具配置\n\n\n进行JDK配置，在此之前你需要查看JAVA_HOM路径，使用docker inspect xxxxxxx即可，大致如下，有JAVA_HOM即可。\n&quot;Env&quot;: [\n    &quot;PATH&#x3D;&#x2F;opt&#x2F;java&#x2F;openjdk&#x2F;bin:&#x2F;usr&#x2F;local&#x2F;sbin:&#x2F;usr&#x2F;local&#x2F;bin:&#x2F;usr&#x2F;sbin:&#x2F;usr&#x2F;bin:&#x2F;sbin:&#x2F;bin&quot;,\n    &quot;LANG&#x3D;en_US.UTF-8&quot;,\n    &quot;LANGUAGE&#x3D;en_US:en&quot;,\n    &quot;LC_ALL&#x3D;en_US.UTF-8&quot;,\n    &quot;JAVA_VERSION&#x3D;jdk8u262-b10&quot;,\n    &quot;JAVA_HOME&#x3D;&#x2F;opt&#x2F;java&#x2F;openjdk&quot;,\n    &quot;JENKINS_HOME&#x3D;&#x2F;var&#x2F;jenkins_home&quot;,\n    &quot;JENKINS_SLAVE_AGENT_PORT&#x3D;50000&quot;,\n    &quot;REF&#x3D;&#x2F;usr&#x2F;share&#x2F;jenkins&#x2F;ref&quot;,\n    &quot;JENKINS_VERSION&#x3D;2.249.2&quot;,\n    &quot;JENKINS_UC&#x3D;https:&#x2F;&#x2F;updates.jenkins.io&quot;,\n    &quot;JENKINS_UC_EXPERIMENTAL&#x3D;https:&#x2F;&#x2F;updates.jenkins.io&#x2F;experimental&quot;,\n    &quot;JENKINS_INCREMENTALS_REPO_MIRROR&#x3D;https:&#x2F;&#x2F;repo.jenkins-ci.org&#x2F;incrementals&quot;,\n    &quot;COPY_REFERENCE_FILE_LOG&#x3D;&#x2F;var&#x2F;jenkins_home&#x2F;copy_reference_file.log&quot;\n],\n\n\n\n进行git配置\n\n\nmaven配置\n\n\ndocker配置\n\n\n最后点击保存即可。\n\n开始新建任务\n\n点击新建任务\n\n\n任务填写\n\n\n进行任务配置\n添加git仓库\n\n构建触发器\n\nbuild编译\n\n编译build的shell命令\n\n#将打包好的jar项目，移到&#x2F;opt&#x2F;data&#x2F;build目录\n#&#x2F;var&#x2F;jenkins_home&#x2F;workspace&#x2F;SpringBoot_AutoTest&#x2F;target&#x2F;jenkins-0.0.1-SNAPSHOT.jar构建好的jar路径\n#&#x2F;opt&#x2F;data&#x2F;build进入到容器创建这个目录\nmv &#x2F;var&#x2F;jenkins_home&#x2F;workspace&#x2F;SpringBoot-AutoTest&#x2F;target&#x2F;springboot-AutoTest-0.0.1-SNAPSHOT.jar &#x2F;opt&#x2F;data&#x2F;build\n#切换目录到&#x2F;opt&#x2F;data&#x2F;build\ncd &#x2F;opt&#x2F;data&#x2F;build\n#执行构建Dockerfile命令\ndocker build .&#x2F; -t my&#x2F;demo\n#停止之前的容器运行\ndocker stop demo\n#删除之前的容器\ndocker rm demo \n#运行刚刚创建的容器\ndocker run -d --name demo -p 8080:8080 my&#x2F;demo\necho &quot;构建完成&quot;\n\n点击保存应用。\n\n编写一份Dockerfile文件，内容如下\n# 基于java镜像创建新镜像\nFROM docker.io&#x2F;java:8\n\n# 作者\nMAINTAINER xxxx\n\n# 将jar包添加到容器中并更名为springboot-AutoTest-0.0.1-SNAPSHOT.jar\nCOPY springboot-AutoTest-0.0.1-SNAPSHOT.jar &#x2F;springboot-AutoTest-0.0.1-SNAPSHOT.jar\n\n# 暴露8080端口\nEXPOSE 8080\n\n# 运行jar包\nENTRYPOINT [&quot;java&quot;,&quot;-jar&quot;,&quot;springboot-AutoTest-0.0.1-SNAPSHOT.jar&quot;,&quot;--server.port&#x3D;8080&quot;,&quot;&amp;&quot;]\n\n编写好之后，运行如下命令，将其放置到Docker容器中\ndocker cp Dockerfile  容器ID:/opt/data/build\n\n点击立刻构建\n\n\n\n\n参考文章1：https://www.cnblogs.com/fuzongle/p/12834080.html\n文章2：https://blog.csdn.net/linfen1520/article/details/109045808\n文章3：https://blog.csdn.net/linfen1520/article/details/109045063\n","categories":["Jenkins"],"tags":["Jenkins"]},{"title":"Java-NIO","url":"/2021/09/28/Java-NIO/","content":"Java NIO 概述NIO主要有三大核心部分: Channel(通道)、Buffer(缓冲区)、Selector(选择区),区别与传统IO基于字节流和字符流进行操作,而NIO基于Channel和Buffer进行操作,数据总是从通道读取到缓存区中,或者从缓冲区写入到通道中,Selector用与监听多个通道的事件.因此单线程可以监听多个数据通道.\nChannel 和 Buffer基本上，所有的 IO 在NIO 中都从一个Channel 开始。Channel 有点象流。 数据可以从Channel读到Buffer中，也可以从Buffer 写到Channel中。\n\nChannel的主要实现:\n\nFileChannel\nDatagramChannel\nSocketChannel\nServerSocketChannel\n\n这些实现涵盖了UDP和TCP及网络IO与文件IO.\n\nBuffer的主要实现hexo\n\nByteBuffer\nCharBuffer\nDoubleBuffer\nFloatBuffer\nIntBuffer\nLongBuffer\nShortBuffer\nMappedByteBuffer(用于内存映射)\n\n这些Buffer覆盖了你能通过IO发送的基本数据类型：byte, short, int, long, float, double 和 char。\nSelectorSelector允许单个线程处理多个Channel,如果你的应用打开了多个连接(通道),但每个流量都很低(低流量场景),使用Selector会方便.\n\n要使用Selector,得向Selector注册Channel,然后调用它的Select()方法.这个方法会一直阻塞到某个注册的通道有事件就绪,一旦这个方法返回,线程就可以处理这些事件.\nBuffer使用Buffer读写数据一般遵循四个步骤\n\n写入数据到Buffer\n调用flip()方法\n从Buffer中读取数据\n调用clear()方法或者compact()方法\n\n向buffer写入数据时,buffer会记录写入了多少数据,一旦要读取数据,需要通过filp()方法将buffer切换到读模式,在读模式下,可以读取之前写入到buffer的所有数据.\n一旦读完了所有数据,就需要清空缓冲区,让它可以被再次写入,有两种方法能清空缓冲区:\n\nclaer()清空整个缓冲区\ncompact()清除已读过的数据,未读的会被移动至缓冲区起始处,新数据接在后面\n\n案例:\nFile file = new File(\"test.txt\");\nFileChannel fc = new RandomAccessFile(file, \"rw\").getChannel();\n\n//创建容量为 3 字节的缓冲区\nByteBuffer buf = ByteBuffer.allocate(3);\n\nint bytesRead;\n//读入缓冲区\nwhile ((bytesRead = fc.read(buf)) != -1) &#123;\n    System.out.println(\"Read-\" + bytesRead);\n    \n    //使Buffer状态变为准备读\n    buf.flip();\n\n    while (buf.hasRemaining())&#123;\n        //一次读取 1 个字节\n        System.out.println((char) buf.get());\n    &#125;\n    \n    //清空缓冲区,准备重新写入\n    buf.clear();\n&#125;\n\n\nBuffer(缓冲区)的本质是一块可以写入数据,然后可以从中读取数据的内存,这块内存被包装为NIO Buffer对象,提供了一组方法,用来方便访问该块内存.\n为了理解Buffer的工作原理,需要熟悉它的三个属性:\n\ncapacity\nposition\nlimit\n\nposition和limit的含义取决于Buffer是处于读模式还是写模式.不管Buffer处于什么模式,capacity的含义是一样的.\n\n\ncapacity\n作为一个内存块,Buffer有一个固定的大小,值为capacity,你只能往里面写入capacity个byte、long、char等类型,一旦写满,需要将其清空（通过读数据或者清除数据）才能继续写入数据.\n\n\nposition\n写模式：position表示当前位置,初始的position为0,当一个byte、long等数据写入Buffer后,position会向前移动到下一个可插入数据的Buffer单元,position最大可为 capacity-1    \n读模式：从某个特定的位置读,将当前Buffer从写模式切换到读模式,position会被重置为0,当从Buffer的position处读取数据时,position向前移动到下一个可读位置.\n\n\nlimit\n写模式：Buffer的limit表示你最多能往Buffer里写入多少数据.写模式下,limit最大值等于capacity.\n读模式：limit表示最多能读多少数据,因此,当切换Buffer到读模式时,limit会被设置为写模式下的position的值.换句话说,你能读到你之前写入的所有数据.(limit被设置成已写数据的数量，这个值在写模式下就是position)\n\nBuffer的类型Java NIO有一下Buffer类型\n\nByteBuffer\nMappedByteBuffer\nCharBuffer\nDoubleBuffer\nFloatBuffer\nIntBuffer\nLongBuffer\nShortBuffer\n\n不太Buffer对应不同数据类型,换句话说,就是可以通过char、short、int、long、float或double类型来操作缓冲区中的字节.\nBuffer的分配想要获得一个Buffer对象首先要进行分配,每个Buffer类都有一个allocate方法,下面是一个分配48字节capacity的ByteBuffer的例子.\nByteBuffer buf = ByteBuffer.allocate(48);\nSystem.out.println(ByteBuffer.allocate(10).getClass());\nSystem.out.println(ByteBuffer.allocateDirect(10).getClass());\n/**\n  * class java.nio.HeapByteBuffer    -使用Java堆内存，读写效率低，受到GC影响\n  * class java.nio.DirectByteBuffer  -使用直接内存。读写效率高（少一次数据拷贝），不会受到GC影响,分配的效率低，使用不当会内存泄露\n*/\n\nBuffer写入数据写入数据到Buffer有两种方法:\n\n从Channel写入到Buffer\nint bytesRead = inChannel.read(buf); //read into buffer.\n通过Buffer的put()方法写到Buffer里\nbuf.put((byte)127);\n\nput()方法有很多版本,允许你以不同方法从Buffer中读取数据,例如,从指定position读取,或者从Buffer中读取数据到字节数组,更多Buffer实现的细节参考JavaDoc.\n\nBuffer读取数据读取数据到Buffer有两种方法:\n\n调用channel的write方法\nint writeBytes = channel.write(buf);\n调用buffer自己的get方法\nbyte b = buf.get();\n\nget ()方法会让position读指针向后走，如果想重复读取数据,可以调用 rewind 方法将 position 重新置为 0,或者调用 get(int i) 方法获取索引 i 的内容，它不会移动读指针.\n\nrewind()方法\nBuffer.rewind()将position设回0,所以可以重读Buffer中的内容,limit保持不变.\nclear()和compact()方法\n一旦读完Buffer中的数据,需要清空Buffer以备再次写入,可以通过clear()或compact()方法来完成.\n调用的是clear()方法,position将被设置为0,limit被设置为capacity值,意思是,Buffer被清空,但是数据未清除,只是标记我们可以从那个标志位开始向Buffer写入数据.\n如果Buffer中有一些未读数据,调用clear()方法,数据将会被遗忘,意味着不会标记任何数据是读过的还是未读的.\n如果希望保留未读的数据,且后续需要这些数据,但又要先写入一些数据,则需使用compact()方法\ncompact()方法将未读的数据拷贝到Buffer起始处,然后将position设到最后一个未读元素后面,limit属性依然和clear()一样,设置为capacity,现在Buffer准备好写入数据了,但不会覆盖未读数据.\nmark()与reset()方法\n调用Buffer.make()方法,可以标记Buffer中的一个特定position,之后可以同过Buffer.reset()方法将position恢复到make位置.\nbuffer.mark();\n// 调用 buffer.get() 几次，例如 在解析过程中。\nbuffer.reset(); //将位置设置回标记\n/注意\nrewind 和 flip 都会清除 mark 位置\n\nequals()方法\n满足以下条件时为true\n\n相同的类型\nBuffer中剩余的byte、char等的个数相等\nBuffer中所有剩余的byte、char等都相同\n\nequals只是比较Buffer的一部分,不是每一个在它里面的元素都比较.实际上,它只比较Buffer中的剩余元素.\ncomareTo()方法\ncompareTo()方法比较两个Buffer的剩余元素(byte、char等), 如果满足下列条件,则认为一个Buffer“小于”另一个Buffer：\n\n第一个不相等的元素小于另一个Buffer中对应的元素 。\n所有元素都相等，但第一个Buffer比另一个先耗尽(第一个Buffer的元素个数比另一个少)。\n\nBuffer与字符串的转换\n//1. 字符串转为ByteBuffer\nByteBuffer buffer1 = ByteBuffer.allocate(16);\nbuffer1.put(\"hello\".getBytes());\nByteBufferUtil.debugAll(buffer1);\n\n//2. Charset\nByteBuffer buffer2 = StandardCharsets.UTF_8.encode(\"hello\"); //会自动切换到读模式\nByteBufferUtil.debugAll(buffer2);\n\n//3. wrap\nByteBuffer buffer3 = ByteBuffer.wrap(\"hello\".getBytes()); //会自动切换到读模式\nByteBufferUtil.debugAll(buffer3);\n\n/**--*--buffer转字符串--*--**/\n\nCharBuffer str1 = StandardCharsets.UTF_8.decode(buffer2);\nSystem.out.println(str1.toString());\n\n//需要先切换到读模式\nbuffer1.flip();\nCharBuffer str2 = StandardCharsets.UTF_8.decode(buffer1);\nSystem.out.println(str2.toString());\n\nScatter/GatherScatter(分散)从Channel中读取是指在读操作时将读取的数据写入多个Buffer中。因此，Channel将从Channel中读取的数据“分散(Scatter)”到多个Buffer中。\nGather(集散)写入Channel是指在写操作时将多个Buffer的数据写入同一个Channel中，因此，Channel将多个Buffer中的数据“聚集(Gather)”后发送到Buffer中。\nscatter / gather经常用于需要将传输的数据分开处理的场合，例如传输一个由消息头和消息体组成的消息，你可能会将消息体和消息头分散到不同的buffer中，这样你可以方便的处理消息头和消息体。\nScatterering ReadsScattering Reads是指数据从一个channel读取到多个buffer中。如下图描述：\n\n代码示例：\ntry (FileChannel channel = new RandomAccessFile(\"words.txt\", \"r\").getChannel()) &#123;\n    ByteBuffer b1 = ByteBuffer.allocate(3);\n    ByteBuffer b2 = ByteBuffer.allocate(3);\n    ByteBuffer b3 = ByteBuffer.allocate(5);\n    channel.read(new ByteBuffer[]&#123;b1, b2, b3&#125;);\n\n    b1.flip();\n    b2.flip();\n    b3.flip();\n\n    ByteBufferUtil.debugAll(b1);\n    ByteBufferUtil.debugAll(b2);\n    ByteBufferUtil.debugAll(b3);\n&#125; catch (IOException e) &#123;\n&#125; ;\n\n这里需要注意，Buffer数组作为read()的入参，会按顺序将将数据写入到Buffer中，当写满一个才会到下一个。\nScattering Reads在移动下一个buffer前，必须填满当前的buffer，意味着它不适合动态的消息，或者说大小不固定的消息，换句话说，如果存在消息头和消息体，消息头必须完成填充（例如 128byte），Scattering Reads才能正常工作。\nGathering WritesGathering Writes是指数据从多个buffer写入到同一个channel。如下图描述：\n\n代码示例：\nByteBuffer b1 = StandardCharsets.UTF_8.encode(\"hello\");\nByteBuffer b2 = StandardCharsets.UTF_8.encode(\"world\");\nByteBuffer b3 = StandardCharsets.UTF_8.encode(\"你好\");\n\ntry (FileChannel channel = new RandomAccessFile(\"words2.txt\", \"rw\").getChannel()) &#123;\n    channel.write(new ByteBuffer[]&#123;b1, b2, b3&#125;);\n&#125; catch (IOException e) &#123;\n&#125;\n\nbuffers数组是write()方法的入参，write()方法会按照buffer在数组中的顺序，将数据写入到channel，注意只有position和limit之间的数据才会被写入。因此，如果一个buffer的容量为128byte，但是仅仅包含58byte的数据，那么这58byte的数据将被写入到channel中。因此与Scattering Reads相反，Gathering Writes能较好的处理动态消息。\n通道之间的数据传输在NIO中，如果两个通道中有一个是FileChannel，那就可以之间将数据从一个Channel拷贝到另一个Channel。涉及到零拷贝，后面有写\ntransferTo()transferTo()方法将数据从FileChannel传输到其他的channel中。下面是一个简单的例子：\ntry &#123;\n    FileChannel from = new FileInputStream(\"data.txt\").getChannel();\n    FileChannel to = new FileOutputStream(\"to.txt\").getChannel();\n\n    // 效率高 底层会利用操作系统的零拷贝优化 注意：一次最大传2G 下面解决方法\n    from.transferTo(0, from.size(), to);\n&#125; catch (IOException e) &#123;\n    e.printStackTrace();\n&#125;\n\n//解决方法\ntry &#123;\n    FileChannel from = new FileInputStream(\"data.txt\").getChannel();\n    FileChannel to = new FileOutputStream(\"to.txt\").getChannel();\n\n    // 效率高 底层会利用操作系统的零拷贝优化 一次最大传2G\n    long size = from.size();\n    //left代表还剩余多少数据没有传输\n    for (long left = size; left > 0; ) &#123;\n        System.out.println(\"position: \" + (size - left) + \" left: \" + left);\n        left -= from.transferTo(size - left, left, to);\n    &#125;\n&#125; catch (IOException e) &#123;\n    e.printStackTrace();\n&#125;\n\ntransferFrom()FileChannel的transferFrom()方法可以将数据从源通道传输到FileChannel中。\n简单例子：\nRandomAccessFile fromFile = new RandomAccessFile(\"fromFile.txt\", \"rw\");\nFileChannel      fromChannel = fromFile.getChannel();\nRandomAccessFile toFile = new RandomAccessFile(\"toFile.txt\", \"rw\");\nFileChannel      toChannel = toFile.getChannel();\nlong position = 0;\nlong count = fromChannel.size();\ntoChannel.transferFrom(position, count, fromChannel);\n\n\n方法的输入参数position表示从position处开始向目标文件写入数据，count表示最多传输的字节数。如果源通道的剩余空间小于 count 个字节，则所传输的字节数要小于请求的字节数。\n此外要注意，在SoketChannel的实现中，SocketChannel只会传输此刻准备好的数据（可能不足count字节）。因此，SocketChannel可能不会将请求的所有数据(count个字节)全部传输到FileChannel中。\n是不是发现这个例子和前面那个例子特别相似？除了调用方法的FileChannel对象不一样外，其他的都一样。\nSelectorSelector(选择器)是Java NIO中能够检测一到多个NIO通道，并能够知晓通道是否为诸如读写事件做好准备的组件，这样，一个单独的线程可以管理多个Channel，从而管理多个网络连接。\n为什么使用Selector仅用单个线程来处理多个Channels的好处是，只需要更少的线程来处理通道。事实上，可以只用一个线程处理所有的通道。对于操作系统来说，线程之间上下文切换的开销很大，而且每个线程都要占用系统的一些资源（如内存）。因此，使用的线程越少越好。\n但是，需要记住，现代的操作系统和CPU在多任务方面表现的越来越好，所以多线程的开销随着时间的推移，变得越来越小了。实际上，如果一个CPU有多个内核，不使用多任务可能是在浪费CPU能力。不管怎么说，关于那种设计的讨论应该放在另一篇不同的文章中。在这里，只要知道使用Selector能够处理多个通道就足够了。\n\nSelector的创建通过调用Selector.open()方法创建一个Selector，如下：\nSelector selector = Selector.open();\n\n绑定Channel事件也称之为注册事件，为了Channel和Selector配合使用，必须将Channel注册到Selector上，通过SelectableChannel.register()方法实现，如下：\nchannel.configureBlocking(false);//设置非阻塞模式\n//向Selector注册Channel时，`Channel.register()`方法会返回一个SelectionKey对象，这个对象代表注册到该Selector的通道。\nSelectionKey key = channel.register(selector, 绑定事件);\n\n\nchannel必须工作在非阻塞模式下\nFileChannel 没用非阻塞模式，因此不能配合 selector 一起使用\n\n注意register()方法的第二个参数。这是一个“interest集合”，意思是在通过Selector监听Channel时对什么事件感兴趣。可以监听四种不同类型的事件：\n\nConnect - 客户端连接建立后触发\nAccept - 会在有连接请求时触发\nRead - 可读事件\nWrite - 可写事件\n\n通道触发了一个事件意思是该事件已经就绪。所以，某个channel成功连接到另一个服务器称为“连接就绪”。一个server socket channel准备好接收新进入的连接称为“接收就绪”。一个有数据可读的通道可以说是“读就绪”。等待写数据的通道可以说是“写就绪”。\n这四种事件用SelectionKey的四个常量来表示：\n\nSelectionKey.OP_CONNECT\nSelectionKey.OP_ACCEPT\nSelectionKey.OP_READ\nSelectionKey.OP_WRITE\n\n如果你对不止一种事件感兴趣，那么可以用“位或”操作符将常量连接起来，如下：\nint interestSet = SelectionKey.OP_READ | SelectionKey.OP_WRITE;\n\n在下面还会继续提到interest集合。\nSelectionKey向Selector注册Channel时，register()方法会返回一个SelectionKey对象，这个对象包含了一些属性：\n\ninterest集合\nready集合\nChannel\nSelector\n附加对象(可选)\n\n\ninterest集合\n就像向Selector注册通道一节中所描述的，interest集合是你所选择的感兴趣的事件集合。可以通过SelectionKey读写interest集合，像这样：\nint interestSet = selectionKey.interestOps();\nboolean isInterestedInAccept  = (interestSet &amp; SelectionKey.OP_ACCEPT) == SelectionKey.OP_ACCEPT；\nboolean isInterestedInConnect = interestSet &amp; SelectionKey.OP_CONNECT;\nboolean isInterestedInRead    = interestSet &amp; SelectionKey.OP_READ;\nboolean isInterestedInWrite   = interestSet &amp; SelectionKey.OP_WRITE;\n\n可以看到，用“位与”操作insterest集合和SelectionKey常量，可以确定某个确定的事件是否在insterest集合中。\n\n\nready集合\nready集合是通道已经准备就绪的操作的集合，在一次选择(Selection)之后，你会首先访问这个ready set。Selection将在下一小节进行解释。可以这样访问ready集合：\nint readySet = selectionKey.readyOps();\n\n可以用像检测interest集合那样的方法，来检测channel中什么事件或操作已经就绪。但是，也可以使用以下四个方法，它们都会返回一个布尔类型：\nselectionKey.isAcceptable();\nselectionKey.isConnectable();\nselectionKey.isReadable();\nselectionKey.isWritable();\n\n\nChannel+Selector\n从SelectionKey访问Channel和Selector很简单。如下：\nChannel  channel  = selectionKey.channel();\nSelector selector = selectionKey.selector();\n\n\n附加对象\n可以将一个对象或者更多信息附着到SelectionKey上，这样就能方便的识别某个给定的通道。例如，可以附加 与通道一起使用的Buffer，或是包含聚集数据的某个对象。使用方法如下：\nselectionKey.attach(theObject);\nObject attachedObj = selectionKey.attachment();\n\n还可以在用register()方法向Selector注册Channel的时候附加对象。如：\nSelectionKey key = channel.register(selector, SelectionKey.OP_READ, theObject);\n\n监听Channel事件一旦向Selector注册了一个或多个通道，就可用调用select()方法，这些方法会根据你所感兴趣的事件（如连接、接受、读或写）已经准备就绪的那些通道。\n方法1，阻塞直到绑定事件发生\nint count = selector.select();\n\n\n\n方法2，阻塞直到绑定事件发生，或是超时（时间单位为 ms）\nint count = selector.select(long timeout);\n\n\n\n方法3，不会阻塞，也就是不管有没有事件，立刻返回，自己根据返回值检查是否有事件\nint count = selector.selectNow();\n\n\n\nselect 何时不阻塞\n\n事件发生时\n客户端发起连接请求，会触发 accept 事件\n客户端发送数据过来，客户端正常、异常关闭时，都会触发 read 事件，另外如果发送的数据大于 buffer 缓冲区，会触发多次读取事件\nchannel 可写，会触发 write 事件\n在 linux 下 nio bug 发生时\n\n\n调用 selector.wakeup()\n调用 selector.close()\nselector 所在线程 interrupt\n\n\nselectedKeys()一旦select()方法执行完毕，就可以通过调用selector的selectedKeys()方法，访问就绪通道，如下：\nSet&lt;SelectionKey> selectionKeys = selector.selectedKeys();\n// 或\nIterator&lt;SelectionKey> iter = selector.selectedKeys().iterator();\n\n可以通过遍历这个集合访问就绪的通道，如下：\nIterator&lt;SelectionKey> iter = selector.selectedKeys().iterator();\nwhile (iter.hasNext()) &#123;\n    SelectionKey key = iter.next();\n    if(key.isAcceptable()) &#123;\n        // a connection was accepted by a ServerSocketChannel.\n    &#125; else if (key.isConnectable()) &#123;\n        // a connection was established with a remote server.\n    &#125; else if (key.isReadable()) &#123;\n        // a channel is ready for reading\n    &#125; else if (key.isWritable()) &#123;\n        // a channel is ready for writing\n    &#125;\n&#125;\n\n这个循环遍历了所有已就绪的Key，并检测对应的事件。\nSelectionKey.channel()方法返回的通道需要转型成你要处理的类型，如ServerSocketChannel或SocketChannel等。\nServerSocketChannel channel = (ServerSocketChannel) key.channel();\n\n完整的示例：\nserver端：\n//1.创建selector对象 管理多个channel\nSelector selector = Selector.open();\n\nServerSocketChannel ssc = ServerSocketChannel.open();\nssc.configureBlocking(false);\nssc.bind(new InetSocketAddress(8080));\n\n//2.建立selector和channel的联系/注册\n//SelectionKey 就是将来事件发生后 通过它可以知道事件和哪个channel的事件\nSelectionKey sscKey = ssc.register(selector, 0, null);\n//key 只关注 accpet 事件\nsscKey.interestOps(SelectionKey.OP_ACCEPT);\nSystem.out.println(\"register: \" + sscKey);\n\nwhile (true) &#123;\n    //3. select方法\n    //select在事件未处理时，它不会阻塞，事件发生后要么处理，要么取消，不能不管\n    selector.select();//阻塞方法 没有事件发生时会阻塞 发生事件继续运行\n\n    //4. 处理事件 selectedKeys()内部包含了所有发生的事件\n    Iterator&lt;SelectionKey> iter = selector.selectedKeys().iterator();\n    while (iter.hasNext()) &#123;\n        SelectionKey key = iter.next();\n        System.out.println(\"key: \" + key);\n        //处理事件\n        ServerSocketChannel channel = (ServerSocketChannel) key.channel();\n        SocketChannel accept = channel.accept();\n        System.out.println(\"\" + accept);\n        //取消事件\n        //key.channel();\n        // 处理完毕，必须将事件移除\n        iter.remove();\n    &#125;\n&#125;\n\n\n事件发生后，要么处理，要么取消（cancel），不能什么都不做，否则下次该事件仍会触发，这是因为 nio 底层使用的是水平触发\n\n\n因为 select 在事件发生后，就会将相关的 key 放入 selectedKeys 集合，但不会在处理完后从 selectedKeys 集合中移除，需要我们自己编码删除。例如\n\n第一次触发了 ssckey 上的 accept 事件，没有移除 ssckey \n第二次触发了 sckey 上的 read 事件，但这时 selectedKeys 中还有上次的 ssckey ，在处理时因为没有真正的 serverSocket 连上了，就会导致空指针异常\n\n\nclient端：\nSocketChannel sc = SocketChannel.open();\nsc.connect(new InetSocketAddress(\"localhost\",8080));\nSystem.out.println(\"waiting...\");\n\n消息边界问题在服务器端接收到的消息，长度是不定的，如图：\n\n为了解决这种情况，有如下三种方法：\n\n固定消息长度，数据大小一样，服务器按照预定长度读取\n分隔符拆分\nTLV格式(T：Type类型，L：Length长度，V：Value类型)，类型和格式已知的情况下，去分配Buffer\nHTTP1是TLV格式\nHTTP2是LTV格式\n\n\n\n\n使用第二种方式的代码：\n服务器端\npublic static void main(String[] args) throws IOException &#123;\n    //1.创建selector对象 管理多个channel\n    Selector selector = Selector.open();\n\n    ServerSocketChannel ssc = ServerSocketChannel.open();\n    ssc.configureBlocking(false);\n    ssc.bind(new InetSocketAddress(8080));\n\n    //2.建立selector和channel的联系/注册\n    //SelectionKey 就是将来事件发生后 通过它可以知道事件和哪个channel的事件\n    SelectionKey sscKey = ssc.register(selector, 0, null);\n    //key 只关注 accpet 事件\n    sscKey.interestOps(SelectionKey.OP_ACCEPT);\n    System.out.println(\"register: \" + sscKey);\n\n    while (true) &#123;\n        //3. select方法\n        //select在事件未处理时，它不会阻塞，事件发生后要么处理，要么取消，不能不管\n        selector.select();//阻塞方法 没有事件发生时会阻塞 发生事件继续运行\n\n        //4. 处理事件 selectedKeys()内部包含了所有发生的事件\n        Iterator&lt;SelectionKey> iter = selector.selectedKeys().iterator();\n        while (iter.hasNext()) &#123;\n            SelectionKey key = iter.next();\n            iter.remove();//处理key后 必须从selectedKeys()中删除 否则下次还会处理\n            System.out.println(\"key: \" + key);\n            //5.区分事件类型\n            if (key.isAcceptable()) &#123; //如果是accpet\n                ServerSocketChannel channel = (ServerSocketChannel) key.channel();\n                SocketChannel sc = channel.accept();\n                sc.configureBlocking(false);\n                ByteBuffer buffer = ByteBuffer.allocate(16);\n                //将一个ByteBuffer作为附件关联到selectionKey上\n                SelectionKey scKey = sc.register(selector, 0, buffer);\n                scKey.interestOps(SelectionKey.OP_READ);\n                System.out.println(\"\" + sc);\n            &#125; else if (key.isReadable()) &#123;//如果是read\n                try &#123;\n                    SocketChannel channel = (SocketChannel) key.channel();\n                    //                        ByteBuffer buffer = ByteBuffer.allocate(16);\n                    ByteBuffer buffer = (ByteBuffer) key.attachment();//从附件中获取\n                    int read = channel.read(buffer);\n                    if (read == -1) &#123;//-1表示客户端主动断开连接\n                        key.cancel();\n                        System.out.println(\"一个客户端断开连接\");\n                    &#125; else &#123;\n                        split(buffer);\n                        if (buffer.position() == buffer.limit()) &#123; //如果读到的消息没用结束符 则进行扩容\n                            ByteBuffer newBuffer = ByteBuffer.allocate(buffer.capacity() * 2);\n                            buffer.flip();//切换到读模式\n                            newBuffer.put(buffer);\n                            key.attach(newBuffer);//将新的Buffer放到附件中\n                        &#125;\n                    &#125;\n                &#125; catch (IOException e) &#123;\n                    e.printStackTrace();\n                    //因为客户端断开了，因此需要将key取消(从selector的keys中真正删除key)\n                    key.cancel();\n                &#125;\n            &#125;\n        &#125;\n    &#125;\n&#125;\n\nprivate static void split(ByteBuffer source) &#123;\n    source.flip();\n\n    for (int i = 0; i &lt; source.limit(); i++) &#123;\n        //找到一条完整消息\n        if (source.get(i) == '\\n') &#123;\n            int length = i + 1 - source.position();\n            //将完整消息存入新的Buffer\n            ByteBuffer target = ByteBuffer.allocate(length);\n            //从 source 读 ， 向 target 写\n            for (int j = 0; j &lt; length; j++) &#123;\n                target.put(source.get());\n            &#125;\n            ByteBufferUtil.debugAll(target);\n        &#125;\n    &#125;\n    source.compact();\n&#125;\n\n客户端\nSocketChannel sc = SocketChannel.open();\nsc.connect(new InetSocketAddress(\"localhost\",8080));\nsc.write(Charset.defaultCharset().encode(\"1234567890\\n0987654321aaaa\"));\nsc.write(Charset.defaultCharset().encode(\"12345678900987654321\\n\"));\nSystem.out.println(\"waiting...\");\nSystem.in.read();\n\nNIO vs BIOStream vs Channel\nStream不会自动缓存数据，channel会利用系统提供的发送缓冲区、接收缓冲区\nStream仅支持阻塞API，Channel同时支持阻塞、非阻塞API，网络Channel可配合Selector实现多路复用\n二者均为全双工，即读写可以同时进行\n\nIO模型同步阻塞、同步非阻塞、同步多路复用、异步阻塞(不存在的)、异步非阻塞\n\n同步：线程自己去获取结果(一个线程)\n异步：线程不自己获取结果，而是由其他线程发送结果(至少两个线程)\n\n零拷贝传统IO问题传统的IO将一个文件通过Socket写出\nFile f = new File(\"helloword/data.txt\");\nRandomAccessFile file = new RandomAccessFile(file, \"r\");\n\nbyte[] buf = new byte[(int)f.length()];\nfile.read(buf);\n\nSocket socket = ...;\nsocket.getOutputStream().write(buf);\n\n内部工作流程：\n\n\njava本身不具备IO读写能力，因此Read方法调用后，要从java程序的用户态切换到内核态，去调用操作系统（Kernel）的读能力，将数据读入内核缓冲区。这期间用户线程阻塞，操作系统会使用DMA(Direct Memory Access)来实现文件读，期间也不会使用CPU\n\nDMA也可以理解为硬件单元，用来解放 cpu 完成文件 IO\n\n\n从内核态切换回用户态，将数据从内核缓冲区读入用户缓冲区（即byte[] buf），这期间cpu会参与拷贝，无法利用cpu\n\n调用write方法，这时将数据从用户缓冲区（即byte[] buf）写入socket缓冲区，cpu会参与拷贝\n\n接下来要向网卡写入数据，这项能力java又不具备，因此又得从用户态切换至内核态，调用操作系统的写能力，使用DMA将socket缓冲区的数据写入网卡，又不会使用cpu\n\n\n可以看到中间环节较多，java的IO实际不是物理设备级别的读写，而是缓存的复制，底层真正的读写是又操作系统来完成的\n\n用户态和内核态的切换发生了3次，这是重量级的\n数据拷贝了共4次\n\nNIO通过DirectByteBuff\n\nByteBuffer.allocate(10)  HeapByteBuffer 使用的是 java 内存\nByteBuffer.allocateDirect(10)  DirectByteBuffer 使用的是操作系统内存\n\n\n基本和优化前相同，唯有一点：java可以通过 DirectByteBuff  将堆外内存映射到jvm内存中来直接访问使用\n\n这块内存不受jvm垃圾回收的影响，因此内存地址固定，有助于IO读写\njava中的DirectByteBuf对象仅维护了此内存的虚引用，内存回收分成两部\nDirectByteBuf对象垃圾回收，将虚引用加入引用队列\n通过专门线程访问引用队列，根据虚引用是否堆外内存\n\n\n减少了一次数据拷贝，用户态和内核态的切换次数没用减少\n\n\n进一步优化（底层使用了lunux2.1后提供的sendFile方法），java中对应着两个channel调用transferTo和transferForm方法拷贝数据\n\n\njava调用transferTo方法后，要从java程序的用户态切换至内核态，使用DMA将数据读入内核缓冲区，不会使用\n数据从内核缓冲区传输到socket缓冲区，cpu会参与拷贝\n最后使用DMA将socket缓冲区的数据写入网卡，不会使用cpu\n\n可以看到，只发生了一次用户态和内核态的切换，数据拷贝了3次\n\n再进一步优化（linux2.4）\n\n\njava调用transferTo方法后，要从java程序的用户态切换到内核态，使用DMA将数据读入内核缓冲区，不会使用cpu\n只会将一些 offset 和 length 信息考入 socket缓冲区，几乎无消耗\n使用DMA将内核缓冲区的数据写入网卡，不会使用cpu\n\n整个过程同意只发生了一次用户态和内核态的切换，数据拷贝了2次，所谓的零拷贝，并不是真正的无拷贝，而是不会拷贝重复数据到jvm内存中，零拷贝的的优点：\n\n更少的用户态与内核态的切换\n不利于cpu计算，减少cpu利用\n零拷贝适合小文件传输\n\nAIOAIO用于解决数据复制阶段的阻塞问题\n\n同步意味着，在进行读写操作时，线程需要等待结果，相当于闲置\n异步意味着，在进行读写操作时，线程不必等待结果，而是由操作系统来通过回调方式由另外的线程获得结果\n\n\n异步模型需要底层操作系统(Kernel)提供支持\n\nWindows系统通过IOCP实现了真正的异步IO\nLinux系统异步IO在2.6版本引入，但是底层实现还是多路复用模拟异步IO，性能没优势\n\n\n案例：\npublic class AioFileChannel &#123;\n    public static void main(String[] args) throws IOException &#123;\n        try (AsynchronousFileChannel channel = AsynchronousFileChannel.open(Paths.get(\"data.txt\"), StandardOpenOption.READ)) &#123;\n            //参数1：ByterBuffer\n            //参数2：读取的起始位置\n            //参数3：附件\n            //参数4：回调对象\n            ByteBuffer buffer = ByteBuffer.allocate(16);\n            log.debug(\"read begin...\");\n            channel.read(buffer, 0, buffer, new CompletionHandler&lt;Integer, ByteBuffer>() &#123;\n                @Override\n                public void completed(Integer result, ByteBuffer attachment) &#123;\n                    log.debug(\"read completed...&#123;&#125;\", result);\n                    attachment.flip();\n                    debugAll(attachment);\n                &#125;\n\n                @Override\n                public void failed(Throwable exc, ByteBuffer attachment) &#123;\n                    log.error(exc.getMessage());\n                &#125;\n            &#125;);\n            log.debug(\"read end...\");\n        &#125; catch (IOException e) &#123;\n            e.printStackTrace();\n        &#125;\n        System.in.read();\n    &#125;\n&#125;\n\n输出\n13:44:56 [DEBUG] [main] c.i.aio.AioDemo1 - begin...\n13:44:56 [DEBUG] [main] c.i.aio.AioDemo1 - do other things...\n13:44:56 [DEBUG] [Thread-5] c.i.aio.AioDemo1 - read completed...2\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 61 0d                                           |a.              |\n+--------+-------------------------------------------------+----------------+\n\n\n相应文件读取成功的是另一个线程Thread-5\n主线程并没用IO操作\n\n参考文章1: https://blog.csdn.net/forezp/article/details/88414741/\n文章2: https://ifeve.com/java-nio-all/\n视频教程: https://www.bilibili.com/video/BV1py4y1E7oA\n","categories":["Java"],"tags":["Java","NIO"]},{"title":"IText实现PDF自动定位签合同","url":"/2021/09/13/IText%E5%AE%9E%E7%8E%B0PDF%E8%87%AA%E5%8A%A8%E5%AE%9A%E4%BD%8D%E7%AD%BE%E5%90%88%E5%90%8C/","content":"前言需要实现PDF合同自动签字的功能,实现这个功能关键点在与怎么找到签字的位置,我想到的办法是在签字位置放一个关键字,然后程序找到这个关键字的位置,在上面放上用户的签字.\n代码首先先导入对应的包\n&lt;dependency>\n    &lt;groupId>com.itextpdf&lt;/groupId>\n    &lt;artifactId>itextpdf&lt;/artifactId>\n    &lt;version>5.5.13&lt;/version>\n&lt;/dependency>\n\n&lt;dependency>\n    &lt;groupId>com.itextpdf&lt;/groupId>\n    &lt;artifactId>itext-asian&lt;/artifactId>\n    &lt;version>5.2.0&lt;/version>\n&lt;/dependency>\n\n具体实现\n/**\n *\n * PDF处理类\n *\n * @author GAS\n * @date 2021年09月13日 10:36\n */\npublic class PDFUtils &#123;\n    public static void Autograph() throws Exception &#123;\n        // 模板文件路径\n        String templatePath = \"D:\\\\测试.pdf\";\n        // 生成的文件  本地路径\n        String targetPath = \"D:\\\\target.pdf\";\n        //模拟用户传参\n        HashMap&lt;String, String> hashMap = new HashMap&lt;>(5);\n        hashMap.put(\"Aname\", \"D:\\\\A.jpg\");\n        hashMap.put(\"Bname\", \"D:\\\\B.jpg\");\n        hashMap.put(\"甲签章\", \"D:\\\\C.jpg\");\n        hashMap.put(\"乙签章\", \"D:\\\\D.jpg\");\n\n        // 读取模板文件\n        // InputStream input = new FileInputStream(new File(templatePath));\n        PdfReader reader = new PdfReader(templatePath);\n\n        //新建一个PDF解析对象\n        PdfReaderContentParser parser = new PdfReaderContentParser(reader);\n        PdfStamper stamper = new PdfStamper(reader, new FileOutputStream(targetPath));\n        //循环PDF页\n        for (int i = 1; i &lt;= reader.getNumberOfPages(); i++) &#123;\n            //循环关键字\n            for (String key : hashMap.keySet()) &#123;\n                //新建一个ImageRenderListener对象，该对象实现了RenderListener接口，作为处理PDF的主要类\n                TestRenderListener listener = new TestRenderListener(i, key);\n                //解析PDF，并处理里面的文字\n                parser.processContent(i, listener);\n                List&lt;pdfHelpEntity> result = listener.result;\n                for (pdfHelpEntity entity : result) &#123;\n                    // 获取操作的页面---\n                    PdfContentByte under = stamper.getOverContent(entity.getPageNumber());\n                    // 读图片\n                    Image image = Image.getInstance(hashMap.get(key));\n                    // url远程文件旋转需要使用setRotationDegrees   本地使用setRotation\n                    image.setRotationDegrees(90f);\n                    // 根据域的大小缩放图片\n                    double width = Math.abs(entity.getStart().getMinX() - entity.getEnd().getMinX()) * entity.getSign().length();\n                    double height = entity.getStart().getHeight();\n//                    image.scaleToFit((float) height,(float) width);\n                    image.scaleAbsolute((float) height * 2,(float) width);\n                    // 添加图片\n                    image.setAbsolutePosition((float) entity.getStart().getMinX(), (float) entity.getStart().getMinY() - 5);\n                    under.addImage(image);\n                &#125;\n            &#125;\n        &#125;\n        stamper.close();\n        reader.close();\n        System.exit(0);\n    &#125;\n&#125;\n\npublic class TestRenderListener implements RenderListener &#123;\n\n    // 关键字\n    public String keyWord;\n    // 关键字字符数组\n    public char[] charArray;\n    // PDF当前页数\n    public int curPage;\n    // 坐标信息集合\n    public List&lt;pdfHelpEntity> result = new ArrayList&lt;>();\n    //下标\n    public int subscript = 0;\n    //是否找到\n    public boolean isFind = false;\n    //一个实体类\n    pdfHelpEntity entity;\n\n    public TestRenderListener(int curPage, String keyWord) &#123;\n        this.curPage = curPage;\n        this.keyWord = keyWord;\n        this.charArray = keyWord.toCharArray();\n    &#125;\n\n    /**\n     * 文字主要处理方法\n     */\n    @Override\n    public void renderText(TextRenderInfo textRenderInfo) &#123;\n        String text = textRenderInfo.getText();\n        RectangularShape rectBase = textRenderInfo.getBaseline().getBoundingRectange();\n        Rectangle2D.Float rectAscen = textRenderInfo.getAscentLine().getBoundingRectange();\n        //查找是否匹配 关键字的第一个字符\n        if (text.equals(keyWord.substring(0, 1))) &#123;\n            Rectangle2D.Float start = new Rectangle2D.Float();\n            start.setRect((float) rectBase.getMinX()\n                    , (float) rectBase.getMinY()\n                    , (float) (rectAscen.getMaxX() - rectBase.getMinX())\n                    , (float) (rectAscen.getMaxY() - rectBase.getMinY())\n            );\n            entity = new pdfHelpEntity();\n            entity.setPageNumber(curPage);\n            entity.setStart(start);\n\n            //下标自增\n            subscript++;\n            //已找到\n            isFind = true;\n\n            return;\n        &#125;\n\n        if (isFind) &#123;\n            //下标不能超过关键字的长度\n            if (subscript &lt; charArray.length) &#123;\n                //判断后续的字符是否符合\n                if (text.equals(String.valueOf(charArray[subscript]))) &#123;\n                    //下标自增\n                    subscript++;\n\n                    if (subscript >= charArray.length)&#123;\n                        Rectangle2D.Float end = new Rectangle2D.Float();\n\n                        end.setRect((float) rectBase.getMinX()\n                                , (float) rectBase.getMinY()\n                                , (float) (rectAscen.getMaxX() - rectBase.getMinX())\n                                , (float) (rectAscen.getMaxY() - rectBase.getMinY())\n                        );\n                        entity.setEnd(end);\n                        entity.setSign(keyWord);\n                        result.add(entity);\n                        System.out.println(\"成功-\" + keyWord + \"-\" + text + \"-\" + charArray[subscript-1] + \"-\" + subscript);\n                        //这里是找完一组了 所以重置数据\n                        isFind = false;\n                        subscript = 0;\n                        return;\n                    &#125;\n\n                    return;\n                &#125;\n                //如果后续字符不匹配\n                else &#123;\n                    System.out.println(\"失败-\" + keyWord + \"-\" + text + \"-\" + charArray[subscript] + \"-\" + subscript);\n                    isFind = false;\n                    subscript = 0;\n                    return;\n                &#125;\n            &#125;\n        &#125;\n    &#125;\n\n    @Override\n    public void beginTextBlock() &#123;\n    &#125;\n\n    @Override\n    public void endTextBlock() &#123;\n    &#125;\n\n    //step 1(图片处理方法)\n    @Override\n    public void renderImage(ImageRenderInfo renderInfo) &#123;\n\n    &#125;\n&#125;\n\npublic class pdfHelpEntity &#123;\n    String sign;\n    com.itextpdf.awt.geom.Rectangle2D.Float start;\n    com.itextpdf.awt.geom.Rectangle2D.Float end;\n    int pageNumber;\n\n    public String getSign() &#123;\n        return sign;\n    &#125;\n\n    public void setSign(String sign) &#123;\n        this.sign = sign;\n    &#125;\n\n    public com.itextpdf.awt.geom.Rectangle2D.Float getStart() &#123;\n        return start;\n    &#125;\n\n    public void setStart(com.itextpdf.awt.geom.Rectangle2D.Float start) &#123;\n        this.start = start;\n    &#125;\n\n    public com.itextpdf.awt.geom.Rectangle2D.Float getEnd() &#123;\n        return end;\n    &#125;\n\n    public void setEnd(com.itextpdf.awt.geom.Rectangle2D.Float end) &#123;\n        this.end = end;\n    &#125;\n\n    public int getPageNumber() &#123;\n        return pageNumber;\n    &#125;\n\n    public void setPageNumber(int pageNumber) &#123;\n        this.pageNumber = pageNumber;\n    &#125;\n&#125;\n\n使用上面的代码运行就能实现功能了,但具体如何封装到自己的应用中,就更凭本事发挥,网上也有更多比我更好的实现方案,我这里的算是简陋版的,献丑了.\n踩过的坑网上百度的实现大多是告诉你renderText获取到一行之后,直接匹配关键字就行了,然而renderText获取到的内容不是一行,而是一个字,我翻阅了很多资料,发现renderText每次读取到的都是chunk(文本块)里的内容,属实乱复制粘贴,罪大恶极啊.\n参考文章1: https://cloud.tencent.com/developer/article/1502411\n文章2: http://www.manongjc.com/article/54527.html\n文章3: https://blog.csdn.net/qq_40707682/article/details/108347146\n文章4: https://www.codeleading.com/article/61094200906/\n官网: https://itextpdf.com/en/resources/api-documentation/itext-5-java\n","categories":["IText"],"tags":["Java","IText"]},{"title":"SpringCloud GateWay(一)","url":"/2021/09/03/SpringCloud-GateWay-%E4%B8%80/","content":"简介网关作为流量入口,常用功能包括路由转发、权限校验、限流控制等.而SpringCloud GateWay作为SpringCloud官方推出的第二代网关框架,取代了Zuul网关.\n三大概念\nRoute(路由): The basic building block of the gateway. It is defined by an ID, a destination URI, a collection of predicates断言, and a collection of filters. A route is matched if the aggregate predicate is true.发一个请求给网关，网关要将请求路由到指定的服务。路由有id，目的地uri，断言的集合，匹配了断言就能到达指定位置，\nPredicate(断言): This is a Java 8 Function Predicate. The input type is a Spring Framework ServerWebExchange. This lets you match on anything from the HTTP request, such as headers or parameters.就是java里的断言函数，匹配请求里的任何信息，包括请求头等。根据请求头路由哪个服务\nFilter(过滤器): These are instances of Spring Framework GatewayFilter that have been constructed with a specific factory. Here, you can modify requests and responses before or after sending the downstream request.过滤器请求和响应都可以被修改。\n\n\n\n当一个请求到达 网关 网关利用断言判定请求是否符合某个路由规则,如果符合就按照路由规则路由到指定地方\n要到达指定地方,就要经过一系列过滤器.\n\n参考官网: SpringCloudGateWay\n","categories":["GateWay"],"tags":["Spring","SpringBoot","SpringCloud","GateWay"]},{"title":"基于Redis的访问次数限制","url":"/2021/08/30/%E5%9F%BA%E4%BA%8ERedis%E7%9A%84%E8%AE%BF%E9%97%AE%E6%AC%A1%E6%95%B0%E9%99%90%E5%88%B6/","content":"前言某些时候,总有些艺高人胆大的家伙喜欢乱来,所以基于Redis写了一个限制访问次数的功能.\n需要用到AOP实现(本文使用),当然,也可以使用拦截器实现,看个人喜好吧.\n实现导入依赖&lt;!-- AOP依赖 -->\n&lt;dependency>\n            &lt;groupId>org.springframework.boot&lt;/groupId>\n            &lt;artifactId>spring-boot-starter-aop&lt;/artifactId>\n            &lt;version>2.1.5.RELEASE&lt;/version>\n&lt;/dependency>\n\n自定义注解创建一个自定义注解来标记需要限制访问的接口,当然你需要限制全部当我没说..\n/**\n * @author GAS\n */\n@Retention(RetentionPolicy.RUNTIME)\n@Target(ElementType.METHOD)\npublic @interface AccessLimit &#123;\n    //每秒\n    int seconds();\n    //最大访问次数\n    int maxcount();\n    //是否判断登录\n    boolean needLogin() default true;\n&#125;\n\n自定义AOP/**\n * @author LZC\n * @Date: 2020/11/1 0:12\n * @Description: 接口防刷拦截器\n */\n@Aspect\n@Component\npublic class LimitVisitAspect &#123;\n\n    @Autowired\n    private RedisUtil redisUtil;\n\n    @Pointcut(\"@annotation(accessLimit)\")\n    public void excudeService(AccessLimit accessLimit) &#123;\n    &#125;\n\n    @Around(\"excudeService(accessLimit)\")\n    public Object doAround(ProceedingJoinPoint pjp, AccessLimit accessLimit) throws Throwable &#123;\n\n        // 获得request对象\n        RequestAttributes ra = RequestContextHolder.getRequestAttributes();\n        ServletRequestAttributes sra = (ServletRequestAttributes) ra;\n        HttpServletRequest request = sra.getRequest();\n        String uri = request.getRequestURI();\n        String ip = request.getRemoteAddr();\n        String key = \"limit:\" + ip + \"-\" + uri;\n\n        String s = redisUtil.get(key);\n        //我这里因为项目需求 简单粗暴 单日只能访问一次\n        if(s == null)&#123;\n            // result的值就是被拦截方法的返回值\n            Object result = pjp.proceed();\n            redisUtil.set(key,\"1\");\n            return result;\n        &#125;\n\n        return AjaxResult.success(\"访问过多了\");\n    &#125;\n\n    /**\n     * 判断IP地址是否为内外IP\n     * 没用到\n     * @param addr\n     * @return\n     */\n    public static boolean internalIp(byte[] addr) &#123;\n        //使用方式\n        //if (ip.equals(\"0:0:0:0:0:0:0:1\") || ip.equals(\"127.0.0.1\")) &#123;\n        //    return true;\n        //&#125;\n        //byte[] addr = IPAddressUtil.textToNumericFormatV4(ip);\n        final byte b0 = addr[0];\n        final byte b1 = addr[1];\n        //10.x.x.x/8\n        final byte SECTION_1 = 0x0A;\n        //172.16.x.x/12\n        final byte SECTION_2 = (byte) 0xAC;\n        final byte SECTION_3 = (byte) 0x10;\n        final byte SECTION_4 = (byte) 0x1F;\n        //192.168.x.x/16\n        final byte SECTION_5 = (byte) 0xC0;\n        final byte SECTION_6 = (byte) 0xA8;\n        switch (b0) &#123;\n            case SECTION_1:\n                return true;\n            case SECTION_2:\n                if (b1 >= SECTION_3 &amp;&amp; b1 &lt;= SECTION_4) &#123;\n                    return true;\n                &#125;\n            case SECTION_5:\n                switch (b1) &#123;\n                    case SECTION_6:\n                        return true;\n                &#125;\n            default:\n                return false;\n        &#125;\n    &#125;\n&#125;\n\n\n获取到IP和访问URL将其作为一个key,存放在Redis中,并记录访问次数,如果超过返回错误或者其他消息\n\n定时删除限制/**\n * 每天清除redis的限制访问列表\n * 当然 也可以给redis设置过期时间\n * 但是我就是要这样写\n *\n * @author GAS\n * @date 2021年08月30日 16:42\n */\n@Component\n@EnableScheduling\n@EnableAsync\npublic class CleanLimitTask &#123;\n    @Autowired\n    private RedisUtil redisUtil;\n\n    @Async\n    @Scheduled(cron = \"0 0 23 * * ?\")//每天23点执行\n    public void cleanLimit()&#123;\n        Set&lt;String> keys = redisUtil.keys(\"limit:*\");\n        redisUtil.delete(keys);\n    &#125;\n&#125;\n\n最后在你需要限制的地方加上注解就行了\n@Controller\npublic class testController&#123;\n    @RequestMapping(\"/hello\")\n    @AccessLimit(seconds = 5, maxcount = 1)\n    public String test(HttpServletRequest request)&#123;\n        return \"hello\";\n    &#125;\n&#125;\n\n参考文章1: springboot限制接口访问次数 - CSDN\n文章2: SpringBoot实现限制ip访问次数_It_BeeCoder的博客-CSDN博客_springboot 限制访问频率\n文章3: springboot接口限制访问次数_战战的坚果的博客-CSDN博客\n文章4: SpringBoot在一定时间内限制接口请求次数_qq_41084438的博客-CSDN博客_springboot限制接口访问次数\n","categories":["Redis"],"tags":["Spring","SpringBoot","Redis"]},{"title":"SpringBoot JSON时间数据差8小时","url":"/2021/08/23/SpringBoot-JSON%E6%97%B6%E9%97%B4%E6%95%B0%E6%8D%AE%E5%B7%AE8%E5%B0%8F%E6%97%B6/","content":"SpringBoot JSON时间数据差8小时写项目遇到一个大坑,md 突然发现前端传的时间和我接收到的时间不一样,我传回去的时间和显示的时间不一样,找了一会,定位问题发生在Json格式化的过程中.\n原因是spring转json的默认实现jackson中会根据时区去转换时间，而jackson的默认时区跟国内应该是相差8小时，所以在时间换算上自动减去了8小时。\n可以通过jackson 的注解 @JsonFormat 解决问题\n@JsonFormat(pattern=\"yyyy-MM-dd HH:mm:ss\" ,timezone = \"GMT+8\")\nprivate Date createTime;\n@JsonFormat(pattern=\"yyyy-MM-dd HH:mm:ss\" ,timezone = \"GMT+8\")\nprivate Date updateTime;\n\n也可以在 SpringBoot 配置文件中统一配置，推荐使用这种方式：\n　　spring.jackson.date-format=yyyy-MM-dd HH:mm:ss\n　　spring.jackson.time-zone=GTM+8 #或者Asia/Shanghai\n\n参考文章1: https://www.cnblogs.com/wbxk/p/10679556.html\n文字2: https://www.cnblogs.com/ZJPaang/p/13166555.html\n","categories":["SpringBoot"],"tags":["Spring","SpringBoot","Json"]},{"title":"UV统计","url":"/2021/08/16/UV%E7%BB%9F%E8%AE%A1/","content":"业务需求实现用户访问量统计\n实现过程\n使用Redis的hyperloglog实现用户访问量统计\n理由拦截器afterCompletion在整个请求完成之后，才拦截的,提供接口响应速度\n\n拦截代码:\n/**\n * 访客拦截器\n *\n * @author GAS\n * @date 2021年08月13日 14:46\n */\n@Component\npublic class VisitorInterceptor implements HandlerInterceptor &#123;\n\n    @Autowired\n    private RedisUtil redisUtil;\n\n    @Override\n    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123;\n        return true;\n    &#125;\n\n    @Override\n    public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception &#123;\n    &#125;\n\n    @Override\n    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception &#123;\n        \n        //获取来源\n        String terminal = request.getHeader(\"terminal\");\n\n        //get IP 去重\n        String ip = request.getRemoteHost();\n\n        //写入\n        redisUtil.recordUV(\"app\",ip);\n    &#125;\n\n&#125;\n\n拦截器配置:\n/**\n * @author GAS\n * @date 2021年08月13日 14:54\n */\n@Configuration\npublic class WebMvcConfig extends WebMvcConfigurationSupport &#123;\n    @Autowired\n    private VisitorInterceptor visitorInterceptor;\n\n    @Override\n    protected void addInterceptors(InterceptorRegistry registry) &#123;\n        //这里根据自己的实际情况调整\n        registry.addInterceptor(visitorInterceptor)\n                .addPathPatterns(\"/applets/**\")\n                .excludePathPatterns(\"/profile/**\",\"/process/**\")\n                .excludePathPatterns(\"/*/*.css\", \"/*/*.js\", \"/*/*.png\", \"/*/*.jpg\", \"/*/*.jpeg\");\n    &#125;\n\n    //配置一下这个 不然Swagger会访问不了\n    @Override\n    protected void addResourceHandlers(ResourceHandlerRegistry registry) &#123;\n        registry.addResourceHandler(\"swagger-ui.html\")\n                .addResourceLocations(\"classpath:/META-INF/resources/\");\n        registry.addResourceHandler(\"/webjars/**\")\n                .addResourceLocations(\"classpath:/META-INF/resources/webjars/\");\n    &#125;\n&#125;\n\n接着写一个Redis的操作:\n/**\n  * 将指定IP计入UV\n  * @param ip\n  */\npublic void recordUV(String terminal,String ip) &#123;\n    //获取时间作为key\n    SimpleDateFormat sdf = new SimpleDateFormat(\"yyyy-MM-dd\");\n    String time = sdf.format(new Date());\n\n    String key = terminal + \":\" + time;\n    //两天后过期 留着干嘛\n    expire(key,2,TimeUnit.DAYS);\n\n    redisTemplate.opsForHyperLogLog().add(key, ip);\n&#125;\n\n//获取UV\npublic Long getUV(String terminal)&#123;\n    //获取时间作为key\n    SimpleDateFormat sdf = new SimpleDateFormat(\"yyyy-MM-dd\");\n    String timeKey = sdf.format(new Date());\n    System.out.println(terminal+\":\"+timeKey);\n    return redisTemplate.opsForHyperLogLog().size(terminal+\":\"+timeKey);\n&#125;\n\n然后继续写一个定时器,将我们的数据定时写入数据库做个持久化\n// @Component注解用于对那些比较中立的类进行注释；\n// 相对与在持久层、业务层和控制层分别采用 @Repository、@Service 和 @Controller 对分层中的类进行注释\n@Component\n@EnableScheduling // 1.开启定时任务\n@EnableAsync // 2.开启多线程\npublic class RedisScheduleTask &#123;\n\n    @Autowired\n    private RedisUtil redisUtil;\n\n    @Autowired\n    private IProVisitRecordsNumberService proVisitRecordsNumberService;\n\n    @Async\n    @Scheduled(cron = \"0 58 * * * ?\") // 每小时\n    public void first() throws InterruptedException &#123;\n        //获取来自 小程序 的访问数\n        Long app = redisUtil.getUV(\"app\");\n        System.out.println(app);\n\n        ProVisitRecordsNumber pvrn = new ProVisitRecordsNumber();\n        Calendar cal = Calendar.getInstance();\n\n        //年\n        pvrn.setYear(String.valueOf(cal.get(Calendar.YEAR)));\n        //月\n        pvrn.setMonth(String.valueOf(cal.get(Calendar.MONTH)));\n        //日\n        pvrn.setDay(String.valueOf(cal.get(Calendar.DATE)));\n        //时\n        pvrn.setHour(String.valueOf(cal.get(Calendar.HOUR_OF_DAY)));\n        //设置访问数\n        pvrn.setVisitorNumber(app);\n        //来自小程序设置为 1L\n        pvrn.setTerminal(1L);\n\n        proVisitRecordsNumberService.insertProVisitRecordsNumber(pvrn);\n\n    &#125;\n&#125;\n\n然后剩下的就是查了,这就不写了吧.\nSQLCREATE TABLE `pro_visit_records_number` (\n  `id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT 'ID',\n  `year` varchar(25) NOT NULL COMMENT '年份',\n  `month` varchar(25) NOT NULL COMMENT '月份',\n  `day` varchar(25) NOT NULL COMMENT '天',\n  `hour` varchar(25) NOT NULL COMMENT '小时',\n  `visitor_number` int(11) NOT NULL DEFAULT '0' COMMENT '访问人数',\n  `create_time` datetime NOT NULL COMMENT '创建时间',\n  `terminal` bigint(20) NOT NULL COMMENT '用户终端',\n  PRIMARY KEY (`id`),\n  KEY `pro_visit_records_number_create_time_IDX` (`create_time`) USING BTREE\n) ENGINE=InnoDB AUTO_INCREMENT=89 DEFAULT CHARSET=utf8 COMMENT='访问人数统计';\n\n参考文章1:https://blog.csdn.net/yaologos/article/details/106174535\n文章2:https://blog.csdn.net/ws13575291650/article/details/113184215\n文章3:https://blog.csdn.net/ws13575291650/article/details/113187031\n","categories":["SpringBoot"],"tags":["SpringBoot","Java","UV"]},{"title":"Java-IO","url":"/2021/08/11/Java-IO/","content":"流流:内存与储存设备之间传输数据的通道\n输入流:将存储设备中的内容读入到内存中\n输出流:将内存中的内容写入到存储设备中\n字节流:以字节为单位,可以读写所有数据\n字符流:以字符为单位,可以读写文本数据\n节点流:具有实际传输数据的读写功能\n过滤流:在节点流的基础之上增强功能\n字节流字节流基类\nInputStream字节流输入基类,抽象类是表示字节输入流的所有类的超类.\n// 从输入流中读取数据的下一个字节\nabstract int read()\n// 从输入流中读取一定数量的字节，并将其存储在缓冲区数组 b中\nint read(byte[] b)\n// 将输入流中最多 len 个数据字节读入 byte 数组\nint read(byte[] b, int off, int len)\n// 跳过和丢弃此输入流中数据的 n个字节\nlong skip(long n)\n// 关闭此输入流并释放与该流关联的所有系统资源\nOutputStream字节输出流基类,抽象类是表示输出字节流的所有类的超类.\n// 将 b.length 个字节从指定的 byte 数组写入此输出流\nvoid write(byte[] b)\n// 将指定 byte 数组中从偏移量 off 开始的 len 个字节写入此输出流\nvoid write(byte[] b, int off, int len)\n// 将指定的字节写入此输出流\nabstract void write(int b)\n// 关闭此输出流并释放与此流有关的所有系统资源\nvoid close()\n// 刷新此输出流并强制写出所有缓冲的输出字节\nvoid flush()\n\n字节文件操作流FileInputStream// 构造方法\n// 通过打开一个到实际文件的连接来创建一个FileInputStream，该文件通过文件系统中的File对象file指定\nFileInputStream(File file)\n// 通过打开一个到实际文件的连接来创建一个FileInputStream，该文件通过文件系统中的路径name指定\nFileInputStream(String name)\n\n//基本使用\nFileInputStream fis = new FileInputStream(\"C:\\\\Users\\\\1\\\\Documents\\\\Test.txt\");\n\n//单个字节读取\nint data = 0;\nwhile ((data = fis.read()) != -1) &#123;\n    System.out.println((char)data);\n&#125;\n\n//多个字节读取\nbyte[] buf = new byte[1024];\nint count = 0;\nwhile ((count = fis.read(buf)) != -1) &#123;\n    /**\n      * 参数1为要显示的数组,这里是buf\n      * 参数2为代表数组从什么地方开始显示,这里为下标0的地方开始\n      * 参数3为显示几个元素,这里显示count个元素\n      */\n    System.out.println(new String(buf, 0, count));\n&#125;\n//一次读取一个字节数组，提高了操作效率,IO流使用完毕一定要关闭\nfis.close();\nSystem.out.println(\"close\");\n\nFileOutputStream//构造方法\n// 创建一个向指定File对象表示的文件中写入数据的文件输出流\nFileOutputStream(File file)\n// 创建一个向指定File对象表示的文件中写入数据的文件输出流\nFileOutputStream(File file, boolean append)\n// 创建一个向具有指定名称的文件中写入数据的输出文件流\nFileOutputStream(String name)\n// 创建一个向具有指定name的文件中写入数据的输出文件流\nFileOutputStream(String name, boolean append)\n\n//基本使用\nOutputStream fos = new FileOutputStream(new File(\"test.txt\"));\n// 写出数据\nfos.write(69);//这里插入的是对应的ascii表的对应编码\nfos.write('a');\nfos.write('b');\n// 关闭IO流\nfos.close();\n// 内容追加写入\nOutputStream fos = new FileOutputStream(\"test.txt\", true);\n// 输出换行符\nfos.write(\"\\r\\n\".getBytes());\n// 输出追加内容\nfos.write(\"hello\".getBytes());\n// 关闭IO流\nfos.close();\n//输出的目的地文件不存在，则会自动创建，不指定盘符的话，默认创建在项目目录下;输出换行符时一定要写\\r\\n不能只写\\n,因为不同文本编辑器对换行符的识别存在差异性。\n\n学完上边这些,下面实现一个复制操作\n//文件字节输入流\nFileInputStream fis = new FileInputStream(\"C:\\\\Users\\\\1\\\\Pictures\\\\o_201106013133212.jpg\");\n\n//文件字节输出流\nFileOutputStream fos = new FileOutputStream(\"C:\\\\Users\\\\1\\\\Pictures\\\\cpoy.jpg\");\n\n//复制\nbyte[] buf = new byte[1024];\nint count = 0;\nwhile ((count = fis.read(buf)) != -1)&#123;\n    fos.write(buf,0,count);\n&#125;\n\n//记得关闭\nfis.close();\nfos.close();\n\n字节缓存流BufferedInputStreamBufferedInputStream bis = new BufferedInputStream(new FileInputStream(\"C:\\\\Users\\\\1\\\\Documents\\\\Test.txt\"));\n\n//读取\nint data = 0;\nwhile ((data = bis.read()) != -1)&#123;\n    System.out.print((char) data);\n&#125;\n\n//读取\nbyte[] data = new byte[1024];\nint count = 0;\nwhile ((count = bis.read(data)) != -1) &#123;\n    System.out.println(new String(data,0,count));\n&#125;\n\nbis.close();\n\nBufferedOutputStreamBufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(\"C:\\\\Users\\\\1\\\\Documents\\\\TestBuf.txt\"));\n\nfor (int i = 0; i &lt; 10; i++) &#123;\n    bos.write(\"hello world\\r\\n\".getBytes());//先写入缓冲区\n    bos.flush();//刷新到硬盘\n&#125;\n\nbos.close();//这里执行close会执行flush\n\n对象流使用流传输对象的过程称之为序列化、反序列化.\n需要序列化的对象必须实现Serializable接口,才可以被序列化.\n\n序列化\n序列化是将对象状态转换为可保持或传输的格式的过程.与序列化相对的是反序列化,它将流转换为对象,这两个过程结合起来,可以轻松的存储和传输数据.\n\nObjectOutputStreamOutputStream out = new FileOutputStream(\"C:\\\\Users\\\\1\\\\Documents\\\\stu.bin\");\nObjectOutputStream oos = new ObjectOutputStream(out);\n\n//序列化(写入操作)\nStudent stu = new Student(\"saber\",20);\noos.writeObject(stu);\n\n//关闭\noos.close();\n\nObjectInputStreamInputStream in = new FileInputStream(\"C:\\\\Users\\\\1\\\\Documents\\\\stu.bin\");\nObjectInputStream ois = new ObjectInputStream(in);\n\n//反序列化(读取)\nStudent stu = (Student) ois.readObject();\nStudent stu2 = (Student) ois.readObject();//如果重复读取 会报EOFException的错误\nSystem.out.println(stu);\n\nois.close();\n\n使用注意\n序列化类必须要实现Serializable接口\n序列化类中的对象属性也必须实现Serializable接口\n序列化版本ID,必须保证序列化的类和反序列化的类是同一个类\n使用transient修饰的属性将不参与序列化\n静态属性不会被序列化\n序列化多个对象可以借助集合实现\n\n字符流常见字符编码\n\n\n编码\n\n\n\n\nISO-8859-1\n收录除ASCII外,还包括西欧、希腊语、泰语、阿拉伯语、希伯来语对应的文字符号\n\n\nUTF-8\n针对Unicode码表的可变长度字符编码\n\n\nGB2312\n简体中文\n\n\nGBK\n简体中文、扩充\n\n\nBIG5\n中国台湾、繁体中文\n\n\n注意:当编码方式和解码方式不一样时,会出现乱码\n字符流基类参考文章1:https://blog.csdn.net/qq_33642117/article/details/52074796\n文章2:https://baijiahao.baidu.com/s?id=1633305649182361563\n","categories":["Java"],"tags":["Java","IO"]},{"title":"SpringBoot-Redis-消息队列","url":"/2021/08/07/SpringBoot-Redis-%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/","content":"前言\n首先要明确消息队列的作用:异步、解耦、削峰\n就算平时开发中,没有大流量,解耦和异步几乎也是离不开的,这就体现了MQ的重要性\n但是,总有公司不用啊,但是Redis总用吧,Redis的List结构非常适合用来作消息队列\n\n使用Redis实现消息队列有两种方式\n\nRedis队列模式\nRedis发布订阅模式\n\n原理我们需要了解Redis的命令\nRedis的List有两种命令方式,均满足先进先出的队列模式\n\nlpush rpop:非阻塞式\nlpush brpop:阻塞式\n\nlpush rpop127.0.0.1:6379[2]&gt; lpush testmq a b c\t\t&#x2F;&#x2F;创建队列\n(integer) 3\n127.0.0.1:6379[2]&gt; lrange testmq 0 -1\t\t&#x2F;&#x2F;查看value\n1) &quot;c&quot;\n2) &quot;b&quot;\n3) &quot;a&quot;\n127.0.0.1:6379[2]&gt; rpop testmq\t\t\t\t&#x2F;&#x2F;取值\n&quot;a&quot;\n127.0.0.1:6379[2]&gt; rpop testmq\t\t\t\t&#x2F;&#x2F;...\n&quot;b&quot;\n127.0.0.1:6379[2]&gt; rpop testmq\t\t\t\t&#x2F;&#x2F;...\n&quot;c&quot;\n127.0.0.1:6379[2]&gt; lrange testmq 0 -1\t\t&#x2F;&#x2F;已经没有数据了\n(empty list or set)\n127.0.0.1:6379[2]&gt; keys *\t\t\t\t\t&#x2F;&#x2F;没有值时,队列会被删除\n(empty list or set)\n127.0.0.1:6379[2]&gt; rpop testmq\t\t\t\t&#x2F;&#x2F;但是还可以取值\n(nil)\n\nlpush brpop127.0.0.1:6379[1]&gt; brpop testmq 0\t\t\t&#x2F;&#x2F;执行brpop命令,但是并没有key&#x3D;testmq的队列,陷入阻塞中\n\n\n127.0.0.1:6379[1]&gt; lpush testmq a b\t\t\t&#x2F;&#x2F;这里打开了一个新的cli,并向testmq中插入数据a b\n(integer) 2\n127.0.0.1:6379[1]&gt;\n\n127.0.0.1:6379[1]&gt; brpop testmq 0\t\t\t&#x2F;&#x2F;在看原来的cli,可以看出,已经取到值了,还可以看到等待了多久\n1) &quot;testmq&quot;\n2) &quot;a&quot;\n(201.71s)\n\n127.0.0.1:6379[1]&gt; lrange testmq 0 -1\t\t&#x2F;&#x2F;查看testmq,可以看出a已经被取走\n1) &quot;b&quot;\n\n\n127.0.0.1:6379[1]&gt; keys *\n(empty list or set)\n127.0.0.1:6379[1]&gt; lpush testmq a\t\t\t&#x2F;&#x2F;向testmq中添加a\n(integer) 1\n127.0.0.1:6379[1]&gt; lpush testmq2 b\t\t\t&#x2F;&#x2F;向testmq2中添加b\n(integer) 1\n127.0.0.1:6379[1]&gt; lrange testmq 0 -1\t\t&#x2F;&#x2F;查看testmq\n1) &quot;a&quot;\n127.0.0.1:6379[1]&gt; lrange testmq2 0 -1\t\t&#x2F;&#x2F;查看testmq2\n1) &quot;b&quot;\n127.0.0.1:6379[1]&gt; brpop testmq2 testmq 0\t&#x2F;&#x2F;brpop可以接收多个key,会按照顺序读取,这里可以实现一个优先级的功能,这里可以看出接收了testmq2的value\n1) &quot;testmq2&quot;\n2) &quot;b&quot;\n\n从命令中可以看出,brpop可以接收多个键,意义是同时检测多个键,如果所有键都没有元素,则阻塞,如果其中一个有元素则从该键中弹出该元素,只弹出一个消息.\n(会按照key的顺序进行读取，可以实现具有优先级的队列)。\n代码消费者并没有内置消费者监听器来实现，可以直接使用定时器实现\n@Component\npublic class MsgTask &#123;\n\n    @Resource\n    private RedisTemplate redisTemplate;\n\n    @Scheduled(cron=\"*/5 * * * * *\")\n    public void sendMsg() &#123;\n        Object listMQ = redisTemplate.opsForList().rightPop(\"listMQ\", 0, TimeUnit.SECONDS);\n        System.out.println(listMQ.toString());\n    &#125;\n&#125;\n\n然后使用普通的添加方法就实现了这个简单的消息队列了\nredisTemplate.opsForList().leftPush(\"listMQ\",\"a\");\n\n参考文章1:https://blog.csdn.net/qq_42175986/article/details/88417023\n文章2:https://springboot.io/t/topic/1013\n文章3:https://yampery.github.io/2019/01/05/redis/rdsmq/\n文章4:https://www.jianshu.com/p/d32b16f12f09\n","categories":["SpringBoot"],"tags":["SpringBoot","Redis"]},{"title":"SpringBoot-Redis-过期事件","url":"/2021/08/06/SpringBoot-Redis-%E8%BF%87%E6%9C%9F%E4%BA%8B%E4%BB%B6/","content":"需求需要实现一个超时通知的功能,又不想定时任务扫,所以就百度百度发现了这个,Redis的过期监听事件,就是向Redis里存放一条记录,把需要的信息存在key中,设置过期事件,一旦过期,就触发事件.\n实现要实现这个功能,需要先修改Redis的配置文件.\n打开.conf文件,找到notify-keyspace-events这个值,默认值为” “,将其修改为notify-keyspace-events Ex\n也可以通过命令设置,执行如下\n&#x2F;&#x2F;修改\nconfig set notify-keyspace-events &quot;Ex&quot;\n&#x2F;&#x2F;查看\nconfig get notify-keyspace-events\n\n参数解析\n\n\n字符\n发送通知\n\n\n\nK\n键空间通知，所有通知以 keyspace@ 为前缀，针对Key\n\n\nE\n键事件通知，所有通知以 keyevent@ 为前缀，针对event\n\n\ng\nDEL 、 EXPIRE 、 RENAME 等类型无关的通用命令的通知\n\n\n$\n字符串命令的通知\n\n\nl\n列表命令的通知\n\n\ns\n集合命令的通知\n\n\nh\n哈希命令的通知\n\n\nz\n有序集合命令的通知\n\n\nx\n过期事件：每当有过期键被删除时发送\n\n\ne\n驱逐(evict)事件：每当有键因为 maxmemory 政策而被删除时发送\n\n\nA\n参数 g$lshzxe 的别名，相当于是All\n\n\n输入的参数中至少需要一个 K 或者 E,不然不会触发任何通知\n斜体 表示通用的操作或者事件\n粗体 表示特定数据类型的操作\n事件类型对于每个修改数据库的操作,键空间通知都会发送两种不同类型的事件消息: keyspace 和  keyevent.\n以keyspace为前缀的频道被称为 键空间通知key-space notification\n以keyevent为前缀的频道被称为 键事件通知key-event notification\n事件通知是以 __keyspace@DB __: KeyPattern 或 __keyevent@DB__:OpsType 的格式来发送信息的.\nDB表示第几个数据库\nKeyPattern表示需要监控的键模式,可以用通配符.\nOpsType表示操作类型\n所以,如果想订阅特殊的Key上的事件,应该订阅Keyspace\n所以执行对0号数据库的myKey键执行DEL操作时,系统将发布两条消息, 相当于执行以下两个 publish 命令：\nPUBLISH __keyspace@0__:myKey del\nPUBLISH __keyevent@0__:del  myKey\n\n订阅第一个频道 __keyspace@0__:myKey 可以接收0号数据库所有修改myKey的事件\n订阅第二个频道 __keyevent@0__:del 可以接收0号数据库所有执行del命令的键\n订阅使用subscribe 和psubscribe命令来对特点主题进行订阅,完成通知的过程\nSUBSCRIBE channel [channel ...]\nPSUBSCRIBE channelPattern [channelPattern ...]\n\nPSUBSCRIBE对比SUBSCRIBE唯一不同就是支持通配符,每个模式以 * 作为匹配符,比如 huangz* 匹配所有以 huangz.显然支持通配符的性能消耗会大一点.\n命令实践 1：订阅\n    subscribe __keyspace@0__:cool\nReading messages... (press Ctrl-C to quit)\n1) &quot;subscribe&quot;                   # 返回值的类型：显示订阅成功\n2) &quot;__keyspace@0__:cool&quot;         # 订阅的Channel名\n3) (integer) 1                   # 目前已订阅的频道数量\n\n2：设置失效\n  setex cool 1 val                 # cool&#x3D;val 1秒失效\n\n3：失效消息\n1)&quot;message&quot;                      # 返回值的类型：信息\n2)__keyspace@0__:cool”           # 来源(从哪个Channel发送过来)\n3) “expired&quot;                     # 信息内容\n\n注：对于psubscribe，消息会多一行\n1) “pmessage”                     # 返回值的类型：信息\n2) &quot;__keyspace@0__:cool*”         # 来源(从哪个ChannelPattern发送过来)\n3) &quot;__keyspace@0__:cool&quot;          # 实际的Channel\n4) “expired&quot;                      # 信息内容\n\nSpring实现最主要的是KeyExpirationEventMessageListener类,此类是对MessageListener接口的实现\n看源码,它其实就是监听的一个__keyevent@*__:expired事件\npublic class KeyExpirationEventMessageListener extends KeyspaceEventMessageListener implements ApplicationEventPublisherAware &#123;\n    //看这里-----------------------------------------------------------------------↓↓↓↓↓↓\n    private static final Topic KEYEVENT_EXPIRED_TOPIC = new PatternTopic(\"__keyevent@*__:expired\");\n    @Nullable\n    private ApplicationEventPublisher publisher;\n\n    public KeyExpirationEventMessageListener(RedisMessageListenerContainer listenerContainer) &#123;\n        super(listenerContainer);\n    &#125;\n\n    protected void doRegister(RedisMessageListenerContainer listenerContainer) &#123;\n        listenerContainer.addMessageListener(this, KEYEVENT_EXPIRED_TOPIC);\n    &#125;\n\n    protected void doHandleMessage(Message message) &#123;\n        this.publishEvent(new RedisKeyExpiredEvent(message.getBody()));\n    &#125;\n\n    protected void publishEvent(RedisKeyExpiredEvent event) &#123;\n        if (this.publisher != null) &#123;\n            this.publisher.publishEvent(event);\n        &#125;\n\n    &#125;\n\n    public void setApplicationEventPublisher(ApplicationEventPublisher applicationEventPublisher) &#123;\n        this.publisher = applicationEventPublisher;\n    &#125;\n&#125;\n\n我们只需要继承它,并重写onMessage即可\n@Component\npublic class RedisKeyExpirationListener extends KeyExpirationEventMessageListener &#123;\n    public RedisKeyExpirationListener(RedisMessageListenerContainer container) &#123;\n        super(container);\n    &#125;\n  \n    /**\n     * 针对redis数据失效事件，进行数据处理\n     * @param message\n     * @param pattern\n     */\n    @Override\n    public void onMessage(Message message, byte[] pattern) &#123;\n       String key=message.toString();//生效的key\n        if (key!=null &amp;&amp; key.startsWith(\"order\"))&#123;//从失效key中筛选代表订单失效的key\n            //截取订单号，查询订单，如果是未支付状态则取消订单\n            String orderNo=key.substring(5);\n            System.out.println(\"订单号为：\"+orderNo+\"的订单超时未支付，取消订单\");\n  \n        &#125;\n    &#125;\n&#125;\n\n然后在RedisConfig中配置如下\n@Bean\nRedisMessageListenerContainer container(RedisConnectionFactory connectionFactory) &#123;\n    RedisMessageListenerContainer container = new RedisMessageListenerContainer();\n    container.setConnectionFactory(connectionFactory);\n\n    return container;\n&#125;\n\n我们只需把过期事件设置为48小时,就实现了我们的需求\n缺陷\n只能获取到失效的key，但是此时不能根据key获取value值，因为该事件是在数据失效后才触发\n\n有个简单的解决办法，就是一份数据存两份比如你现在需要set一份数据：key：value可以额外再set一份value相同但key有指定规则的数据：key_copy：value第二份数据过期时间相对第一份数据稍微长一点这样过期事件执行时可以拿着key根据指定的规则拼装出第二份数据的key，从而得到想要的value缺点就是当你需要set的地方比较多时维护起来就非常恶心\n\n\nRedis的过期事件可能有点不准时,这是因为Redis本身的机制问题\n\nRedis有一下两种删除方式\n\n当键被访问时,程序会对键进行一次检查,如果以过期,那么键将被删除\n底层系统会在后台随机查找并删除过期的键,从而处理这些已经过期,但未被查找的键\n\n当键被以上两个程序任意一个发现并删除时,Redis会产生一个expired通知\nRedis并不保证生存时间变为0时会被立即删除,\n如果程序没有访问这个键,或者带有过期事件的键非常多的话,那么在键的生存时间变为0时,直到真正删除这些键,会存在一个时间差,越多越明显.\n因此,产生expired通知的时间才是过期键被删除的时间,而不是键的生存时间为0的时候.\n\n\n\n参考文章1:https://my.oschina.net/u/182501/blog/1927210\n文章2:https://blog.csdn.net/qijiqiguai/article/details/78229111\n文章3:http://redisdoc.com/topic/notification.html\n文章4:https://segmentfault.com/a/1190000022735302\n文章5:https://blog.csdn.net/for_the_time_begin/article/details/90376873\n","categories":["SpringBoot"],"tags":["SpringBoot","Redis"]},{"title":"SpringBoot-Redis-发布订阅","url":"/2021/08/06/SpringBoot-Redis-%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85/","content":"前言消息队列是常用的异步通信解决方案,一般有两种解决方案,一种为队列模式,一种为发布订阅模式,对于Redis而言,官方就支持这种.\n发布订阅发布订阅是一种消息模式,消息的发送者(称为发布者)不会将消息直接发送给特定的接收者(称为订阅者)。而是将发布的消息分为不同的类别，无需了解哪些订阅者(如果有的话)可能存在。同样的，订阅者可以表达对一个或多个类别的兴趣，只接收感兴趣的消息，无需了解哪些发布者(如果有的话)存在。\n就如同微信公众号一样,\n\n代码按照官网的教程,首先我们先创建一个消息发布者和消息订阅者.\n消息订阅者/**\n * 消息订阅者\n */\npublic class Receiver &#123;\n    private static final Logger LOGGER = LoggerFactory.getLogger(Receiver.class);\n\n    private AtomicInteger counter = new AtomicInteger();\n\n    //消费方法\n    public void receiveMessage(String message) &#123;\n        LOGGER.info(\"收到消息为: &lt;\" + message + \">\");\n        counter.incrementAndGet();\n    &#125;\n&#125;\n\n注册订阅者在RedisConfig类添加如下代码\n/**\n * 将订阅者 注入到容器中\n */\n@Bean\nRedisMessageListenerContainer container(RedisConnectionFactory connectionFactory,\n                                        MessageListenerAdapter listenerAdapter) &#123;\n    RedisMessageListenerContainer container = new RedisMessageListenerContainer();\n    container.setConnectionFactory(connectionFactory);\n    //订阅者和topic\n    container.addMessageListener(listenerAdapter, new PatternTopic(\"chat\"));\n\n    return container;\n&#125;\n\n//注册订阅者\n@Bean\nMessageListenerAdapter listenerAdapter(Receiver receiver) &#123;\n    return new MessageListenerAdapter(receiver, \"receiveMessage\");\n&#125;\n\n//我们的订阅者\n@Bean\nReceiver receiver() &#123;\n    return new Receiver();\n&#125;\n\nlistenerAdapter方法中创建一个消息侦听器,并在container中注册,监听有关chat主题的消息,在MessageListenerAdapter中需要指定订阅者执行的方法(如果订阅者实现MessageListener接口则无须指定,下面演示).\n然后就可以通过RedisTemplate发送事件\n@Autowired\nprivate RedisTemplate redisTemplate;\n\n@Test\nvoid contextLoads() &#123;\n    redisTemplate.convertAndSend(\"chat\",\"asd\");\n&#125;\n\n实现MessageListener的订阅者/**\n * 消息订阅者\n */\npublic class Receiver implements MessageListener &#123;\n    private static final Logger LOGGER = LoggerFactory.getLogger(Receiver.class);\n\n    private AtomicInteger counter = new AtomicInteger();\n\n    @Override\n    public void onMessage(Message message, byte[] bytes) &#123;\n        LOGGER.info(\"收到消息为: &lt;\" + message.toString() + \">\");\n        counter.incrementAndGet();\n    &#125;\n&#125;\n\n在RedisConfig中修改如下\n//注册订阅者\n@Bean\nMessageListenerAdapter listenerAdapter(Receiver receiver) &#123;\n    return new MessageListenerAdapter(receiver);\n&#125;\n\n自定义消息体创建自定义的消息体\npublic class MessageEntity implements Serializable &#123;\n\n    private static final long serialVersionUID = 8632296967087444509L;\n\n    private String id;\n    \n    private String content;\n\n    public MessageEntity() &#123;\n        super();\n    &#125;\n\n    public MessageEntity(String id, String content) &#123;\n        super();\n        this.id = id;\n        this.content = content;\n    &#125;\n    \n    //get set 这里省略 记得加上\n\n    @Override\n    public String toString() &#123;\n        return \"MessageEntity [id=\" + id + \", content=\" + content + \"]\";\n    &#125;\n&#125;\n\n订阅者修改为:\n/**\n * 消息订阅者\n */\npublic class Receiver implements MessageListener &#123;\n    private static final Logger LOGGER = LoggerFactory.getLogger(Receiver.class);\n\n    private AtomicInteger counter = new AtomicInteger();\n\n    @Autowired\n    private RedisTemplate redisTemplate;\n\n    @Override\n    public void onMessage(Message message, byte[] pattern) &#123;\n        doBusiness(message);\n    &#125;\n\n    /**\n     * 打印 message body 内容\n     * @param message\n     */\n    public void doBusiness(Message message) &#123;\n        Object value = redisTemplate.getValueSerializer().deserialize(message.getBody());\n        System.out.println(\"consumer message: \" + value.toString());\n    &#125;\n&#125;\n\nredisTemplate.convertAndSend(\"chat\", new MessageEntity(\"1\", \"object\"));//发送事件 也可以发送普通的String\n\n最后用spring data redis实现redis订阅者,本质上还是Listener模式.\n参考文章1:https://blog.csdn.net/johnf_nash/article/details/87891293\n官网:https://spring.io/guides/gs/messaging-redis/\n","categories":["SpringBoot"],"tags":["SpringBoot","Redis"]},{"title":"Java代理之动态代理","url":"/2021/07/19/Java%E4%BB%A3%E7%90%86%E4%B9%8B%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/","content":"引言学习了前面的静态代理,我们知道了它的一些缺点,该如何改进它呢,当然是使用本篇的重点,通过让代理类动态生成,也就是动态代理.\n为什么类可以动态生成,这涉及到类的加载机制,这里不讲……\n实现动态代理的方向\n有两种方式:\n\n通过实现接口的方式 -&gt; JDK动态代理\n通过继承类的方式 -&gt; CGLIB动态代理\n\nJDK动态代理JDK动态的实现\n\n动态代理是由java.lang.reflect.Proxy反射类提供实例创建的调派,由Proxy.newProxyInstance()方法创建对应的实例对象.\n通过java.lang.reflect.InvocationHandler接口中的invoke()方法进行调用,增强,转发实现业务.\n\n\n我们接着之前的场景,我们在通过代购帮我们购买了好多次物品以后，代购现在越来越有钱了，代购的商品种类也更加丰富，他便自己开了一家代购公司D，这个时候我们如果想要去通过代购去买一件商品，就不在会是每一次都是同一个人去接待我们，可能是D公司的小刘美女业务员、也可能是小王帅哥业务员。即：动态代理就是，同一个服务由不同的实例去帮我们实现。\n\n代码示例A抽象对象\npublic interface ASellService &#123;\n    void sale(String name);\n&#125;\n\nA真实对象(商家A)\npublic class AMerchantServiceImplA implements ASellService &#123;\n    @Override\n    public void sale(String name) &#123;\n        System.out.println(name + \"购买了A商品\");\n    &#125;\n&#125;\n\nB抽象对象\npublic interface BSellService &#123;\n    void sale(String name);\n&#125;\n\nB真实对象(商家B)\npublic class BMerchantServiceImpl implements BSellService &#123;\n    @Override\n    public void sale(String name) &#123;\n        System.out.println(name + \"购买了B商品\");\n    &#125;\n&#125;\n\nJDK动态代理对象(代理公司)\npublic class DCompany implements InvocationHandler &#123;\n    // 代理对象需要包含真实对象，为提升真实对象的复用性，则使用Object接受\n    private Object objFactory;\n\n    public Object getObjFactory()&#123;\n        return objFactory;\n    &#125;\n\n    public void setObjFactory(Object objFactory)&#123;\n        this.objFactory = objFactory;\n    &#125;\n\n    // 使用JDK代理类获取代理对象\n    public Object getProxyInstance()&#123;\n        return Proxy.newProxyInstance(objFactory.getClass().getClassLoader(), objFactory.getClass().getInterfaces(), this);\n    &#125;\n\n    @Override\n    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;\n        // 进行业务增强\n        System.out.println(\"JDK动态代理对业务进行了增强处理\");\n        // 通过反射调用方法本身\n        Object invoke = method.invoke(objFactory, args);\n        System.out.println(\"JDK动态代理对业务进行了增强处理结束\");\n        return invoke;\n    &#125;\n&#125;\n\n测试类\npublic class DynamicProxyTest &#123;\n    public static void main(String[] args) &#123;\n        // A商品卖家\n        ASellService A = new AMerchantServiceImplA();\n        // B商品卖家\n        BSellService B = new BMerchantServiceImpl();\n\n        // 购买者\n        String customerName = \"张三\";\n        // 代购公司\n        DCompany dCompany = new DCompany();\n        dCompany.setObjFactory(A);\n        ASellService AProxyInstance = (ASellService) dCompany.getProxyInstance();\n\n        System.out.println(\"业务员\"+AProxyInstance.getClass()+\"接待\"+customerName);\n        AProxyInstance.sale(customerName);\n\n        System.out.println(\"--------------------------------------------------------------\");\n\n        dCompany.setObjFactory(B);\n        BSellService BProxyInstance = (BSellService) dCompany.getProxyInstance();\n        System.out.println(\"业务员\"+BProxyInstance.getClass()+\"接待\"+customerName);\n        BProxyInstance.sale(customerName);\n    &#125;\n&#125;\n\n结果:\n\n我们可以清晰的看到JDK动态代理执行后打印的结果，以及Proxy动态调派帮我们由不同的代理对象$Proxy X实例化真实对象。\n保存代理类\n借助工具类,保存代理类,\n（通过设置环境变量sun.misc.ProxyGenerator.saveGeneratedFiles=true也可以保存代理类）\nSystem.getProperties().setProperty(\"sun.misc.ProxyGenerator.saveGeneratedFiles\", \"true\");\n\npublic class ProxyUtils &#123;\n    /**\n     * 将根据类信息动态生成的二进制字节码保存到硬盘中，默认的是clazz目录下\n     * params: clazz 需要生成动态代理类的类\n     * proxyName: 为动态生成的代理类的名称\n     */\n    public static void generateClassFile(Class clazz, String proxyName) &#123;\n        // 根据类信息和提供的代理类名称，生成字节码\n        byte[] classFile = ProxyGenerator.generateProxyClass(proxyName, clazz.getInterfaces());\n        String paths = clazz.getResource(\".\").getPath();\n        System.out.println(paths);\n        FileOutputStream out = null;\n        try &#123;\n            //保留到硬盘中\n            out = new FileOutputStream(paths + proxyName + \".class\");\n            out.write(classFile);\n            out.flush();\n        &#125; catch (Exception e) &#123;\n            e.printStackTrace();\n        &#125; finally &#123;\n            try &#123;\n                out.close();\n            &#125; catch (IOException e) &#123;\n                e.printStackTrace();\n            &#125;\n        &#125;\n    &#125;\n&#125;\n\n然后在代码最后一行加入代码\n// 保存JDK动态代理生成的代理类，类名保存为 asd\nProxyUtils.generateClassFile(BMerchantServiceImpl.class, \"asd\");\n\n代码如下:\npublic final class asd extends Proxy implements BSellService &#123;\n    private static Method m1;\n    private static Method m3;\n    private static Method m2;\n    private static Method m0;\n\n    public asd(InvocationHandler var1) throws  &#123;\n        super(var1);\n    &#125;\n\n    public final boolean equals(Object var1) throws  &#123;\n        // 省略...\n    &#125;\n\n    public final String toString() throws  &#123;\n        // 省略...\n    &#125;\n\n    public final void select() throws  &#123;\n        try &#123;\n            super.h.invoke(this, m4, (Object[])null);\n        &#125; catch (RuntimeException | Error var2) &#123;\n            throw var2;\n        &#125; catch (Throwable var3) &#123;\n            throw new UndeclaredThrowableException(var3);\n        &#125;\n    &#125;\n\n    public final int hashCode() throws  &#123;\n        // 省略...\n    &#125;\n\n    public final void update() throws  &#123;\n        try &#123;\n            super.h.invoke(this, m3, (Object[])null);\n        &#125; catch (RuntimeException | Error var2) &#123;\n            throw var2;\n        &#125; catch (Throwable var3) &#123;\n            throw new UndeclaredThrowableException(var3);\n        &#125;\n    &#125;\n\n    static &#123;\n        try &#123;\n            m1 = Class.forName(\"java.lang.Object\").getMethod(\"equals\", Class.forName(\"java.lang.Object\"));\n            m3 = Class.forName(\"com.company.dynamicAgent.BSellService\").getMethod(\"sale\", Class.forName(\"java.lang.String\"));\n            m2 = Class.forName(\"java.lang.Object\").getMethod(\"toString\");\n            m0 = Class.forName(\"java.lang.Object\").getMethod(\"hashCode\");\n        &#125; catch (NoSuchMethodException var2) &#123;\n            throw new NoSuchMethodError(var2.getMessage());\n        &#125; catch (ClassNotFoundException var3) &#123;\n            throw new NoClassDefFoundError(var3.getMessage());\n        &#125;\n    &#125;\n&#125;\n\n从上述代码可知:\n\nasd继承了 Proxy 类，并且实现了被代理的所有接口，以及equals、hashCode、toString等方法\n由于 asd继承了 Proxy 类，所以每个代理类都会关联一个 InvocationHandler 方法调用处理器\n类和所有方法都被 public final 修饰，所以代理类只可被使用，不可以再被继承\n每个方法都有一个 Method 对象来描述，Method 对象在static静态代码块中创建，以 m + 数字 的格式命名\n调用方法的时候通过 super.h.invoke(this, m1, (Object[])null); 调用，其中的 super.h.invoke 实际上是在创建代理的时候传递给 Proxy.newProxyInstance 的DCompany对象，它继承 InvocationHandler 类，负责实际的调用处理逻辑\n\n\n\nCGLIB动态代理先引入Maven包\n&lt;dependency>\n   &lt;groupId>cglib&lt;/groupId>\n   &lt;artifactId>cglib&lt;/artifactId>\n   &lt;version>3.3.0&lt;/version>\n&lt;/dependency>\n\n代码示例编写一个 LogInterceptor ，继承了 MethodInterceptor，用于方法的拦截回调\npublic class LogInterceptor implements MethodInterceptor &#123;\n\n    private Object target;//维护一个目标对象\n    public LogInterceptor(Object target) &#123;\n        this.target = target;\n    &#125;\n\n    //为目标对象生成代理对象\n    public Object getProxyInstance() &#123;\n        //工具类\n        Enhancer en = new Enhancer();\n        //设置父类\n        en.setSuperclass(target.getClass());\n        //设置回调函数\n        en.setCallback(this);\n        //创建子类对象代理\n        return en.create();\n    &#125;\n\n    /**\n     * @param object 表示要进行增强的对象\n     * @param method 表示拦截的方法\n     * @param objects 数组表示参数列表，基本数据类型需要传入其包装类型，如int-->Integer、long-Long、double-->Double\n     * @param methodProxy 表示对方法的代理，invokeSuper方法表示对被代理对象方法的调用\n     * @return 执行结果\n     * @throws Throwable\n     */\n    @Override\n    public Object intercept(Object object, Method method, Object[] objects, MethodProxy methodProxy) throws Throwable &#123;\n        before();\n        Object result = methodProxy.invokeSuper(object, objects);   // 注意这里是调用 invokeSuper 而不是 invoke，否则死循环，methodProxy.invokesuper执行的是原始类的方法，method.invoke执行的是子类的方法\n        after();\n        return result;\n    &#125;\n    private void before() &#123;\n        System.out.println(String.format(\"log start time [%s] \", new Date()));\n    &#125;\n    private void after() &#123;\n        System.out.println(String.format(\"log end time [%s] \", new Date()));\n    &#125;\n&#125;\n\n编写一个UserDao类，它没有接口，只有两个方法，select() 和 update()\npublic class UserDao &#123;\n    public void select() &#123;\n        System.out.println(\"UserDao 查询 selectById\");\n    &#125;\n    public void update() &#123;\n        System.out.println(\"UserDao 更新 update\");\n    &#125;\n&#125;\n\n测试\npublic class CglibTest &#123;\n    public static void main(String[] args) &#123;\n        //目标对象\n        UserDao target = new UserDao();\n        System.out.println(target.getClass());\n\n        //代理对象\n        UserDao proxy = (UserDao) new LogInterceptor(target).getProxyInstance();\n        System.out.println(proxy.getClass());\n\n        //执行代理对象方法\n        proxy.select();\n        proxy.update();\n    &#125;\n&#125;\n\n结果\nlog start time [Fri Dec 21 00:06:40 CST 2018] \nUserDao 查询 selectById\nlog end time [Fri Dec 21 00:06:40 CST 2018] \nlog start time [Fri Dec 21 00:06:40 CST 2018] \nUserDao 更新 update\nlog end time [Fri Dec 21 00:06:40 CST 2018] \n\nCGLIB创建动态代理类的模式:\n\n查找目标类上所有非final的public类型的方法定义;\n将这些方法的定义转换为字节码;\n将组成的字节码转换成相对应的代理的class对象\n实现MethodInterceptor接口，用来处理对代理类上所有方法的请求\n\nJDK动态代理和CGLIB动态代理JDK动态代理：基于Java反射机制实现，必须要实现了接口的业务类才能用这种办法生成代理对象。\ncglib动态代理：基于ASM机制实现，通过生成业务类的子类作为代理类。\nJDK Proxy 的优势：\n\n最小化依赖关系，减少依赖意味着简化开发和维护，JDK 本身的支持，可能比 cglib 更加可靠。\n平滑进行 JDK 版本升级，而字节码类库通常需要进行更新以保证在新版 Java 上能够使用。\n代码实现简单。\n\n基于类似 cglib 框架的优势：\n\n无需实现接口，达到代理类无侵入\n只操作我们关心的类，而不必为其他相关类增加工作量。\n高性能\n\n面试题描述动态代理的几种实现方式？分别说出相应的优缺点.\n代理可以分为 “静态代理” 和 “动态代理”，动态代理又分为 “JDK动态代理” 和 “CGLIB动态代理” 实现。\n静态代理：代理对象和实际对象都继承了同一个接口，在代理对象中指向的是实际对象的实例，这样对外暴露的是代理对象而真正调用的是 Real Object\n\n优点：可以很好的保护实际对象的业务逻辑对外暴露，从而提高安全性。\n缺点：不同的接口要有不同的代理类实现，会很冗余\n\nJDK 动态代理：\n\n为了解决静态代理中，生成大量的代理类造成的冗余；\nJDK 动态代理只需要实现 InvocationHandler 接口，重写 invoke 方法便可以完成代理的实现，\njdk的代理是利用反射生成代理类 Proxyxx.class 代理类字节码，并生成对象\njdk动态代理之所以只能代理接口是因为代理类本身已经extends了Proxy，而java是不允许多重继承的，但是允许实现多个接口\n优点：解决了静态代理中冗余的代理实现类问题。\n缺点：JDK 动态代理是基于接口设计实现的，如果没有接口，会抛异常。\n\nCGLIB 代理：\n\n由于 JDK 动态代理限制了只能基于接口设计，而对于没有接口的情况，JDK方式解决不了；\nCGLib 采用了非常底层的字节码技术，其原理是通过字节码技术为一个类创建子类，并在子类中采用方法拦截的技术拦截所有父类方法的调用，顺势织入横切逻辑，来完成动态代理的实现。\n实现方式实现 MethodInterceptor 接口，重写 intercept 方法，通过 Enhancer 类的回调方法来实现。\n但是CGLib在创建代理对象时所花费的时间却比JDK多得多，所以对于单例的对象，因为无需频繁创建对象，用CGLib合适，反之，使用JDK方式要更为合适一些。\n同时，由于CGLib由于是采用动态创建子类的方法，对于final方法，无法进行代理。\n优点：没有接口也能实现动态代理，而且采用字节码增强技术，性能也不错。\n缺点：技术实现相对难理解些。\n\nCGlib 对接口实现代理？\nimport net.sf.cglib.proxy.Enhancer;\nimport net.sf.cglib.proxy.MethodInterceptor;\nimport net.sf.cglib.proxy.MethodProxy;\nimport proxy.UserService;\nimport java.lang.reflect.Method;\n\n/**\n * 创建代理类的工厂 该类要实现 MethodInterceptor 接口。\n * 该类中完成三样工作：\n * （1）声明目标类的成员变量，并创建以目标类对象为参数的构造器。用于接收目标对象\n * （2）定义代理的生成方法，用于创建代理对象。方法名是任意的。代理对象即目标类的子类\n * （3）定义回调接口方法。对目标类的增强这在这里完成\n */\npublic class CGLibFactory implements MethodInterceptor &#123;\n    // 声明目标类的成员变量\n    private UserService target;\n\n    public CGLibFactory(UserService target) &#123;\n        this.target = target;\n    &#125;\n    // 定义代理的生成方法,用于创建代理对象\n    public UserService myCGLibCreator() &#123;\n        Enhancer enhancer = new Enhancer();\n        // 为代理对象设置父类，即指定目标类\n        enhancer.setSuperclass(UserService.class);\n        /**\n         * 设置回调接口对象 注意，只所以在setCallback()方法中可以写上this，\n         * 是因为MethodIntecepter接口继承自Callback，是其子接口\n         */\n        enhancer.setCallback(this);\n        return (UserService) enhancer.create();// create用以生成CGLib代理对象\n    &#125;\n    @Override\n    public Object intercept(Object obj, Method method, Object[] args, MethodProxy proxy) throws Throwable &#123;\n        System.out.println(\"start invoke \" + method.getName());\n        Object result = method.invoke(target, args);\n        System.out.println(\"end invoke \" + method.getName());\n        return result;\n    &#125;\n&#125;\n\n参考文章1:https://www.cnblogs.com/staticking/p/13628307.html\n文章2:https://www.cnblogs.com/whirly/p/10154887.html\n文章3:https://www.jianshu.com/p/9bcac608c714\n文章4:https://segmentfault.com/a/1190000011291179\n","categories":["Java"],"tags":["Java"]},{"title":"Java代理之静态代理","url":"/2021/07/19/Java%E4%BB%A3%E7%90%86%E4%B9%8B%E9%9D%99%E6%80%81%E4%BB%A3%E7%90%86/","content":"什么是代理代理就是给目标对象一个代理对象,并又代理对象控制目标的引用.\n为什么使用代理模式\n通过引入代理对象的方式,间接访问目标对象,避免不必要的复杂性.\n通过代理对象可以对原有的业务实现增强.\n\n举例：如果我们需要买国外的某一件商品A，这个时候我们一般有两个途径要么直接去国外买，要么可以找一些代购人员帮我们去购买。在这种情况下，我们由于直接去国外买，实在是太耗软妹币，而且还要花时间等等，这个时候我们最优的选择就是找代购购买，这样也帮我们省去了很多麻烦的事情。\n\n\n代码示例接口:\npublic interface ITargetFactoryService &#123;\n    void sale(String name);\n&#125;\n\n目标对象:\npublic class TargetFactoryServiceImpl implements ITargetFactoryService &#123;\n    @Override\n    public void sale(String name) &#123;\n        log.info(name+\"购买了商品A\");\n    &#125;\n&#125;\n\n代理对象:\npublic class ProxyImpl implements ITargetFactoryService &#123;\n    public ITargetFactoryService service;\n    \n    public ProxyImpl(ITargetFactoryService service)&#123;\n        super();\n        this.service = service;\n    &#125;\n\n    @Override\n    public void sale(String name) &#123;\n        before();\n        service.sale(\"代购\");\n        after();\n\n    &#125;\n\n    /**\n     * 后置增强\n     */\n    private void after() &#123;\n        log.info(\"代购在购买后得到了市场调研结果\");\n    &#125;\n\n    /**\n     * 前置增强\n     */\n    private void before() &#123;\n        log.info(\"代购在购买前做了市场调研\");\n    &#125;\n&#125;\n\n测试类:\npublic class SpsringJdbcApplication &#123;\n  public static void main(String[] args) &#123;\n    TargetFactoryServiceImpl service = new TargetFactoryServiceImpl();\n    ProxyImpl proxy = new ProxyImpl(service);\n    proxy.sale(\"代购\");\n    SpringApplication.run(SpsringJdbcApplication.class, args);\n  &#125;\n&#125;\n\n测试结果:\n\n通过示例可以看到,代理对象包含了目标对象,并且在业务处理上进行了一定的业务扩展,但却和目标对象继承于同一个接口.\n这种情况便是静态代理,适合业务情况比较简单,实现类少,需求变化不频繁,但是要对原有目标服务对象进行功能扩展,并且不修改原有服务,这个时候我们可以选择使用静态代理.\n静态代理的缺点如果此时业务继续扩展,在经过一定的调研之后,发现商品B更加收欢迎,这个时候我们就需要对业务继续进行扩展.\n接口\npublic interface ITargetFactoryBService &#123;\n    void saleB(String name);\n&#125;\n\n目标对象\npublic class ITargetFactoryBServiceImpl implements ITargetFactoryBService &#123;\n    @Override\n    public void saleB(String name) &#123;\n        log.info(name + \"购买了商品B\");\n    &#125;\n&#125;\n\n代理对象\npublic class ProxyTwoImpl implements ITargetFactoryService, ITargetFactoryBService &#123;\n\n    public ITargetFactoryService service;\n\n    public ITargetFactoryBService bService;\n\n    public ProxyTwoImpl(ITargetFactoryService service,ITargetFactoryBService bService)&#123;\n        super();\n        this.service = service;\n        this.bService = bService;\n    &#125;\n\n    @Override\n    public void sale(String name) &#123;\n        before();\n        service.sale(\"代购\");\n        after();\n\n    &#125;\n\n    @Override\n    public void saleB(String name) &#123;\n        before();\n        bService.saleB(\"代购\");\n        after();\n    &#125;\n\n    /**\n     * 后置增强\n     */\n    private void after() &#123;\n        log.info(\"代购在购买后得到了市场调研结果\");\n    &#125;\n\n    /**\n     * 前置增强\n     */\n    private void before() &#123;\n        log.info(\"代购在购买前做了市场调研\");\n    &#125;\n&#125;\n\n测试类:\npublic class SpsringJdbcApplication &#123;\n  public static void main(String[] args) &#123;\n    TargetFactoryServiceImpl service = new TargetFactoryServiceImpl();\n    ITargetFactoryBServiceImpl bService = new ITargetFactoryBServiceImpl();\n    ProxyTwoImpl proxy2 = new ProxyTwoImpl(service, bService);\n    proxy2.sale(\"代购\");\n    proxy2.saleB(\"代购\");\n    SpringApplication.run(SpsringJdbcApplication.class, args);\n  &#125;\n&#125;\n\n测试结果:\n\n在进行业务扩展时,需要对原有的代理类进行修改,如果后期需要更多的业务时,这个类将变得繁杂,大量的继承以及重写,牵一发而动全身,所以这种业务扩展性高,业务变化繁杂的情况不适合使用静态代理.\n总结\n违反Java设计模式开闭原则,即:程序对外扩展开放,对修改关闭.当要进行变更时,应该是新增代码来实现,而不是在原有代码上进行修改.\n扩展性差.\n可维护性差.\n代码耦合度高.\n\n参考:文章:https://www.cnblogs.com/staticking/p/13628267.html\n","categories":["Java"],"tags":["Java"]},{"title":"注解和反射","url":"/2021/07/13/%E6%B3%A8%E8%A7%A3%E5%92%8C%E5%8F%8D%E5%B0%84/","content":"注解什么是注解注解就是对程序做出解释,与我们在方法、类上的注释没什么区别,但是注解可以被其他程序所读取,进行信息处理,否则与注释没有太大区别.\n内置注解内置注解就是JDK所带的一些注解.常用的三个注解:\n\n@Override\n\n修辞方法,表示打算重写超类中的方法声明.\n\n\n@Deprecated\n\n表示废弃,这个注解可以修饰方法、属性、类表示不鼓励程序员使用这样的元素,通常是因为他们危险或有更好的选择.\n\n\n@SuperWarnings\n\n抑制警告信息,我们写程序的时候,可能会报很多黄线的警告,但是不影响允许,我们就可以用这个注解来抑制隐藏他们.\n与前两个注解不同的是,我们必须给注解参数才可以使用它.\n\n\n\n\n\n\n参数\n说明\n\n\n\ndeprecation\n使用了过时的类或方法的警告\n\n\nunchecked\n执行了未检查的转换时的警告 如:使用集合时未指定泛型\n\n\nfallthrough\n当在switch语句使用时发生case穿透\n\n\npath\n在类路径、源文件路径中有不存在路径的警告\n\n\nserial\n当在序列化的类上缺少serialVersionUID定义时的警告\n\n\nfinally\n任何finally子句不能完成时的警告\n\n\nall\n关于以上所有的警告\n\n\n自定义注解public @interface 注解名 &#123; 定义体 &#125;\n\n@interface MyAnnotation&#123;\n    //注解的参数名称: 参数类型 + 参数名 ();\n    String name() default \"\";\n    int age() default 0;\n    int id() default -1;//如果为-1,代表不存在\n\n    String[] schools();\n&#125;\n\n需要注意:\n\n使用@interface自定义注解时,自动继承了java.lang.annotation.Annotation接口\n每个方法实际上是声明了一个配置参数\n方法的名称就是参数的名称\n返回值类型就是参数的类型(返回值类型只能是基本类型、Class、String、enum)\n可以通过default来声明参数的默认值\n如果只有一个参数成员,一般参数名为value\n使用注解元素时必须要有值,可以定义默认值,空字符串,0或者-1\n\n元注解在自定义注解时,需要使用Java提供的元注解,就是复制注解的其他注解.Java定义了四个标准的meta-annotation类型,它们被用来提供对其他注解类型的声明.\n\n@Target\n\n用来描述注解的使用范围,就是注解可以被应用在哪个地方.\n\n\n\n\n\n\n所修饰范围\n取值ElementType\n\n\n\npackage包\nPACKAGE\n\n\n类、接口、枚举、Annotation类型\nTYPE\n\n\n类型成员(方法、构造方法、成员变量、枚举值)\nCONSTRUCTOR：用于描述构造器。FIELD：用于描述域。METHOD：用于描述方法\n\n\n方法参数和本地变量\nLOCAL_VARIABLE:用于描述局部变量。PARAMETER：用于描述参数\n\n\n\nRetention\n\n告诉编译器需要在什么级别保存该注解信息,用于描述注解的生命周期\n\n\n\n\n\n\n取值RetentionPolicy\n作用\n\n\n\nSOURCE\n在源文件中有效(即源文件保留)\n\n\nCLASS\n在Class文件中有效(即Class保留)\n\n\nRUNTIME\n在运行时有效(即运行时保留)注:为RUNTIME时可以被反射机制所获取\n\n\n一般情况下,我们使用RUNTIME即可.这样程序运行时我们也可以通过反射机制来读取到该注解.\n\n@Document\n@Inherited\n\n反射什么是反射反射是Java迈向动态语言的一步,让Java成为了一个伪动态语言,反射机制允许程序在执行期间借助ReflecctionAPI取得类的任何信息,并能直接操作对象的内部属性及方法.\n加载完类之后,方法区会存放类的信息,包含类的完整结构信息,我们可以通过它看到类的结构,所以我们称之为反射.\n\nClass类使用反射,离不开java.lang.Class这个类.\n如何获取Class\n\n通过Class.forName()获取(最常用)\npublic class TestReflect &#123;\n    public static void main(String[] args) &#123;\n        try &#123;\n            //获取User的Class对象，参数为需要获取类对象的全类名\n           Class aClass = Class.forName(\"sml.reflect.User\");\n        //因为是动态编译，所有我们需要抛出类未找到的异常   \n        &#125; catch (ClassNotFoundException e) &#123;\n            e.printStackTrace();\n        &#125;\n    &#125;\n&#125;\n通过getClass()获取\npublic class TestReflect &#123;\n    public static void main(String[] args) &#123;\n        //new一个user对象\n        User user = new User();\n        //通过user对象来获取User类对象\n        Class aClass = user.getClass();\n    &#125;\n&#125;\n通过.class获取\npublic class TestReflect &#123;\n    public static void main(String[] args) &#123;\n        //通过导包获取类名点class来获取类对象\n        Class aClass = User.class;\n    &#125;\n&#125;\n\n反射的基本操作获取到Class对象之后,可以获取类的信息,这里列举常用的:\n\n获取类名\nClass aClass = Class.forName(\"sml.reflect.User\");\n //获取全类名\nString name = aClass.getName();\n //获取简单的类名\nString simpleName = aClass.getSimpleName();\n获取类的字段、某些变量\nClass aClass = Class.forName(\"sml.reflect.User\");\n\n//获取该类的所有public字段，包括父类的\nField[] fields = aClass.getFields();\n//根据字段名获取该类的public字段\nField field = aClass.getField(\"age\");\n\n//获取该类的所有字段，不包括父类（仅自定义）\nField[] fields1 = aClass.getDeclaredFields();\n//根据字段名获取该类的字段\nField field1 = aClass.getDeclaredField(\"name\");\n\n注意：我们仔细看注释，不带Declared的方法职能获取到public字段，且包括父类的，带Declared的方法可以获取到所有的自定义的字段！\n\n获取类的方法\nClass aClass = Class.forName(\"sml.reflect.User\");\n\n//获取该类的所有public方法，包括父类的\nMethod[] methods = aClass.getMethods();\n//根据方法名获取该类的public方法\nMethod method = aClass.getMethod(\"getName\");\n//如果该类为重写方法，可以在第二个参数加上重写方法的参数类型，不写为无参数的方法\nMethod paramMethod = aClass.getMethod(\"getName\",String.class);\n\n//获取该类的所有方法，不包括父类（仅自定义）\nMethod[] declaredMethods = aClass.getDeclaredMethods();\n//根据方法名获取该类的方法\nMethod declaredMethod = aClass.getDeclaredMethod(\"getName\");\n\n注：获取方法的方式与获取字段的方法一样，在这里我们需要注意的是重写的方法，一个类中存在俩个或多个方法名是一样的，因此在根据方法名获取方法时，提供第二个参数，为可变参数。参数类型为我们获取方法的参数类型的类，如果不写默认为无参方法。\n\n获取类的构造器\nClass aClass = Class.forName(\"sml.reflect.User\");\n\n//获取该类的所有构造器，包括父类\nConstructor[] constructors = aClass.getConstructors();\n//根据构造器的参数类型来获取指定构造器，不写为无参构造器\nConstructor constructor = aClass.getConstructor();\nConstructor constructor1 = aClass.getConstructor(String.class,int.class);\n\n//获取该类的所有构造器，不包括父类\nConstructor[] declaredConstructors = aClass.getDeclaredConstructors();\n//根据构造器的参数类型来获取指定的自定义构造器，不写为无参构造器\nConstructor declaredConstructor = aClass.getDeclaredConstructor();\nConstructor declaredConstructor1 = aClass.getDeclaredConstructor(String.class, int.class);\n\n注：在我们获取类构造器和类方法时涉及到可变参数的知识，大家可以自行百度一下，或者查阅官方文档，也不难，就是在我们不确定参数有几个时，就可以写成可变参数，我们在使用时可以传多个参数。注意我们写的参数都为类对象！\n\n类的实例化\nClass aClass = Class.forName(\"sml.reflect.User\");\n\n//通过class类直接实例化，使用的是User类的无参构造器\nUser user = (User) aClass.newInstance();\n            \n//获取构造器来进行实例化,这里获取有参构造器\nConstructor declaredConstructor = aClass.getDeclaredConstructor(String.class, int.class);\n//根据构造器进行实例化\nUser user1 = (User) declaredConstructor.newInstance(\"sml\",18);\n\n注：我们在使用类对象直接实例化时，一定要确保需实例化的类中存在无参构造器，否则会报错。默认获取的是Object类型，因此最后需要进行下类型转化。\n\n方法的调用\nClass aClass = Class.forName(\"sml.reflect.User\");\n\nUser user = (User) aClass.newInstance();\n//获取setName方法\nMethod setName = aClass.getDeclaredMethod(\"setName\", String.class);\n//通过获取的方法来调用(invoke),invoke方法有俩个参数\n//第一个是调用底层方法的对象，也就是通过哪个对象来调用方法\n//第二个为可变参数，是用于方法调用的参数\nsetName.invoke(user,\"sml\");\n\n注：如果我们调用的方法为私有方法，虽然编译器通过，在运行时会报错的（java.lang.IllegalAccessException），这是因为java的安全检查。我们可以使用setAccessible(true)这个方法来跳过安全检查。\nClass aClass = Class.forName(\"sml.reflect.User\");\n\nUser user = (User) aClass.newInstance();\nMethod setName = aClass.getDeclaredMethod(\"setName\", String.class);\n//若setName为私有方法，跳过安全检查\nsetName.setAccessible(true);\nsetName.invoke(user,\"sml\");\n字段的操作\nClass aClass = Class.forName(\"sml.reflect.User\");\n\nUser user = (User) aClass.newInstance();\n//获取name字段\nField name = aClass.getDeclaredField(\"name\");\n//通过该字段的set方法来改变该字段的值，该字段有俩个参数\n//第一个为应该修改其字段的参数\n//第二个为被修改字段的新值\n\n//如果是私有字段,同样需要添加setAccessible(true)\n//setName.setAccessible(true);\nname.set(user,\"sml\");\n泛型的操作(Generic)\nJava采用泛型擦除机制来引入泛型,也就是说java的泛型仅仅只是给编译器javac使用的,确保数据安全和免去强制类型转换的麻烦,一旦完成编译,这泛型等于没有.\n为了通过反射操作这些类型以迎合实际开发需求,Java新增了ParameterizedType、GenericArrayType、TypeVariable和WildcardType几种类型来代表不能被归一到Class类中的类型但是又和原始类型齐名的类型,这四种类型实现了Type接口.\n\n\n\n类型\n含义\n\n\n\nParameterizedType\n参数化类型,带有类型参数的类型,即常说的泛型,如:List\n\n\nTypeVariable\n类型变量,如参数化类型Map&lt;E,Y&gt;中的Y,K等类型变量,表示泛指任何类\n\n\nGenericArrayType\n(泛型)数组类型,比如List[],T[]这种,注意,这不是一般数组,而是表示一种{元素类型是参数化类型或者类型变量的}数组类型\n\n\nWildcardType\n代表通配符表达式,或泛型表达式,比如[?],[? super T],[? extends T],虽然WildcardType是Type的一个子接口，但并不是Java类型中的一种\n\n\npublic class TestReflect &#123;\n    //测试方法，返回类型与参数都为泛型\n    public static Map&lt;String,User> GenericityTest(List&lt;User> list,User user)&#123;\n        return null;\n    &#125;\n\n    public static void main(String[] args) &#123;\n        try &#123;\n            //先获取到该类\n            Class aClass = Class.forName(\"sml.reflect.TestReflect\");\n            //获取到测试方法\n            Method genericityTest = aClass.getDeclaredMethod(\"GenericityTest\", List.class,User.class);\n            //获取到类型参数数组,就是获取方法所有的参数类型\n            Type[] genericParameterTypes = genericityTest.getGenericParameterTypes();\n            for (Type genericParameterType : genericParameterTypes) &#123;\n                //输出一下类型参数\n                System.out.println(genericParameterType);\n                //我们在循环时判断该参数类型，若该参数属于参数化类型\n                if(genericParameterType instanceof ParameterizedType)&#123;\n                    //若属于参数化类型，则获取类型对象的数组，表示此类型的实际类型参数\n                    Type[] actualTypeArguments = ((ParameterizedType) genericParameterType).getActualTypeArguments();\n                    for (Type actualTypeArgument : actualTypeArguments) &#123;\n                        //打印下实际类型参数\n                        System.out.println(actualTypeArgument);\n                    &#125;\n                &#125;\n            &#125;\n        &#125; catch (Exception e) &#123;\n            e.printStackTrace();\n        &#125;\n    &#125;\n&#125;\n\n上面演示的是获取方法参数,下面为获取返回类型\n//获取方法所有的参数类型\nType[] genericParameterTypes = genericityTest.getGenericParameterTypes();\n//获取返回值的参数类型，返回值只有一个，所有不是数组\nType genericReturnType = genericityTest.getGenericReturnType();\n注解的操作\npublic class AnnotationTest &#123;\n\n    @TestAnnotation(\"sml\")\n    public static void main(String[] args) &#123;\n\n        try &#123;\n            Class aClass = Class.forName(\"sml.annotation.AnnotationTest\");\n            Method main = aClass.getDeclaredMethod(\"main\",String[].class);\n            //根据我们的main方法获取main方法上的注解\n            TestAnnotation declaredAnnotation = main.getDeclaredAnnotation(TestAnnotation.class);\n            //获取到他的值\n            String value = declaredAnnotation.value();\n            System.out.println(value);\n        &#125; catch (Exception e) &#123;\n            e.printStackTrace();\n        &#125;\n    &#125;\n&#125;\n\n如果我们需要获取类上的注解，只需要获取到类对象，然后.getDeclaredAnnotation（）即可，其实不管是获取类上的注解还是字段上的注解都是一样的方法.\n\n\n参考文章1:https://blog.csdn.net/weixin_45056780/article/details/105127722\n文章2:https://blog.csdn.net/zhangzhiyuan88/article/details/113404626\n","categories":["Java"],"tags":["Java"]},{"title":"JUC并发编程","url":"/2021/06/22/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/","content":"什么是JUC其实就是java.util.concurrent包的简称,最开始出现在JDK1.5中.\n线程和进程进程一个运行中的程序集合,一个进程往往包含多个线程,至少包含1个线程,\nJava中默认有2个线程,一个Mian线程,一个GC线程\n线程线程是操作系统弄够运算调度的最小单位,\n对Java而言创建thread: 继承自thread,实现runnable接口,实现callable接口\nJava真的可以开启线程吗? 开不了的,底层是用native关键词修饰.调用本地实现\n并发和并行并发(多线程操作同一个资源,交替执行)\n\nCPU一核, 模拟出来多条线程,天下武功,唯快不破,快速交替\n\n并行(多个人一起行走, 同时进行)\n\nCPU多核,多个线程同时进行 ; 使用线程池操作\n\n并发编程的本质:充分利用CPU的资源\nWait/Sleep的区别\n来自不同的类\n wait来自object类, sleep来自线程类\n\n关于锁的释放\n wait会释放锁, sleep不会释放锁\n\n使用的范围不同\n wait必须在同步代码块中\nsleep可以在任何地方睡\n\n是否需要捕获异常\n wait不需要捕获异常\n sleep需要捕获异常\n\n\nLock锁Lock是一个接口,其基本功能和Synchronized 大差不差,两者对比如下:\n\n\n\nSynchronized\nLock\n\n\n\nJava内置关键字\nJava的一个接口\n\n\n无法判断获取锁的状态\n可以判断是否获取到锁\n\n\n自动释放锁\n必须手动释放\n\n\n线程 1（获得锁，阻塞）、线程2（等待，傻傻的等）\nLock锁就不一定会等待下去\n\n\n可重入锁,不可以中断,非公平\n可重入锁,可以判断锁,非公平(可设置)\n\n\n适合少量代码\n适合大量代码\n\n\nLock有三个实现类:\n\nReentrantLock 可重入锁(常用)\nReadLock 读锁\nWriteLock 写锁\n\n公平锁/非公平锁公平锁: 十分公平: 可以先来后到,一定要排队\n非公平锁: 十分不公平,可以插队(默认)\npublic static void main(String[] args) &#123;\n    Ticket ticket = new Ticket();\n    new Thread(() -&gt; &#123;\n        for (int i = 0; i &lt; 40; i++) ticket.sale();\n    &#125;, &quot;a&quot;).start();\n    new Thread(() -&gt; &#123;\n        for (int i = 0; i &lt; 40; i++) ticket.sale();\n    &#125;, &quot;b&quot;).start();\n    new Thread(() -&gt; &#123;\n        for (int i = 0; i &lt; 40; i++) ticket.sale();\n    &#125;, &quot;c&quot;).start();\n&#125;\n\nstatic class Ticket &#123;\n    private int ticketNum = 30;\n    private Lock lock = new ReentrantLock(true);\n    public void sale() &#123;\n        lock.lock();\n        try &#123;\n            if (this.ticketNum &gt; 0) &#123;\n                System.out.println(Thread.currentThread().getName() + &quot;购得第&quot; + ticketNum-- + &quot;张票, 剩余&quot; + ticketNum + &quot;张票&quot;);\n            &#125;\n            //增加错误的发生几率\n            Thread.sleep(10);\n        &#125; catch (Exception e) &#123;\n            e.printStackTrace();\n        &#125; finally &#123;\n            lock.unlock();\n        &#125;\n    &#125;\n&#125;\n\n参考文章1: https://blog.csdn.net/qq_22155255/article/details/109749311\n","categories":[],"tags":[]},{"title":"八大排序","url":"/2021/06/22/%E5%85%AB%E5%A4%A7%E6%8E%92%E5%BA%8F/","content":"插入排序基本思想:每一步将一个待排序的数据插入到前面已经排好序的有序序列中，直到插完所有元素为止.\n先确定第一个元素暂时为有序元素,声明应该变量tmp存放第二个元素这个\n创建一个循环 i,从第二个元素开始向右循环(++),在循环 i 中嵌套一个循环 j 为i-1向左循环(–),假设 i 左边的元素为有序元素, 则循环 j 需要用有序元素与右边的无序元素进行比较.\n假设一个数组包含{4, 6, 8, 5, 9}, i 从第二个元素6开始,向右循环,每次循环将对应的值赋予tmp,到8为止,都不需要进行排序操作,当 i 指向5时,8&gt;5,进入循环 j,将8赋值给5所在的下标区域,循环 j 继续循环,走到6时发现6&gt;tmp=5,所以将6给它右边的第一个值(j+1的位置),继续执行 j 循环,直到 j = 0,4&lt;5时,则 j+1的位置为5,跳出循环 j,接着执行循环 i,最后完成排序.\n算法适用于少量数据的排序，时间复杂度为O(n^2)。是稳定的排序方法。\n时间复杂度为O(n^2),\n\n代码实现:\nint[] array = new int[]&#123;4, 6, 8, 5, 9&#125;;\nint i;\nint j;\n//从第二个元素开始循环数组\nfor (i = 1; i &lt; array.length; i++) &#123;\n    int tmp = array[i];//将元素赋予tmp\n\n    //从i-1个元素开始循环 判断array[j]是否大于tmp 如果大于则进入循环 开始交换\n    for (j = i - 1; j > 0 &amp;&amp; array[j] > tmp; j--) &#123;\n        //向右移动 腾出左边的空间\n        array[j + 1] = array[j];\n    &#125;\n    //将tmp的数插入到合适的位置\n    array[j + 1] = tmp;\n&#125;\n\n冒泡排序基本思想:冒泡排序,类似于水中冒泡,较大的数沉下去,较小的数慢慢冒出,假设从小到大,则大的往上浮,小的往下沉.说白了,就是每遍历一趟,将最大的数移动至末尾.\n比较相邻两个元素,如果前一个比后一个大,则交换.\n第一趟比较,第一个和第二个比较交换,然后第二个和第三个比较交换,这样下来,最大的会到最后面,接着是下一趟.\n冒泡排序最好的时间复杂度为O(n)。冒泡排序的最坏时间复杂度为O(n^2)。因此冒泡排序总的平均时间复杂度为O(n^2)。\n\n代码实现:\nint[] array = new int[]&#123;4, 6, 8, 5, 9&#125;;\nfor (int i = 0; i &lt; array.length; i++) &#123;\n    for (int j = i; j &lt; array.length; j++) &#123;\n        if (array[i] > array[j]) &#123;\n            //交换\n            int tmp = array[j];\n            array[j] = array[i];\n            array[i] = tmp;\n        &#125;\n    &#125;\n&#125;\n\n选择排序基本思想:每次排序中选择最大或最小的一个元素,存放在序列的初始位置,直到全部元素完成排序.\n选择排序是不稳定的排序方法。时间复杂度 O(n^2)。\n\n代码实现:\nint[] arr = &#123;2, 5, 4, 3, 8, 6, 4&#125;;\nint sub = 0;\nfor (int i = 0; i &lt; arr.length; i++) &#123;\n    sub = i;\n    for (int j = i + 1; j &lt; arr.length; j++) &#123;\n        if(arr[sub] &lt; arr[j])&#123;\n            sub = j;\n        &#125;\n    &#125;\n\n    if(sub != i)&#123;\n        int temp = arr[sub];\n        arr[sub] = arr[i];\n        arr[i] = temp;\n    &#125;\n&#125;\n\n希尔排序基本思想:先取一个小于n的整数d1作为第一个增量，把文件的全部记录分组。所有距离为d1的倍数的记录放在同一个组中。先在各组内进行直接插入排序；然后，取第二个增量d2&lt;d1重复上述的分组和排序，直至所取的增量dt=1(dt&lt;dt-1…&lt;d2&lt;d1)，即所有记录放在同一组中进行直接插入排序为止。\n希尔排序不稳定，时间复杂度 平均时间 O(nlogn) 最差时间O(n^2)\nint[] arr = &#123;3, -1, 45, 98, 1, 34, 56, 0, -2, -89, 2&#125;;\n\n//控制希尔变量\nfor (int gap = arr.length / 2; gap > 0; gap /= 2) &#123;\n    for (int i = gap; i &lt; arr.length; i++) &#123;\n        for (int j = i - gap; j >= 0; j -= gap) &#123;\n            if (arr[j] > arr[j + gap]) &#123;\n                int temp = arr[j];\n                arr[j] = arr[j + gap];\n                arr[j + gap] = temp;\n            &#125;\n        &#125;\n    &#125;\n&#125;\n\n参考视频:希尔排序动画演示\n堆排序参考插入排序/希尔排序:https://blog.csdn.net/qq_33289077/article/details/90370899\n选择排序:https://www.jianshu.com/p/51100da14cc2\n","categories":["排序"],"tags":["排序"]},{"title":"Java-集合","url":"/2021/06/18/Java-%E9%9B%86%E5%90%88/","content":"Java集合Java集合是学习Java中必须掌握的,面试也会经常问道.\nJava集合框架图\n\n从上面可以看出,集合主要分两大类,一种是Collection,存储的是元素集合,另一种是Map,存储Key/Value,其中Collection又分为List、Set和Queue在下面也是一些抽象类,最后是具体实现类,常用的有 ArrayList、LinkedList、HashSet、LinkedHashSet、HashMap、LinkedHashMap等等.\n集合接口\n\n\n接口\n接口描述\n\n\n\nCollection\nCollection是最基本的集合接口,一个Collection代表一组Object,即Collection的元素,Java不提供直接继承Collection的类,只提供继承于的子接口(如List和Set).Collection接口存储一组不唯一,无序的对象.\n\n\nList\nList是有序的Collection,能精确的控制每一个元素的插入位置,能通过索引访问List中的元素,允许有相同的元素.List接口存储一组不唯一,有序的对象.\n\n\nSet\n具有和Collection完全一样的接口,Set不保存重复的元素,Set接口存储一组唯一,无需的对象.\n\n\nSortedSet\n继承于Set保存有序的集合\n\n\nMap\n存储键值对的对象\n\n\nMap.Entry\n描述Map中的一个元素,是Map的内部接口\n\n\nSortedMap\n继承于Map,使Key保存在升序排序\n\n\nEnumeration\n这是一个传统的接口和定义的方法，通过它可以枚举（一次获得一个）对象集合中的元素。这个传统接口已被迭代器取代。\n\n\nSet和List的区别\nSet接口保存实例存储的是无序的,不重复的,List接口则是有序的,可以重复的元素\nSet检索效率低下,删除和插入如效率高,插入和删除不会引起元素位置的改变 &lt;实现类有HashSet,TreeSet&gt;\nList和数组类似,可以动态增长,根据实际存储的数据的长度自动增长List的长度,查找元素效率高,插入和删除效率低,因为会引起其他元素位置改变**&lt;实现类有ArrayList,LinkedList,Vector&gt;** \n\n常用集合ArrayListArrayList是可以动态修改的数组,于普通数组的区别就是没有固定的大小限制,我们可以添加或删除数据\nArrayList继承了AbstractList并实现了List接口\n\nArrayList常用方法\n\n\n\n方法\n描述\n\n\n\nadd()\n将元素插入到指定位置的 arraylist 中\n\n\naddAll()\n添加集合中的所有元素到 arraylist 中\n\n\nclear()\n删除 arraylist 中的所有元素\n\n\nclone()\n复制一份 arraylist\n\n\ncontains()\n判断元素是否在 arraylist\n\n\nget()\n通过索引值获取 arraylist 中的元素\n\n\nindexOf()\n返回 arraylist 中元素的索引值\n\n\nremoveAll()\n删除存在于指定集合中的 arraylist 里的所有元素\n\n\nremove()\n删除 arraylist 里的单个元素\n\n\nsize()\n返回 arraylist 里元素数量\n\n\nisEmpty()\n判断 arraylist 是否为空\n\n\nsubList()\n截取部分 arraylist 的元素\n\n\nset()\n替换 arraylist 中指定索引的元素\n\n\nsort()\n对 arraylist 元素进行排序\n\n\ntoArray()\n将 arraylist 转换为数组\n\n\ntoString()\n将 arraylist 转换为字符串\n\n\nensureCapacity()\n设置指定容量大小的 arraylist\n\n\nlastIndexOf()\n返回指定元素在 arraylist 中最后一次出现的位置\n\n\nretainAll()\n保留 arraylist 中在指定集合中也存在的那些元素\n\n\ncontainsAll()\n查看 arraylist 是否包含指定集合中的所有元素\n\n\ntrimToSize()\n将 arraylist 中的容量调整为数组中的元素个数\n\n\nremoveRange()\n删除 arraylist 中指定索引之间存在的元素\n\n\nreplaceAll()\n将给定的操作内容替换掉数组中每一个元素\n\n\nremoveIf()\n删除所有满足特定条件的 arraylist 元素\n\n\nforEach()\n遍历 arraylist 中每一个元素并执行特定操作\n\n\n排序\nCollections.sort(YourList);\nLinkedList链表是一种常见的基本数据结构,是一种线性表,但并不会按线性顺序存储数据,而是在每一个节点里存到下一个节点的地址.\n链表有单向和双向链表之分.\n单向链表包含两个值:当前节点的值和指向下一个节点的链接\n\n双向链表有三个数值:向前的节点链接,数值,向后的节点链接\n\n于ArrayList相比,LinkedList的增加和删除效率更高,而查找和修改的操作效率低\n以下情况使用ArrayList\n\n频繁访问列表的某一个元素\n只需要在列表末尾添加或删除操作\n\n以下情况使用LinkedList\n\n需要通过循环迭代来访问列表中的某些元素\n需要频繁的在列表开头,中间,末尾等位置进行添加和删除元素操作\n\nLinkedList 继承了 AbstractSequentialList 类。\nLinkedList 实现了 Queue 接口，可作为队列使用。\nLinkedList 实现了 List 接口，可进行列表的相关操作。\nLinkedList 实现了 Deque 接口，可作为队列使用。\nLinkedList 实现了 Cloneable 接口，可实现克隆。\nLinkedList 实现了 java.io.Serializable 接口，即可支持序列化，能通过序列化去传输。\n\n常用方法\n\n\n\n方法\n描述\n\n\n\npublic boolean add(E e)\n链表末尾添加元素，返回是否成功，成功为 true，失败为 false。\n\n\npublic void add(int index, E element)\n向指定位置插入元素。\n\n\npublic boolean addAll(Collection c)\n将一个集合的所有元素添加到链表后面，返回是否成功，成功为 true，失败为 false。\n\n\npublic boolean addAll(int index, Collection c)\n将一个集合的所有元素添加到链表的指定位置后面，返回是否成功，成功为 true，失败为 false。\n\n\npublic void addFirst(E e)\n元素添加到头部。\n\n\npublic void addLast(E e)\n元素添加到尾部。\n\n\npublic boolean offer(E e)\n向链表末尾添加元素，返回是否成功，成功为 true，失败为 false。\n\n\npublic boolean offerFirst(E e)\n头部插入元素，返回是否成功，成功为 true，失败为 false。\n\n\npublic boolean offerLast(E e)\n尾部插入元素，返回是否成功，成功为 true，失败为 false。\n\n\npublic void clear()\n清空链表。\n\n\npublic E removeFirst()\n删除并返回第一个元素。\n\n\npublic E removeLast()\n删除并返回最后一个元素。\n\n\npublic boolean remove(Object o)\n删除某一元素，返回是否成功，成功为 true，失败为 false。\n\n\npublic E remove(int index)\n删除指定位置的元素。\n\n\npublic E poll()\n删除并返回第一个元素。\n\n\npublic E remove()\n删除并返回第一个元素。\n\n\npublic boolean contains(Object o)\n判断是否含有某一元素。\n\n\npublic E get(int index)\n返回指定位置的元素。\n\n\npublic E getFirst()\n返回第一个元素。\n\n\npublic E getLast()\n返回最后一个元素。\n\n\npublic int indexOf(Object o)\n查找指定元素从前往后第一次出现的索引。\n\n\npublic int lastIndexOf(Object o)\n查找指定元素最后一次出现的索引。\n\n\npublic E peek()\n返回第一个元素。\n\n\npublic E element()\n返回第一个元素。\n\n\npublic E peekFirst()\n返回头部元素。\n\n\npublic E peekLast()\n返回尾部元素。\n\n\npublic E set(int index, E element)\n设置指定位置的元素。\n\n\npublic Object clone()\n克隆该列表。\n\n\npublic Iterator descendingIterator()\n返回倒序迭代器。\n\n\npublic int size()\n返回链表元素个数。\n\n\npublic ListIterator listIterator(int index)\n返回从指定位置开始到末尾的迭代器。\n\n\npublic Object[] toArray()\n返回一个由链表元素组成的数组。\n\n\npublic T[] toArray(T[] a)\n返回一个由链表元素转换类型而成的数组。\n\n\nHashMapHashMap是一个散列表,存储键值对,实现了Mao接口,根据键的HashCode值存储数据,具有很快的访问速度,最多允许一条记录的键为null,不支持线程同步.\nHashMap是无序的,HashMap 继承于AbstractMap，实现了 Map、Cloneable、java.io.Serializable 接口。\n\nHashMap的key和Value可以相同也可以不相同\n常用方法\n\n\n\n方法\n描述\n\n\n\nclear()\n删除 hashMap 中的所有键/值对\n\n\nclone()\n复制一份 hashMap\n\n\nisEmpty()\n判断 hashMap 是否为空\n\n\nsize()\n计算 hashMap 中键/值对的数量\n\n\nput()\n将键/值对添加到 hashMap 中\n\n\nputAll()\n将所有键/值对添加到 hashMap 中\n\n\nputIfAbsent()\n如果 hashMap 中不存在指定的键，则将指定的键/值对插入到 hashMap 中。\n\n\nremove()\n删除 hashMap 中指定键 key 的映射关系\n\n\ncontainsKey()\n检查 hashMap 中是否存在指定的 key 对应的映射关系。\n\n\ncontainsValue()\n检查 hashMap 中是否存在指定的 value 对应的映射关系。\n\n\nreplace()\n替换 hashMap 中是指定的 key 对应的 value。\n\n\nreplaceAll()\n将 hashMap 中的所有映射关系替换成给定的函数所执行的结果。\n\n\nget()\n获取指定 key 对应对 value\n\n\ngetOrDefault()\n获取指定 key 对应对 value，如果找不到 key ，则返回设置的默认值\n\n\nforEach()\n对 hashMap 中的每个映射执行指定的操作。\n\n\nentrySet()\n返回 hashMap 中所有映射项的集合集合视图。\n\n\nkeySet()\n返回 hashMap 中所有 key 组成的集合视图。\n\n\nvalues()\n返回 hashMap 中存在的所有 value 值。\n\n\nmerge()\n添加键值对到 hashMap 中\n\n\ncompute()\n对 hashMap 中指定 key 的值进行重新计算\n\n\ncomputeIfAbsent()\n对 hashMap 中指定 key 的值进行重新计算，如果不存在这个 key，则添加到 hasMap 中\n\n\ncomputeIfPresent()\n对 hashMap 中指定 key 的值进行重新计算，前提是该 key 存在于 hashMap 中。\n\n\nHashSetHashSet基于HashMap来实现,是一个不允许有重复元素的集合.\nHashSet允许有空值.是无序的,不是线程安全的.\nHashSet实现了Set接口\n\n","categories":["Java"],"tags":["Java","集合"]},{"title":"SpringBoot-Shiro","url":"/2021/05/21/SpringBoot-Shiro/","content":"Shiro介绍跟SpringSecurity一样，它也是一个鉴权授权项目，属于Apache开源的一个轻量级框架，没用SpringSecurity复杂。\nShiro架构图：\n\n\nSubject：与应用交互的主体，例如用户，第三方应用等。\n\nSecurityManager：shiro的核心，负责整合所有的组件，使他们能够方便快捷完成某项功能。例如：身份验证，权限验证等。\n\nAuthenticator：认证器，负责主体认证的，这是一个扩展点，如果用户觉得Shiro默认的不好，可以自定义实现；其需要认证策略（Authentication Strategy），即什么情况下算用户认证通过了。\n\nAuthorizer：决定主体是否有权限进行相应的操作；即控制着用户能访问应用中的哪些功能。\n\nSessionManager：会话管理。\n\nSessionDAO：数据访问对象，对session进行CRUD。\n\nCacheManager：缓存管理器。创建和管理缓存，为 authentication, authorization 和 session management 提供缓存数据，避免直接访问数据库，提高效率。\n\nCryptography；密码模块，提供加密组件。\n\nRealms：可以有1个或多个Realm，可以认为是安全实体数据源，即用于获取安全实体的；可以是JDBC实现，也可以是LDAP实现，或者内存实现等等；由用户提 供；注意：Shiro不知道你的用户/权限存储在哪及以何种格式存储；所以我们一般在应用中都需要实现自己的Realm。\n\n\nSpringBoot整合Shiro1.导入Shiro有两种方式\n其一：使用普通Shiro包\n&lt;dependency>\n    &lt;groupId>org.apache.shiro&lt;/groupId>\n    &lt;artifactId>shiro-spring-boot-web-starter&lt;/artifactId>\n    &lt;version>1.7.1&lt;/version>\n&lt;/dependency>\n\n其二：使用Starter包导入（本文使用），两者相比较，无法就是简化了一些代码，使用差别基本没用\n&lt;dependency>\n    &lt;groupId>org.apache.shiro&lt;/groupId>\n    &lt;artifactId>shiro-spring-boot-web-starter&lt;/artifactId>\n    &lt;version>1.7.1&lt;/version>\n&lt;/dependency>\n\n2.自定义Realm//自定义的Realm需要继承AuthorizingRealm\npublic class CustomRealm extends AuthorizingRealm &#123;\n\n    @Autowired\n    private UserService userService;\n\n    //告诉shiro如何根据获取到的用户信息中的密码和盐值来校验密码\n    //说白了，就是Shiro会加密用户登录的密码然后和数据库的密码进行比较\n    //这个有很多实现类，这里只演示这种\n    &#123;\n        //设置用于匹配密码的CredentialsMatcher\n        HashedCredentialsMatcher hashMatcher = new HashedCredentialsMatcher();\n        hashMatcher.setHashAlgorithmName(\"MD5\");\n        hashMatcher.setHashIterations(1024);\n        this.setCredentialsMatcher(hashMatcher);//将CredentialsMatcher添加进Realm\n    &#125;\n\n    //定义如何获取用户的角色和权限的逻辑，给shiro做权限判断\n    @Override\n    protected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principals) &#123;\n        System.out.println(\"执行了授权操作\");\n        if (principals == null) &#123;\n            throw new AuthorizationException(\"PrincipalCollection 方法参数不能为 null。\");\n        &#125;\n\n        User user = (User) getAvailablePrincipal(principals);\n        //或(User) SecurityUtils.getSubject().getPrincipal()//这个可以在很多地方用不局限于这里\n\n        SimpleAuthorizationInfo info = new SimpleAuthorizationInfo();\n        \n        //https://shiro.apache.org/java-authorization-guide.html\n        //Shiro中权限分为Role和perms\n        info.addStringPermission(user.getPerms());//写入用户权限，这里权限直接写在了User表中\n\n        return info;\n    &#125;\n\n    //定义如何获取用户信息的业务逻辑，给shiro做登录\n    @Override\n    protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken token) throws AuthenticationException &#123;\n        System.out.println(\"执行了认证操作\");\n        UsernamePasswordToken upToken = (UsernamePasswordToken) token;\n        String username = upToken.getUsername();\n\n        // 空用户名无效\n        if (username == null) &#123;\n            throw new AccountException(\"不允许空用户名。\");\n        &#125;\n\n        //在数据库中根据username获取用户\n        User userDB = userService.findUserByName(username);\n\n\n        if (userDB == null) &#123;\n            throw new UnknownAccountException(\"找不到帐户[\" + username + \"]\");\n        &#125;\n\n        //将用户写入 由Shiro进行比对 这里的密码是加密后的\n        SimpleAuthenticationInfo info = new SimpleAuthenticationInfo(userDB, userDB.getPassword(), ByteSource.Util.bytes(userDB.getSalt()), getName());\n        return info;\n    &#125;\n\n&#125;\n\n3.配置Shiro@Configuration\npublic class ShiroConfig &#123;\n    \n    //将自己自定义的Realm写入容器\n    @Bean\n    CustomRealm customRealm() &#123;\n        return new CustomRealm();\n    &#125;\n\n    //安全管理器\n    @Bean\n    DefaultWebSecurityManager securityManager() &#123;\n        DefaultWebSecurityManager manager = new DefaultWebSecurityManager();\n        manager.setRealm(customRealm());\n        return manager;\n    &#125;\n\n    //这里就是配置路径访问权限的，也可以通过注解\n    @Bean\n    public ShiroFilterChainDefinition shiroFilterChainDefinition() &#123;\n        DefaultShiroFilterChainDefinition chainDefinition = new DefaultShiroFilterChainDefinition();\n\n        // 具有user:admin权限登录\n        chainDefinition.addPathDefinition(\"/admin/**\", \"authc, perms[user:admin]\");//roles[admin]\n\n        // 所有人皆可以访问\n        chainDefinition.addPathDefinition(\"/**\", \"anon\");\n        return chainDefinition;\n    &#125;\n&#125;\n\n注解做控制：\n\n|          注解           |                 功能                 |\n| :---------------------: | :----------------------------------: |\n|     @RequiresGuest      |           只有游客可以访问           |\n| @RequiresAuthentication |           需要登录才能访问           |\n|      @RequiresUser      |  已登录的用户或“记住我”的用户能访问  |\n|     @RequiresRoles      | 已登录的用户需具有指定的角色才能访问 |\n|  @RequiresPermissions   | 已登录的用户需具有指定的权限才能访问 |\n\n只用url配置控制鉴权授权：\n\n| 配置缩写          | 对应的过滤器                   | 功能                                                         |\n| ----------------- | ------------------------------ | ------------------------------------------------------------ |\n| anon              | AnonymousFilter                | 指定url可以匿名访问                                          |\n| authc             | FormAuthenticationFilter       | 指定url需要form表单登录，默认会从请求中获取`username`、`password`,`rememberMe`等参数并尝试登录，如果登录不了就会跳转到loginUrl配置的路径。我们也可以用这个过滤器做默认的登录逻辑，但是一般都是我们自己在控制器写登录逻辑的，自己写的话出错返回的信息都可以定制嘛。 |\n| authcBasic        | BasicHttpAuthenticationFilter  | 指定url需要basic登录                                         |\n| logout            | LogoutFilter                   | 登出过滤器，配置指定url就可以实现退出功能，非常方便          |\n| noSessionCreation | NoSessionCreationFilter        | 禁止创建会话                                                 |\n| perms             | PermissionsAuthorizationFilter | 需要指定权限才能访问                                         |\n| port              | PortFilter                     | 需要指定端口才能访问                                         |\n| rest              | HttpMethodPermissionFilter     | 将http请求方法转化成相应的动词来构造一个权限字符串，这个感觉意义不大，有兴趣自己看源码的注释 |\n| roles             | RolesAuthorizationFilter       | 需要指定角色才能访问                                         |\n| ssl               | SslFilter                      | 需要https请求才能访问                                        |\n| user              | UserFilter                     | 需要已登录或“记住我”的用户才能访问                           |\n\n使用两者结合是最好的。\n\n### 4.YML配置\n\n```yaml\nshiro:\n  unauthorizedUrl: /403\n  successUrl: /index\n  loginUrl: /login\n\n\n\n参考官网：https://shiro.apache.org/spring-boot.html#web-applications\n文章1：https://programmer.ink/think/simple-authentication-example-with-spring-boot-2-shiro.html\n文章2：https://segmentfault.com/a/1190000014479154\n文章3：https://blog.csdn.net/u014553029/article/details/106579537/\n文章5：https://blog.csdn.net/pengjunlee/article/details/95600843\n文章6：https://blog.csdn.net/u011478348/article/details/104123407\n","categories":["SpringBoot"],"tags":["Spring","SpringBoot","Shiro"]},{"title":"SpringBoot-SpringSecurity","url":"/2021/05/18/SpringBoot-SpringSecurity/","content":"SpringSecurity简介SpringSecurity是Spring安全框架中的一员，在SpringBoot出现之前，SpringSecurity已经发展了许久了，但使用并不多，这个领域一直都是Shiro的天下。\n相对于Shiro，在SSM/SSH中整合SpringSecurity都是比较麻烦的，所以即使SpringSecurity功能比Shiro强大，但使用反而没Shiro多（虽然Shiro功能没用SpringSecurity多，但绝大部分项目而言，已经够用了）。\nSpringBoot出来以后，对SpringSecurity提供了自动化配置方案，可以零配置使用SpringSecurity。\n所以常见的技术栈组合是如下：\n\nSSM + Shiro\nSpringBoot + SpringSecurity\n\n回到SpringSecurity，它的核心实现就是维护了一组过滤器链。\n基本使用创建项目，引入依赖\n&lt;dependency>\n    &lt;groupId>org.springframework.boot&lt;/groupId>\n    &lt;artifactId>spring-boot-starter-security&lt;/artifactId>\n&lt;/dependency>\n&lt;!--可选-->\n&lt;dependency>\n    &lt;groupId>org.springframework.boot&lt;/groupId>\n    &lt;artifactId>spring-boot-starter-thymeleaf&lt;/artifactId>\n&lt;/dependency>\n&lt;dependency>\n    &lt;groupId>org.springframework.security&lt;/groupId>\n    &lt;artifactId>spring-security-test&lt;/artifactId>\n    &lt;scope>test&lt;/scope>\n&lt;/dependency>\n\n随意编写Controller\n@Controller\npublic class RouterController &#123;\n    @GetMapping(&#123;\"/\",\"/index\"&#125;)\n    public String index()&#123;\n        return \"index\";\n    &#125;\n\n    @GetMapping(\"/tologin\")\n    public String tologin()&#123;\n        return \"views/login\";\n    &#125;\n\n    @GetMapping(\"/level1/&#123;id&#125;\")\n    public String level1(@PathVariable(\"id\") int id)&#123;\n        return \"views/level1/\"+id;\n    &#125;\n\n    @GetMapping(\"/level2/&#123;id&#125;\")\n    public String level2(@PathVariable(\"id\") int id)&#123;\n        return \"views/level2/\"+id;\n    &#125;\n\n    @GetMapping(\"/level3/&#123;id&#125;\")\n    public String level3(@PathVariable(\"id\") int id)&#123;\n        return \"views/level3/\"+id;\n    &#125;\n&#125;\n\n默认情况下，引入了SpringSecurity，所有的页面都需要进行认证\n编写配置类，修改默认配置\n//@Configuration\n@EnableWebSecurity\npublic class SecurityConfig extends WebSecurityConfigurerAdapter  &#123;\n\n    //这里可以配置一些忽略拦截项 当然也可以下面走匿名访问 不建议\n    @Override\n    public void configure(WebSecurity web) throws Exception &#123;\n        //静态资源过滤\n        web.ignoring().antMatchers(\"/resources/**\");\n        //过滤某个路由\n        web.ignoring().antMatchers(\"/vercode\");\n    &#125;\n\n    @Override\n    protected void configure(HttpSecurity http) throws Exception &#123;\n        http.authorizeRequests()\n            \t//为不同的访问路径配置不同的权限\n                .antMatchers(\"/level1/**\").hasAnyRole(\"vip1\",\"vip2\",\"vip3\")\n                .antMatchers(\"/level2/**\").hasAnyRole(\"vip2\",\"vip3\")\n                .antMatchers(\"/level3/**\").hasAnyRole(\"vip3\")\n            \t//剩下的路径设置为所有人皆可访问\n                .anyRequest().permitAll();\n        \n        //配置登录相关\n        http.formLogin()\n            //登录页所在路由 默认/login\n            .loginPage(\"/tologin\")\n            //登录表单发送目标的地址 如果不配置 默认是你的登录页所在路由\n            .loginProcessingUrl(\"/login\")\n            //表单中参数的名称 默认username password\n            .usernameParameter(\"name\")\n            .passwordParameter(\"pwd\")\n            .successHandler(new AuthenticationSuccessHandler() &#123;\n                    @Override\n                    public void onAuthenticationSuccess(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Authentication authentication) throws IOException, ServletException &#123;\n                        //判断请求是异步(返回JSON)还是同步(返回页面)\n                        String xRequestedWith = request.getHeader(\"x-requested-with\");//通过请求头判断\n                        if(\"XMLHttpRequest\".equals(xRequestedWith))&#123;//异步返回\n                            response.setContentType(\"application/plain;charset=utf-8\");\n                            PrintWriter writer = response.getWriter();\n                            writer.write(CommunityUtil.getJSONString(403,\"你还没有登录\"));\n                        &#125;else &#123;//同步返回\n                            response.sendRedirect(request.getContextPath()+\"/login\");\n                        &#125;\n                    &#125;\n                &#125;)\n            .failureHandler(new AuthenticationFailureHandler() &#123;\n                    @Override\n                    public void onAuthenticationFailure(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, AuthenticationException e) throws IOException, ServletException &#123;\n                        //同上\n                    &#125;\n                &#125;)\n        \n        //退出登录相关配置 差不多和上面一样 源码中有简易的教学Demo\n        http.logout();\n        \n        //记住我功能，如果你使用的是自定义登录页面，需要自己写选择框\n        http.rememberMe()\n            //表单中参数的名称\n            .rememberMeParameter(\"remember\");\n    &#125;\n\n    @Override\n    protected void configure(AuthenticationManagerBuilder auth) throws Exception &#123;\n        //添加账户，向内存中，一般用来测试用的，实际开发一般不这么玩\n        //BCryptPasswordEncoder是SpringSecurity提供的密码编码工具，可以非常方便的时间密码的加密和加盐，相同明文加密的密码完全不同\n        auth.inMemoryAuthentication().passwordEncoder(new BCryptPasswordEncoder())\n                .withUser(\"saber\").password(new BCryptPasswordEncoder().encode(\"123\")).roles(\"vip1\")\n                .and()\n                .withUser(\"root\").password(new BCryptPasswordEncoder().encode(\"123\")).roles(\"vip1\",\"vip2\",\"vip3\");\n    &#125;\n    //也可以通过配置文件配置\n    //spring.security.user.name=javaboy\n    //spring.security.user.password=123\n&#125;\n\n到此为止，一个大体的使用框架就搭建完成了，可以进行测试了\n更多使用登录成功和失败处理http.formLogin()\n        .loginPage(\"/tologin\")\n        .loginProcessingUrl(\"/login\")\n        .usernameParameter(\"name\")\n        .passwordParameter(\"pwd\")\n    \t//登录成功于失败的跳转路由\n    \t.successForwardUrl(\"/success\")\n        .failureForwardUrl(\"/failure\");\n\n\n一般上面这种做法无法满足我们的需求，而且查看源码可知，底层就是一个forward跳转，我们知道forward跳转是无法跳到应用之外的页面的，由于这些功能往往会有比较复杂的逻辑，所以SpringSecurity给我们提供了.successHandler()方法去自己实现一个成功跳转逻辑，需要给他一个实现了AuthenticationSuccessHandler接口的类，它会去执行里面的onAuthenticationSuccess()方法\nhttp.formLogin()\n              .loginPage(\"/tologin\")\n              .loginProcessingUrl(\"/login\")\n              .usernameParameter(\"name\")\n              .passwordParameter(\"pwd\")\n\t\t//也可以使用简单的路径跳转，看需求 .successForwardUrl()\n              .successHandler(new AuthenticationSuccessHandler() &#123;\n                  //这里直接在这里实例化一个接口，也可以先创建一个类继承接口在实现，然后通过new的形式或注入的形式在这里使用\n                  @Override\n                  public void onAuthenticationSuccess(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Authentication authentication) throws IOException, ServletException &#123;\n                      //判断请求是异步(返回JSON)还是同步(返回页面)\n                      String xRequestedWith = httpServletRequest.getHeader(\"x-requested-with\");//通过请求头判断\n                      if(\"XMLHttpRequest\".equals(xRequestedWith))&#123;//异步返回\n                          httpServletResponse.setContentType(\"application/plain;charset=utf-8\");\n                          PrintWriter writer = httpServletResponse.getWriter();\n                          writer.write(CommunityUtil.getJSONString(403,\"你还没有登录\"));\n                      &#125;else &#123;//同步返回\n                          httpServletResponse.sendRedirect(httpServletRequest.getContextPath()+\"/login\");\n                      &#125;\n                  &#125;\n              &#125;)\n              .failureHandler(new AuthenticationFailureHandler() &#123;\n                  @Override\n                  public void onAuthenticationFailure(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, AuthenticationException e) throws IOException, ServletException &#123;\n                      \n                  &#125;\n              &#125;);\n\n上面采用了最简单的写法，可读性差，建议还是自己去继承并实现，然后通过new的方式或注入的方式提供给.successHandler()\n权限不足处理//权限不够时\n     http.exceptionHandling()\n             .authenticationEntryPoint(new AuthenticationEntryPoint() &#123;\n                 //没有登录时处理\n                 @Override\n                 public void commence(HttpServletRequest request, HttpServletResponse response, AuthenticationException e) throws IOException, ServletException &#123;\n                     //判断请求是异步(返回JSON)还是同步(返回页面)\n                     String xRequestedWith = request.getHeader(\"x-requested-with\");//通过请求头判断\n                     if(\"XMLHttpRequest\".equals(xRequestedWith))&#123;//异步返回\n                         response.setContentType(\"application/plain;charset=utf-8\");\n                         PrintWriter writer = response.getWriter();\n                         writer.write(CommunityUtil.getJSONString(403,\"你还没有登录\"));\n                     &#125;else &#123;//同步返回\n                         response.sendRedirect(request.getContextPath()+\"/login\");\n                     &#125;\n                 &#125;\n             &#125;)\n             .accessDeniedHandler(new AccessDeniedHandler() &#123;\n                 //权限不足时处理\n                 @Override\n                 public void handle(HttpServletRequest request, HttpServletResponse response, AccessDeniedException e) throws IOException, ServletException &#123;\n                     //判断请求是异步(返回JSON)还是同步(返回页面)\n                     String xRequestedWith = request.getHeader(\"x-requested-with\");//通过请求头判断\n                     if(\"XMLHttpRequest\".equals(xRequestedWith))&#123;//异步返回\n                         response.setContentType(\"application/plain;charset=utf-8\");\n                         PrintWriter writer = response.getWriter();\n                         writer.write(CommunityUtil.getJSONString(403,\"权限不足\"));\n                     &#125;else &#123;//同步返回\n                         response.sendRedirect(request.getContextPath()+\"/denied\");\n                     &#125;\n                 &#125;\n             &#125;);\n\n自定义登录逻辑自定义登录逻辑需要创建一个实现UserDetailsService接口的类，并把它注入到IOC容器中\n@Service\npublic class UserDetailsServiceImpl implements UserDetailsService &#123;\n\n    @Autowired\n    private PasswordEncoder passwordEncoder;\n\n    @Autowired\n    private UserMapper userMapper;\n\n    @Autowired\n    private RoleMapper roleMapper;\n\n    @Bean\n    private BCryptPasswordEncoder passwordEncoder() &#123;\n        return new BCryptPasswordEncoder();\n    &#125;\n\n    @Override\n    public UserDetails loadUserByUsername(String s) throws UsernameNotFoundException &#123;\n\n        com.example.security.entity.User u = userMapper.findUserByName(s);\n        System.out.println(u.toString());\n        if (u == null) &#123;\n            throw new UsernameNotFoundException(\"用户名不存在！\");\n        &#125;\n        //比较密码，匹配成功会返回UserDetails，实际上也会去数据库查\n        String password = passwordEncoder.encode(u.getPassword());\n\n        //用于添加用户的权限。只要把用户权限添加到authorities。\n        List&lt;GrantedAuthority> authorities = new ArrayList&lt;>();\n        Role role = roleMapper.findRoleById((int) u.getRoleId());\n        if (role != null) &#123;\n            //使用Role和Authority都是这一套代码\n            //这里有给大坑 如果你使用Role进行授权的话，一定要如下加上 ROLE_\n            authorities.add(new SimpleGrantedAuthority(\"ROLE_\" + role.getRoleName()));\n        &#125;\n\n        User user = new User(u.getUsername(), password, authorities);\n        return user;\n    &#125;\n&#125;\n\n然后在配置类中添加如下(不是必须的，建议写上):\n@Autowired\nUserDetailsService userDetailsService;\n\n@Override\nprotected void configure(AuthenticationManagerBuilder auth) throws Exception &#123;\n    auth.userDetailsService(userDetailsService);\n&#125;\n\n\n\n认证授权注解在使用注解前需要在配置类或启动类上添加@EnableGlobalMethodSecurity表示开启注解认证授权\n@Secured需要在上面添加的注解中添加一个参数@EnableGlobalMethodSecurity(securedEnabled = true),开启这个注解的使用\n用户具有某个Role可以访问，在Controller中使用\n@GetMapping(\"/level1\")\n@Secured(&#123;\"ROLE_vip1\",\"ROLE_vip2\",\"ROLE_vip3\"&#125;)\npublic String level1() &#123;\n    return \"level1\";\n&#125;\n\n@GetMapping(\"/level2\")\n@Secured(&#123;\"ROLE_vip2\",\"ROLE_vip3\"&#125;)\npublic String level2() &#123;\n    return \"level2\";\n&#125;\n\n@GetMapping(\"/level3\")\n@Secured(&#123;\"ROLE_vip3\"&#125;)\npublic String level3() &#123;\n    return \"level3\";\n&#125;\n\n@PreAuthorize需要在上面添加的注解中添加一个参数@EnableGlobalMethodSecurity(prePostEnabled = true),开启这个注解的使用\n进入方法执行之前进行验证\n@GetMapping(\"/level3\")\n//@PreAuthorize(\"hasRole('ROLE_xxx')\") 这里直接使用上面介绍过的方法名称 就根调用方法一样\n    @PreAuthorize(\"hasAnyAuthority('admin3')\")\npublic String level3() &#123;\n    return \"level3\";\n&#125;\n\n@PostAuthorize需要在上面添加的注解中添加一个参数@EnableGlobalMethodSecurity(prePostEnabled = true),开启这个注解的使用\n在方法执行之后判断是否有权限\n@GetMapping(\"/level3\")\n@PostAuthorize(\"hasAnyAuthority('admin3')\")\npublic String level3() &#123;\n    System.out.println(\"fwcg\");\n    return \"level3\";\n&#125;\n\n@PreFilter / @PostFilter对传入 / 传出的数据进行过滤 Spring Security将移除使对应表达式的结果为false的元素。\n@PostFilter(\"filterObject.id%2==0\")\n@GetMapping(\"/getuser\")\npublic List&lt;User> findAll() &#123;\n    List&lt;User> userList = new ArrayList&lt;User>();\n    User user;\n    for (int i = 0; i &lt; 10; i++)&#123;\n        user = new User();\n        user.setId(i);\n        userList.add(user);\n    &#125;\n    System.out.println(userList);\n    return userList;\n&#125;\n\n上述代码表示将对返回结果中id不为偶数的user进行移除。filterObject是使用@PreFilter和@PostFilter时的一个内置表达式，表示集合中的当前对象\n当@PreFilter标注的方法拥有多个集合类型的参数时，需要通过@PreFilter的filterTarget属性指定当前@PreFilter是针对哪个参数进行过滤的。\n@PreFilter(filterTarget=\"ids\", value=\"filterObject%2==0\")\npublic void delete(List&lt;Integer> ids, List&lt;String> usernames) &#123;\n    ...\n&#125;\n\n记住我最简单的实现方式是储存在内存中，在配置类中添加如下代码即可\nhttp.rememberMe();//实现记住我自动登录，核心的代码只有这这一行\n\n如果你使用默认登录页，什么也不用做，但如果你是自定义的，请在页面中添加复选框，\n&lt;label> &lt;input type=\"checkbox\" name=\"remember-me\" />记住我&lt;/label>\n\n前端传值时SpringSecurity将读取键： remember-me，只能叫这个名，Ajax传递参数也必须为 remember-me，但后端可以通过.rememberMeParameter(&quot;xxx&quot;) 修改参数名称，还可以通过.rememberMeCookieName()修改Cookie中Key的名称\n.tokenValiditySeconds(60*2)这个可以修改有效时长默认2周，单位秒\nhttp.rememberMe()\n    .rememberMeParameter(\"rm\")\n    .rememberMeCookieName(\"rm-cookie\")\n    .tokenValiditySeconds(60*2);\n\n基于数据库的实现\n全部操作在配置类中\n先注入数据源\n@Autowired\nprivate DataSource dataSource;\n\n注入TokenRepostory组件\n@Bean\npublic PersistentTokenRepository persistentTokenRepository() &#123;\n    JdbcTokenRepositoryImpl jdbcTokenRepository = new JdbcTokenRepositoryImpl();\n    jdbcTokenRepository.setDataSource(dataSource);//使用数据源\n    jdbcTokenRepository.setCreateTableOnStartup(true);//创建数据表，第一次运行的时候使用，以后注释吊，不然报错\n    return jdbcTokenRepository;\n&#125;\n\n配置\nhttp.rememberMe()\n    .rememberMeParameter(\"rm\")\n    .rememberMeCookieName(\"rm-cookie\")\n    .tokenRepository(persistentTokenRepository())\n    .tokenValiditySeconds(60*2);\n\t//.userDetailsService(userDetailsService);//如果上面自定义登录中直接指示了auth.userDetailsService(userDetailsService);这里可以不写\n\n这样即可\n整合JWT导入依赖&lt;dependency>\n    &lt;groupId>io.jsonwebtoken&lt;/groupId>\n    &lt;artifactId>jjwt&lt;/artifactId>\n    &lt;version>0.9.1&lt;/version>\n&lt;/dependency>\n\n创建JWT工具类管理Token相关的操作\n/**\n * jwt 工具类 主要是生成token 检查token等相关方法\n */\npublic class JwtUtils &#123;\n\n    public static final String TOKEN_HEADER = \"Authorization\";\n\n    public static final String TOKEN_PREFIX = \"Bearer \";\n\n    // TOKEN 过期时间\n    public static final long EXPIRATION = 1000 * 60 * 30; // 三十分钟\n\n    public static final String APP_SECRET_KEY = \"secret\";\n\n    private static final String ROLE_CLAIMS = \"rol\";\n\n    /**\n     * 生成token\n     *\n     * @param username\n     * @param roles\n     * @return\n     */\n    public static String createToken(String username, List&lt;String> roles) &#123;\n\n        Map&lt;String, Object> map = new HashMap&lt;>();\n        map.put(ROLE_CLAIMS, roles);\n\n        String token = Jwts\n                .builder()\n                .setSubject(username)\n                .setClaims(map)\n                .claim(\"username\", username)\n                .setIssuedAt(new Date())\n                .setExpiration(new Date(System.currentTimeMillis() + EXPIRATION))\n                .signWith(SignatureAlgorithm.HS256, APP_SECRET_KEY).compact();\n        return token;\n    &#125;\n\n    /**\n     * 获取当前登录用户用户名\n     *\n     * @param token\n     * @return\n     */\n    public static String getUsername(String token) &#123;\n        Claims claims = Jwts.parser().setSigningKey(APP_SECRET_KEY).parseClaimsJws(token).getBody();\n        return claims.get(\"username\").toString();\n    &#125;\n\n    /**\n     * 获取当前登录用户角色\n     *\n     * @param token\n     * @return\n     */\n    public static ArrayList&lt;String> getUserRole(String token) &#123;\n        Claims claims = Jwts.parser().setSigningKey(APP_SECRET_KEY).parseClaimsJws(token).getBody();\n        ArrayList&lt;String> rols = claims.get(\"rol\", ArrayList.class);\n        return rols;\n    &#125;\n\n    /**\n     * 获解析token中的信息\n     *\n     * @param token\n     * @return\n     */\n    public static Claims checkJWT(String token) &#123;\n        try &#123;\n            final Claims claims = Jwts.parser().setSigningKey(APP_SECRET_KEY).parseClaimsJws(token).getBody();\n            return claims;\n        &#125; catch (Exception e) &#123;\n            e.printStackTrace();\n            return null;\n        &#125;\n    &#125;\n\n    /**\n     * 检查token是否过期\n     *\n     * @param token\n     * @return\n     */\n    public static boolean isExpiration(String token) &#123;\n        Claims claims = Jwts.parser().setSigningKey(APP_SECRET_KEY).parseClaimsJws(token).getBody();\n        return claims.getExpiration().before(new Date());\n    &#125;\n&#125;\n\n创建JwtUser类主要用于封装登录用户相关信息，例如用户名，密码，权限集合等，必须实现UserDetails接口\nimport org.springframework.security.core.GrantedAuthority;\nimport org.springframework.security.core.authority.SimpleGrantedAuthority;\nimport org.springframework.security.core.userdetails.UserDetails;\n\nimport java.util.Collection;\nimport java.util.Collections;\n\npublic class JwtUser implements UserDetails &#123;\n\n    private Integer id;\n    private String username;\n    private String password;\n    private Collection&lt;? extends GrantedAuthority> authorities;\n\n    public JwtUser() &#123;\n    &#125;\n\n    // 写一个能直接使用user创建jwtUser的构造器\n    public JwtUser(User user, Collection&lt;? extends GrantedAuthority> authorities) &#123;\n        id = Math.toIntExact(user.getId());\n        username = user.getUsername();\n        password = user.getPassword();\n        this.authorities = authorities;\n    &#125;\n\n    public Collection&lt;? extends GrantedAuthority> getAuthorities() &#123;\n        return authorities;\n    &#125;\n\n    public String getPassword() &#123;\n        return password;\n    &#125;\n\n    public String getUsername() &#123;\n        return username;\n    &#125;\n\n    public boolean isAccountNonExpired() &#123;\n        return true;\n    &#125;\n\n    public boolean isAccountNonLocked() &#123;\n        return true;\n    &#125;\n\n    public boolean isCredentialsNonExpired() &#123;\n        return true;\n    &#125;\n\n    public boolean isEnabled() &#123;\n        return true;\n    &#125;\n&#125;\n\n创建JwtUserService类似于自定义登录逻辑，必须实现UserDetailsService\n@Service\npublic class JwtUserService implements UserDetailsService &#123;\n\n    @Autowired\n    private PasswordEncoder passwordEncoder;\n\n    @Autowired\n    private UserMapper userMapper;\n\n    @Autowired\n    private RoleMapper roleMapper;\n\n    @Bean\n    private BCryptPasswordEncoder passwordEncoder() &#123;\n        return new BCryptPasswordEncoder();\n    &#125;\n\n    /**\n     * 根据前端传入的用户信息 去数据库查询是否存在该用户\n     *\n     * @param s\n     * @return\n     * @throws UsernameNotFoundException\n     */\n    @Override\n    public UserDetails loadUserByUsername(String s) throws UsernameNotFoundException &#123;\n        User user = this.userMapper.findUserByName(s);\n\n        user.setPassword(passwordEncoder.encode(user.getPassword()));\n\n        //用于添加用户的权限。只要把用户权限添加到authorities。\n        List&lt;GrantedAuthority> authorities = new ArrayList&lt;>();\n        Role role = roleMapper.findRoleById((int) user.getRoleId());\n        if (role != null) &#123;\n            authorities.add(new SimpleGrantedAuthority(\"ROLE_\" + role.getRoleName()));\n        &#125;\n\n        if (user != null) &#123;\n            JwtUser jwtUser = new JwtUser(user, authorities);\n            return jwtUser;\n        &#125; else &#123;\n            try &#123;\n                throw new ValidationException(\"该用户不存在\");\n            &#125; catch (ValidationException e) &#123;\n                e.printStackTrace();\n            &#125;\n        &#125;\n        return null;\n    &#125;\n&#125;\n\n\n自定义用户登录拦截器/**\n * 验证用户名密码正确后，生成一个token，并将token返回给客户端\n * 该类继承自UsernamePasswordAuthenticationFilter，重写了其中的2个方法 ,\n * attemptAuthentication：接收并解析用户凭证。\n * successfulAuthentication：用户成功登录后，这个方法会被调用，我们在这个方法里生成token并返回。\n */\npublic class JWTAuthenticationFilter extends UsernamePasswordAuthenticationFilter &#123;\n\n    private AuthenticationManager authenticationManager;\n\n    /**\n     * security拦截默认是以POST形式走/login请求，我们这边设置为走/token请求\n     *\n     * @param authenticationManager\n     */\n    public JWTAuthenticationFilter(AuthenticationManager authenticationManager) &#123;\n        this.authenticationManager = authenticationManager;\n        super.setFilterProcessesUrl(\"/token\");\n    &#125;\n\n    /**\n     * 接收并解析用户凭证\n     *\n     * @param request\n     * @param response\n     * @return\n     * @throws AuthenticationException\n     */\n    @Override\n    public Authentication attemptAuthentication(HttpServletRequest request,\n                                                HttpServletResponse response) throws AuthenticationException &#123;\n        // 从输入流中获取到登录的信息\n        try &#123;\n            User loginUser = new ObjectMapper().readValue(request.getInputStream(), User.class);\n            return authenticationManager.authenticate(\n                    new UsernamePasswordAuthenticationToken(loginUser.getUsername(), loginUser.getPassword())\n            );\n        &#125; catch (IOException e) &#123;\n            e.printStackTrace();\n            return null;\n        &#125;\n    &#125;\n\n    // 成功验证后调用的方法\n    // 如果验证成功，就生成token并返回\n    @Override\n    protected void successfulAuthentication(HttpServletRequest request,\n                                            HttpServletResponse response,\n                                            FilterChain chain,\n                                            Authentication authResult) throws IOException, ServletException &#123;\n\n        JwtUser jwtUser = (JwtUser) authResult.getPrincipal();\n        System.out.println(\"jwtUser:\" + jwtUser.toString());\n\n        List&lt;String> roles = new ArrayList&lt;>();\n        Collection&lt;? extends GrantedAuthority> authorities = jwtUser.getAuthorities();\n        for (GrantedAuthority authority : authorities) &#123;\n            roles.add(authority.getAuthority());\n        &#125;\n\n        String token = JwtUtils.createToken(jwtUser.getUsername(), roles);\n        // 返回创建成功的token  但是这里创建的token只是单纯的token\n        // 按照jwt的规定，最后请求的时候应该是 `Bearer token`\n        response.setCharacterEncoding(\"UTF-8\");\n        response.setContentType(\"application/json; charset=utf-8\");\n        String tokenStr = JwtUtils.TOKEN_PREFIX + token;\n        response.setHeader(\"token\", tokenStr);\n    &#125;\n\n    // 失败 返回错误就行\n    @Override\n    protected void unsuccessfulAuthentication(HttpServletRequest request, HttpServletResponse response, AuthenticationException failed) throws IOException, ServletException &#123;\n        response.getWriter().write(\"authentication failed, reason: \" + failed.getMessage());\n    &#125;\n&#125;\n\n自定义权限拦截器假如admin登录成功后，携带token去请求其他接口时，该拦截器会判断权限是否正确\n/**\n * 登录成功之后走此类进行  鉴定 权限\n */\npublic class JWTAuthorizationFilter extends BasicAuthenticationFilter &#123;\n\n\n    public JWTAuthorizationFilter(AuthenticationManager authenticationManager) &#123;\n        super(authenticationManager);\n    &#125;\n\n    @Override\n    protected void doFilterInternal(HttpServletRequest request,\n                                    HttpServletResponse response,\n                                    FilterChain chain) throws IOException, ServletException &#123;\n\n        String tokenHeader = request.getHeader(JwtUtils.TOKEN_HEADER);\n        // 如果请求头中没有Authorization信息则直接放行了\n        if (tokenHeader == null || !tokenHeader.startsWith(JwtUtils.TOKEN_PREFIX)) &#123;\n            chain.doFilter(request, response);\n            return;\n        &#125;\n        // 如果请求头中有token，则进行解析，并且设置认证信息\n        try &#123;\n            SecurityContextHolder.getContext().setAuthentication(getAuthentication(tokenHeader));\n        &#125; catch (Exception e) &#123;\n            e.printStackTrace();\n        &#125;\n        super.doFilterInternal(request, response, chain);\n    &#125;\n\n    // 这里从token中获取用户信息并新建一个token 就是上面说的设置认证信息\n    private UsernamePasswordAuthenticationToken getAuthentication(String tokenHeader) throws Exception &#123;\n\n        String token = tokenHeader.replace(JwtUtils.TOKEN_PREFIX, \"\");\n\n        // 检测token是否过期 如果过期会自动抛出错误\n        JwtUtils.isExpiration(token);\n        String username = JwtUtils.getUsername(token);\n        ArrayList&lt;String> roles = JwtUtils.getUserRole(token);\n        List&lt;SimpleGrantedAuthority> authorities = new ArrayList&lt;>();\n        if (roles != null) &#123;\n            for (String role : roles) &#123;\n                authorities.add(new SimpleGrantedAuthority(role));\n            &#125;\n        &#125;\n        if (username != null) &#123;\n            return new UsernamePasswordAuthenticationToken(username, null, authorities);\n        &#125;\n        return null;\n    &#125;\n&#125;\n\nSpringSecurity配置@EnableWebSecurity\npublic class SecurityConfig extends WebSecurityConfigurerAdapter &#123;\n    @Autowired\n    JwtUserService jwtUserService;\n\n    @Autowired\n    private DataSource dataSource;\n\n    @Bean\n    public PersistentTokenRepository persistentTokenRepository() &#123;\n        JdbcTokenRepositoryImpl jdbcTokenRepository = new JdbcTokenRepositoryImpl();\n        jdbcTokenRepository.setDataSource(dataSource);\n//        jdbcTokenRepository.setCreateTableOnStartup(true);\n        return jdbcTokenRepository;\n    &#125;\n\n\n    @Override\n    public void configure(WebSecurity web) throws Exception &#123;\n        web.ignoring().antMatchers(\"/resources/**\");\n    &#125;\n\n    @Override\n    protected void configure(HttpSecurity http) throws Exception &#123;\n        http.authorizeRequests()\n                .antMatchers(\"/level1/**\").authenticated()//.hasAnyRole(\"vip1\",\"vip2\",\"vip3\")\n                .antMatchers(\"/level2/**\").authenticated()//.hasAnyRole(\"vip2\",\"vip3\")\n                .antMatchers(\"/level3/**\").authenticated()//.hasAnyRole(\"vip3\")\n                .anyRequest().permitAll();\n\n        http.addFilter(new JWTAuthenticationFilter(authenticationManager())) // 用户登录拦截\n            .addFilter(new JWTAuthorizationFilter(authenticationManager())) // 权限拦截\n            // 不需要session\n            .sessionManagement()\n            .sessionCreationPolicy(SessionCreationPolicy.STATELESS)\n            .and()\n            .exceptionHandling();\n\n        http.formLogin();\n\n        http.csrf().disable();\n\n        http.logout().logoutUrl(\"/logout\").logoutSuccessUrl(\"/getuser\");\n\n        http.rememberMe()\n                .rememberMeParameter(\"rm\")\n                .rememberMeCookieName(\"rm-cookie\")\n                .tokenRepository(persistentTokenRepository())\n                .tokenValiditySeconds(60*2);\n    &#125;\n\n    @Override\n    protected void configure(AuthenticationManagerBuilder auth) throws Exception &#123;\n        auth.userDetailsService(jwtUserService);\n    &#125;\n&#125;\n\n\n\n参考：官网：https://docs.spring.io/spring-security/site/docs/5.3.9.RELEASE/reference/html5/#servlet-applications\n视频：https://www.bilibili.com/video/BV15a411A7kP\n参考文章1：https://www.cnblogs.com/lenve/p/11242055.html\n参考文章2：https://www.jianshu.com/p/7817e372c1db\n参考文章3：https://blog.csdn.net/qq_42640067/article/details/113062222\n参考文章4：https://blog.csdn.net/qq_22172133/article/details/86503223\nJWT参考：https://blog.csdn.net/weixin_45452416/article/details/109528425\n","categories":["SpringBoot"],"tags":["Spring","SpringBoot","SpringSecurity"]},{"title":"SpringBoot-Elasticsearch","url":"/2021/05/07/SpringBoot-Elasticsearch/","content":"ElasticsearchElasticsearch 简介\n一个分布式的、Restful 风格的搜索引擎\n支持对各种类型的数据的检索\n搜索速度快，可以提供实时的搜索服务\n便于水平扩展，每秒可以处理 PB 级海量数据\n\nElasticsearch 术语\n索引、类型、文档、字段\n集群、节点、分片、副本\n\n索引可以理解为一个数据库\n类型为一张表\n文档为一条数据，通常为 JSON 结果\n字段为表中的列\n在 ES6 以后，逐渐废弃上面的类型，ES7(本文使用)彻底废除，由索引逐渐代替其功能\nElasticsearch 和 SpringBoot 是有版本对应的，点击查看\n下载Elasticsearch，在使用 ES 之前，还需要装一个ik 分词器，下载好之后，将其解压至 ES 的 plugins 文件夹中的 ik 文件夹(无则创建)\n在使用 ES 之前，我们最好简单更改一下其配置，在 config 目录下，找到 elasticsearch.yml，进行如下更改\n# 集群的名字 随意\ncluster.name: nowcoder\n# ES数据存储路径\npath.data: &#x2F;home&#x2F;gas&#x2F;桌面&#x2F;elasticsearch-7.12.0&#x2F;data\n# 日志\npath.logs: &#x2F;home&#x2F;gas&#x2F;桌面&#x2F;elasticsearch-7.12.0&#x2F;logs\n\n然后执行 bin 目录下的 elasticsearch 文件即可\nSpringBoot 使用 Elasticsearch1. Maven 引入&lt;!-- elasticsearch -->\n&lt;dependency>\n    &lt;groupId>org.springframework.boot&lt;/groupId>\n    &lt;artifactId>spring-boot-starter-data-elasticsearch&lt;/artifactId>\n&lt;/dependency>\n\n2. yml 配置spring:\n  elasticsearch:\n    rest:\n      username: nowcoder #   填写上面自己配置的\n      uris: 127.0.0.1:9200 #   es的ip:port\n\n3. 配置 ES 实体类直接用现有的实体类就好，并不冲突\n//indexName：索引的名称\n//shards：分片\n//replicas：副本\n//type：7.x不用写\n@Document(indexName = \"discusspost\", shards = 6, replicas = 3)\npublic class DiscussPost &#123;\n\n    //声明ID\n    @Id\n    private int id;\n\n    //声明类型\n    @Field(type = FieldType.Integer)\n    private int userId;\n\n    //后面两个是使用的分词器的名字，没什么必要无须更改，前面是存储数据时使用的解析器(存储时尽可能拆分出更多的词语进行存储)，后面是搜索时使用的解析器(搜索时无须过分分词)\n    @Field(type = FieldType.Text, analyzer = \"ik_max_word\", searchAnalyzer = \"ik_smart\")\n    private String title;\n\n    @Field(type = FieldType.Text, analyzer = \"ik_max_word\", searchAnalyzer = \"ik_smart\")\n    private String content;\n\n    //name：字段在es中的名称\n    @Field(name = \"type\",type = FieldType.Integer)\n    private int type;\n    @Field(type = FieldType.Integer)\n    private int status;\n    @Field(name = \"createTime\",type = FieldType.Date)\n    private Date createTime;\n    @Field(type = FieldType.Integer)\n    private int commentCount;\n    @Field(name = \"score\",positiveScoreImpact = false,type = FieldType.Double)\n    private double score;\n&#125;\n\n4. 创建一个操作 ES 的类@Repository                                                         //&lt;处理的对象，对象的主键类型>\npublic interface DiscussPostRepository extends ElasticsearchRepository&lt;DiscussPost,Integer> &#123;\n    //高亮\n    @Highlight(\n            fields = &#123;\n                    @HighlightField(name = \"title\"),\n                    @HighlightField(name = \"content\")\n            &#125;,parameters = @HighlightParameters(\n                    preTags = \"&lt;em>\",\n                    postTags = \"&lt;/em>\"\n    ))\n    //Pageable包含了排序功能，如果你只需要排序，则替换成Sort sort即可，注意：Pageable和Sort不能同时存在\n    List&lt;SearchHit&lt;DiscussPost>> findDiscussPostByTitleLikeOrContentLike(String title,String content,Pageable pageable);\n    //注意，方法的名称findDiscussPostByTitleLikeOrContentLike可不是乱写的，是用含义的，底层会根据方法名称去构建搜索语句\n    //当然，也可以用@Query注解自定义搜索语句，下面是官方文档的声明\n    //https://docs.spring.io/spring-data/elasticsearch/docs/4.1.8/reference/html/#elasticsearch.query-methods\n&#125;\n\n5. 实际操作演示@Autowired\nprivate DiscussPostRepository discussPostRepository;\n\n//保存数据，这里是从数据库中读取了一条DiscussPost类型的数据存入es中\ndiscussPostRepository.save(discussPostMapper.selectDiscussPostById(230));\n//批量存储\ndiscussPostRepository.saveAll(discussPostMapper.selectDiscussPosts(101, 0, 100,0));\n//更新数据\nDiscussPost discussPost = discussPostMapper.selectDiscussPostById(231);\ndiscussPost.setContent(\"我是新人，使劲灌水\");\ndiscussPostRepository.save(discussPost);\n//根据ID删除\ndiscussPostRepository.deleteById(231);\n//删除所有\ndiscussPostRepository.deleteAll();\n\n//搜索\npublic void Select()&#123;\n    Sort sort = Sort.by(\"score\").descending()\n        .and(Sort.by(\"type\").descending())\n        .and(Sort.by(\"createTime\").descending());\n\n    List&lt;SearchHit&lt;DiscussPost>> post = discussPostRepository\n        \t\t\t\t\t\t\t\t\t\t\t\t\t\t//分页数据第1页，10条数据，排序\n        .findDiscussPostByTitleLikeOrContentLike(\"压力数据\", \"压力\",PageRequest.of(1,10,sort));\n\n    post.forEach(res-> &#123;\n        System.out.println(\"查询结果：\" + res);\n    &#125;);\n&#125;\n\n参考：\n官方文档：https://docs.spring.io/spring-data/elasticsearch/docs/4.1.8/reference/html/#repositories\n文章：https://zhuanlan.zhihu.com/p/321248369\n","categories":["SpringBoot"],"tags":["Spring","SpringBoot","Elasticsearch"]},{"title":"SpringBoot-Kafka","url":"/2021/05/02/SpringBoot-Kafka/","content":"什么是 KafkaKafka 最初由 Linkedin 公司开发，是一个分布式的、_分区的_、_多副本的_、_多订阅者_，基于 zookeeper 协调的分布式日志系统（也可以当做 MQ 系统），常用于 web/nginx 日志、访问日志、消息服务等等，Linkedin 于 2010 年贡献给了 Apache 基金会并成为顶级开源项目。\n\n高吞吐量、低延迟：kafka 每秒可以处理几十万条消息，它的延迟最低只有几毫秒；\n可扩展性：kafka 集群支持热扩展；\n持久性、可靠性：消息被持久化到本地磁盘，并且支持数据备份防止丢失；\n容错性：允许集群中的节点失败(若分区副本数量为 n,则允许 n-1 个节点失败)；\n高并发：单机可支持数千个客户端同时读写；\n\n下载地址\n下载完成之后，打开config文件夹，简单更改一下配置文件。\n\n找到zookeeper.properties进行修改\n#zookeeper运行时产生的文件存放路径，win可能需要注意\ndataDir=/tmp/zookeeper\n\n\n找到server.properties进行修改\n#kafka运行时日志文件存放路径\nlog.dirs=/tmp/kafka-logs\n#kafka组id\ngroup.id=test-consumer-group\n\n\n\n完成后，以正确的顺序启动所有服务：\n# Start the ZooKeeper service\n# Note: Soon, ZooKeeper will no longer be required by Apache Kafka.\n$ bin/zookeeper-server-start.sh config/zookeeper.properties\n\n打开另一个终端：\n# Start the Kafka broker service\n$ bin/kafka-server-start.sh config/server.properties\n\n成功启动所有服务后，您将运行并可以使用基本的 Kafka 环境。\nSpringBoot 中使用 Kafka1. 添加所需要的依赖&lt;dependency&gt;\n  &lt;groupId&gt;org.springframework.kafka&lt;/groupId&gt;\n  &lt;artifactId&gt;spring-kafka&lt;/artifactId&gt;\n&lt;/dependency&gt;\n\n2. Kafka 的部分配置###########【Kafka集群】###########\nspring.kafka.bootstrap-servers=112.126.74.249:9092,112.126.74.249:9093\n###########【初始化生产者配置】###########\n# 重试次数\nspring.kafka.producer.retries=0\n# 应答级别:多少个分区副本备份完成时向生产者发送ack确认(可选0、1、all/-1)\nspring.kafka.producer.acks=1\n# 批量大小\nspring.kafka.producer.batch-size=16384\n# 提交延时\nspring.kafka.producer.properties.linger.ms=0\n# 当生产端积累的消息达到batch-size或接收到消息linger.ms后,生产者就会将消息提交给kafka\n# linger.ms为0表示每接收到一条消息就提交给kafka,这时候batch-size其实就没用了\n# 生产端缓冲区大小\nspring.kafka.producer.buffer-memory = 33554432\n# Kafka提供的序列化和反序列化类\nspring.kafka.producer.key-serializer=org.apache.kafka.common.serialization.StringSerializer\nspring.kafka.producer.value-serializer=org.apache.kafka.common.serialization.StringSerializer\n# 自定义分区器\n# spring.kafka.producer.properties.partitioner.class=com.felix.kafka.producer.CustomizePartitioner\n# 事务初始化 设置为一个非空的字符串即可开启事务功能\nspring.kafka.producer.transaction-id-prefix=transaction\n###########【初始化消费者配置】###########\n# 默认的消费组ID\nspring.kafka.consumer.properties.group.id=defaultConsumerGroup\n# 是否自动提交offset\nspring.kafka.consumer.enable-auto-commit=true\n# 提交offset延时(接收到消息后多久提交offset)\nspring.kafka.consumer.auto.commit.interval.ms=1000\n# 当kafka中没有初始offset或offset超出范围时将自动重置offset\n# earliest:重置为分区中最小的offset;\n# latest:重置为分区中最新的offset(消费分区中新产生的数据);\n# none:只要有一个分区不存在已提交的offset,就抛出异常;\nspring.kafka.consumer.auto-offset-reset=latest\n# 消费会话超时时间(超过这个时间consumer没有发送心跳,就会触发rebalance操作)\nspring.kafka.consumer.properties.session.timeout.ms=120000\n# 消费请求超时时间\nspring.kafka.consumer.properties.request.timeout.ms=180000\n# Kafka提供的序列化和反序列化类\nspring.kafka.consumer.key-deserializer=org.apache.kafka.common.serialization.StringDeserializer\nspring.kafka.consumer.value-deserializer=org.apache.kafka.common.serialization.StringDeserializer\n# 消费端监听的topic不存在时，项目启动会报错(关掉)\nspring.kafka.listener.missing-topics-fatal=false\n# 设置批量消费\n# spring.kafka.listener.type=batch\n# 批量消费每次最多消费多少条消息\n# spring.kafka.consumer.max-poll-records=50\n\n#==================================================\n#一般来说 配置一下就行\nspring:\n  kafka:\n      bootstrap-servers: localhost:9092\n      consumer:\n        group-id: test-consumer-group\n        enable-auto-commit: true\n        auto-commit-interval: 3000\n\n3. 生产者//生产者\n@Component\npublic class EventProducet &#123;\n\n    @Autowired\n    private KafkaTemplate kafkaTemplate;//也可以通过&lt;T, T&gt;的方式来指定类型，默认都是String\n\n    //发送事件\n    public void fireEvent(Event event)&#123;\n        //将事件发布到指定主题          这里是封装了一个事件类，发布事件时将事件类转换成JSON\n        kafkaTemplate.send(&quot;topic1&quot;, JSONObject.toJSONString(event));\n    &#125;\n&#125;\n\n//生产者\n@Component\nclass KafkaProducer&#123;\n    @Autowired\n    private KafkaTemplate kafkaTemplate;\n\n    public void sendMessage(String topic,String content)&#123;\n        kafkaTemplate.send(topic,content);\n    &#125;\n&#125;\n\n4. 消费者@Component\npublic class KafkaConsumer &#123;\n    // 消费监听\n    @KafkaListener(topics = &#123;&quot;topic1&quot;&#125;)\n    public void onMessage1(ConsumerRecord&lt;?, ?&gt; record)&#123;\n        // 消费的哪个topic、partition的消息,打印出消息内容\n        System.out.println(&quot;============&quot;+record.topic()+&quot;-&gt;&quot;+record.partition()+&quot;-&gt;&quot;+record.value()+&quot;============&quot;);\n    &#125;\n&#125;\n\n上面的实例创建了一个生产者，发送消息到topic1，然后又一个消费者监听topic1，监听用 @KafkaListener注解，topic 表示要监听的 topic，支持同时监听多个，有逗号分隔\n创建一个测试类进行测试\n@SpringBootTest\npublic class KafkaTest &#123;\n    @Autowired\n    KafkaProducer kafkaProducer;\n    @Test\n    public void testKafka() throws InterruptedException &#123;\n         kafkaProducer.sendMessage(&quot;topic1&quot;, &quot;Hello&quot;);\n         kafkaProducer.sendMessage(&quot;topic1&quot;, &quot;World&quot;);\n         Thread.sleep(1000*10);\n    &#125;\n&#125;\n\n\n可以看到成功运行\n最简单的应用便到此结束\n生产者的更多使用方法1. 待回调的生产者Kafka 提供了一个回调方法 addCallback，我们可以在回调方法中监控信息是否发送成功或失败做补偿处理，有两种写法\n\n@Component\nclass KafkaProducer &#123;\n    @Autowired\n    private KafkaTemplate kafkaTemplate;\n\n    public void sendMessage(String topic, String content) &#123;\n        kafkaTemplate.send(topic, content).addCallback(new ListenableFutureCallback&lt;SendResult&lt;String, String&gt;&gt;() &#123;\n            @Override\n            public void onFailure(Throwable throwable) &#123;\n                System.out.println(&quot;发送消息失败：&quot; + throwable.getMessage());\n            &#125;\n\n            @Override\n            public void onSuccess(SendResult&lt;String, String&gt; result) &#123;\n                System.out.println(&quot;发送消息成功：&quot; + result.getRecordMetadata().topic() + &quot;-&quot;\n                        + result.getRecordMetadata().partition() + &quot;-&quot; + result.getRecordMetadata().offset() + &quot;-&quot; + result.getProducerRecord().value());\n            &#125;\n        &#125;);\n    &#125;\n&#125;\n\n@Component\nclass KafkaProducer &#123;\n    @Autowired\n    private KafkaTemplate kafkaTemplate;\n\n    public void sendMessage(String topic, String content) &#123;\n        ListenableFuture&lt;SendResult&lt;String,String&gt;&gt; future = kafkaTemplate.send(topic, content);\n        future.addCallback((result)-&gt; &#123;\n            // 消息发送到的topic\n            String tp = result.getRecordMetadata().topic();\n            // 消息发送到的分区\n            int partition = result.getRecordMetadata().partition();\n            // 消息在分区内的offset\n            long offset = result.getRecordMetadata().offset();\n            System.out.println(&quot;发送消息成功:&quot; + tp + &quot;-&quot; + partition + &quot;-&quot; + offset);\n        &#125;, (KafkaFailureCallback&lt;Integer, String&gt;) ex -&gt; &#123;\n            ProducerRecord&lt;Integer, String&gt; failed = ex.getFailedProducerRecord();\n        &#125;);\n    &#125;\n&#125;\n\n2. 自定义分区kafka 中每个 topic 划分了多个分区，那么生产者将消息发送到 topic 时，具体追加到那个分区呢？这就是所谓的分区策略，kafka 为我们提供了默认的分区策略，同时它也支持自定义分区策略，其路由机制为：\n\n 若发送消息时指定了分区（即自定义分区策略），则直接将消息 append 到指定分区。\n 若发送消息时未指定 partition，但指定了 key（kafka 允许为每条消息设置一个 key），则对 key 值进行 hash 计算，根据计算结构路由到指定分区，这种情况下可以保证同一个 key 的所有消息都进入相同的分区。\n\npartition 和 key 都未指定，则使用 kafka 默认的分区策略，轮询出一个 partition\n自定义一个分区策略，将消息发送到我们指定的 partition，首先建立一个分区器类实现 Partitioner 接口，重写方法，其中 partition 方法的返回值表示将消息发送到几号分区。\npublic class CustomizePartitioner implements Partitioner &#123;\n    @Override\n    public int partition(String s, Object o, byte[] bytes, Object o1, byte[] bytes1, Cluster cluster) &#123;\n        // 自定义分区规则(这里假设全部发到0号分区)\n        // ......\n        return 0;\n    &#125;\n\n    @Override\n    public void close() &#123;\n\n    &#125;\n\n    @Override\n    public void configure(Map&lt;String, ?&gt; map) &#123;\n\n    &#125;\n&#125;\n\n3. kafka 事务提交如果发送消息时需要创建事务，可以使用 kafkaTemplate 的 executeInTransaction 方法来声明事务。\n需要先进行配置 yml\nspring.kafka.producer.transaction-id-prefix=transaction\n\n@Component\nclass KafkaProducer &#123;\n    @Autowired\n    private KafkaTemplate kafkaTemplate;\n\n    public void sendMessage(String topic, String content) &#123;\n        kafkaTemplate.executeInTransaction(new KafkaOperations.OperationsCallback() &#123;\n            @Override\n            public Object doInOperations(KafkaOperations kafkaOperations) &#123;\n                kafkaOperations.send(topic, content);\n                throw new RuntimeException(&quot;fail&quot;);\n//                return true;\n            &#125;\n        &#125;);\n    &#125;\n&#125;\n\n消费者的更多使用方法1. 指定 topic、partition、offset 消费前面我们只监听了 topic1，监听的是所有在 topic1 上的消息，我们还可以指定 topic、partition、offset，在@KafkaListener注解上全部为我们提供了\n/**\n * @Title 指定topic、partition、offset消费\n * @Description 同时监听topic1和topic2，监听topic1的0号分区、topic2的 &quot;0号和1号&quot; 分区，指向1号分区的offset初始值为8\n **/\n@Component\nclass KafkaConsumer&#123;\n    @KafkaListener(id = &quot;consumer1&quot;,groupId = &quot;felix-group&quot;,topicPartitions = &#123;\n            @TopicPartition(topic = &quot;topic1&quot;,partitions = &#123;&quot;0&quot;&#125;),\n            @TopicPartition(topic = &quot;topic2&quot;,partitions = &quot;0&quot;,partitionOffsets = @PartitionOffset(partition = &quot;1&quot;,initialOffset = &quot;8&quot;))\n    &#125;)\n    public void handleMessage(ConsumerRecord record)&#123;\n        System.out.println(&quot;============&quot;+record.topic()+&quot;-&gt;&quot;+record.partition()+&quot;-&gt;&quot;+record.value()+&quot;============&quot;);\n    &#125;\n&#125;\n\n\nid：消费者 ID\ngroupid：消费组 ID\ntopics：监听的 topic，可以监听多个\ntopicPartitions：可以配置更加详细的监听信息，可以指定 topic、parition、offset 监听\n\n上面 handleMessage 监听的含义：监听 topic1 的 0 号分区，同时监听 topic2 的 0 号分区和 topic2 的 1 号分区里面 offset 从 8 开始的消息。\n注意：topics 和 topicPartitions 不能同时使用；\n2. 批量消费修改配置文件，开启批量消费\n# 设置批量消费\nspring.kafka.listener.type=batch\n# 批量消费每次最多消费多少条消息\nspring.kafka.consumer.max-poll-records=50\n\n接收消息时使用 List 来接收，监听代码如下\n@KafkaListener(topics = &quot;topic1&quot;)\n//也可以使用List&lt;ConsumerRecord&lt;?, ?&gt;&gt;\npublic void onMessage3(ConsumerRecords&lt;?, ?&gt; records) &#123;\n    System.out.println(&quot;&gt;&gt;&gt;批量消费一次，records.size()=&quot;+records.count());\n    for (ConsumerRecord&lt;?, ?&gt; record : records) &#123;\n        System.out.println(record.value());\n    &#125;\n&#125;\n\n3. 异常处理器通过异常处理，我们可以处理 consumer 在消费时发生的异常。\n创建一个 ConsumerAwareListenerErrorHandler 类型的异常处理方法，使用@Bean 注入，然后将这个异常处理的 BeanName 放到@KafkaListener 注解的 errorHandler 属性里面，当监听抛出异常的时候，则会自动调用异常处理器\n@Bean\npublic ConsumerAwareListenerErrorHandler consumerAwareErrorHandler() &#123;\n    return (message, exception, consumer) -&gt; &#123;\n        System.out.println(&quot;消费异常：&quot;+message.getPayload());\n        return null;\n    &#125;;\n&#125;\n\n@KafkaListener(topics = &#123;&quot;topic1&quot;&#125;,errorHandler = &quot;consumerAwareErrorHandler&quot;)\n\n4. 消息过滤器// 监听器工厂\n@Autowired\nprivate ConsumerFactory consumerFactory;\n\n// 配置一个消息过滤策略\n@Bean\npublic ConcurrentKafkaListenerContainerFactory myFilterContainerFactory() &#123;\n    ConcurrentKafkaListenerContainerFactory factory =\n        new ConcurrentKafkaListenerContainerFactory();\n    factory.setConsumerFactory(consumerFactory);\n    // 被过滤的消息将被丢弃\n    factory.setAckDiscarded(true);\n    // 消息过滤策略（将消息转换为int类型，判断是奇数还是偶数，把所有奇数过滤，监听器只接收偶数）\n    factory.setRecordFilterStrategy(consumerRecord -&gt; &#123;\n        if (Integer.parseInt(consumerRecord.value().toString()) % 2 == 0) &#123;\n            return false;\n        &#125;\n        //返回true消息则被过滤\n        return true;\n    &#125;);\n    return factory;\n&#125;\n\n@KafkaListener(topics = &quot;topic1&quot;,containerFactory = &quot;myFilterContainerFactory&quot;)\n\n上面实现了一个”过滤奇数、接收偶数”的过滤策略，我们向 topic1 发送 0-99 总共 100 条消息，看一下监听器的消费情况，可以看到监听器只消费了偶数\n5. 消息转发在实际开发中，我们可能有这样的需求，应用 A 从 TopicA 获取到消息，经过处理后转发到 TopicB，再由应用 B 监听处理消息，即一个应用处理完成后将该消息转发至其他应用，完成消息的转发。\n在 SpringBoot 集成 Kafka 实现消息的转发也很简单，只需要通过一个@SendTo 注解，被注解方法的 return 值即转发的消息内容，如下：\n@Component\nclass KafkaConsumer &#123;\n    @KafkaListener(topics = &quot;topic1&quot;)\n    @SendTo(&quot;topic2&quot;)//使用前需要配置KafkaTemplate,有点麻烦,实在需要的话照着官方文档复制粘贴就好了\n    public String handleMessage(ConsumerRecord&lt;?, ?&gt; record) &#123;\n//        System.out.println(record.value()+&quot;-&gt;topic1&quot;);\n        return record.value()+&quot;-forward message&quot;;\n    &#125;\n\n    @KafkaListener(topics = &quot;topic2&quot;)\n    public void handleMessage2(ConsumerRecord&lt;?, ?&gt; record) &#123;\n        System.out.println(record.value()+&quot;-&gt;topic2&quot;);\n    &#125;\n&#125;\n\n6. 定时启动、停止监听器默认情况下，当消费者项目启动的时候，监听器就开始工作，监听消费发送到指定 topic 的消息，那如果我们不想让监听器立即工作，想让它在我们指定的时间点开始工作，或者在我们指定的时间点停止工作，该怎么处理呢——使用 KafkaListenerEndpointRegistry，下面我们就来实现：\n\n 禁止监听器自启动；\n\n 创建两个定时任务，一个用来在指定时间点启动定时器，另一个在指定时间点停止定时器；\n\n\n新建一个定时任务类，用注解@EnableScheduling 声明，KafkaListenerEndpointRegistry 在 SpringIO 中已经被注册为 Bean，直接注入，设置禁止 KafkaListener 自启动，\n@EnableScheduling\n@Component\npublic class CronTimer &#123;\n\n    /**\n     * @KafkaListener注解所标注的方法并不会在IOC容器中被注册为Bean，\n     * 而是会被注册在KafkaListenerEndpointRegistry中，\n     * 而KafkaListenerEndpointRegistry在SpringIOC中已经被注册为Bean\n     **/\n    @Autowired\n    private KafkaListenerEndpointRegistry registry;\n\n    @Autowired\n    private ConsumerFactory consumerFactory;\n\n    // 监听器容器工厂(设置禁止KafkaListener自启动)\n    @Bean\n    public ConcurrentKafkaListenerContainerFactory delayContainerFactory() &#123;\n        ConcurrentKafkaListenerContainerFactory container = new ConcurrentKafkaListenerContainerFactory();\n        container.setConsumerFactory(consumerFactory);\n        //禁止KafkaListener自启动\n        container.setAutoStartup(false);\n        return container;\n    &#125;\n\n    // 监听器\n    @KafkaListener(id=&quot;timingConsumer&quot;,topics = &quot;topic1&quot;,containerFactory = &quot;delayContainerFactory&quot;)\n    public void onMessage1(ConsumerRecord&lt;?, ?&gt; record)&#123;\n        System.out.println(&quot;消费成功：&quot;+record.topic()+&quot;-&quot;+record.partition()+&quot;-&quot;+record.value());\n    &#125;\n\n    // 定时启动监听器\n    @Scheduled(cron = &quot;0 42 11 * * ? &quot;)\n    public void startListener() &#123;\n        System.out.println(&quot;启动监听器...&quot;);\n        // &quot;timingConsumer&quot;是@KafkaListener注解后面设置的监听器ID,标识这个监听器\n        if (!registry.getListenerContainer(&quot;timingConsumer&quot;).isRunning()) &#123;\n            registry.getListenerContainer(&quot;timingConsumer&quot;).start();\n        &#125;\n        //registry.getListenerContainer(&quot;timingConsumer&quot;).resume();\n    &#125;\n\n    // 定时停止监听器\n    @Scheduled(cron = &quot;0 45 11 * * ? &quot;)\n    public void shutDownListener() &#123;\n        System.out.println(&quot;关闭监听器...&quot;);\n        registry.getListenerContainer(&quot;timingConsumer&quot;).pause();\n    &#125;\n&#125;\n\n参考文章：\nKafka：http://kafka.apache.org/\nKafka 原理架构：点击链接\n文章：https://blog.csdn.net/yuanlong122716/article/details/105160545/\nSpringBootKafka：https://docs.spring.io/spring-kafka/docs/current/reference/html/#preface\n","categories":["SpringBoot"],"tags":["Spring","SpringBoot","Kafka"]},{"title":"SpringBoot Quartz","url":"/2021/04/27/SpringBoot-Quartz/","content":"什么是QuartzQuartz是OpenSymphony开源组织在Job scheduling领域又一个开源项目，完全由Java开发，可以用来执行定时任务，类似于java.util.Timer。但是相较于Timer， Quartz增加了很多功能：\n\n持久性作业 - 就是保持调度定时的状态;\n作业管理 - 对调度作业进行有效的管理;\n\n在实际项目开发中，随着业务的增大，需要操作Job的也就越多，肯定不能是人工操作，我们需要应该自动调度的任务框架去解决，功能的具体实现如下：\n\n首先我们需要定义实现一个定时功能的接口，我们可以称之为Task或者Job（Quartz中称之为Job），如定时发送邮件Job，优惠卷到期通知Job，实现如下：\n\n有了Job之后，我们需要一个能触发Job并执行的触发器（Trigger），Trigger最基本的功能是指定Job的执行时间，执行间隔，运行次数等。\n\n有了Job和Trigger后，需要一个Schedule，来指定Trigger去执行指定的Job。\n\n\n上面三个部分就是Quartz的基本组成部分：\n\n调度器：Scheduler\n任务：JobDetail\n触发器：Trigger，包括SimpleTrigger和CronTrigger\n\nQuartz在SpringBoot的应用\n使用Maven添加依赖\n&lt;!-- SpringBoot 整合 Quartz 定时任务 -->\n&lt;dependency>\n    &lt;groupId>org.springframework.boot&lt;/groupId>\n    &lt;artifactId>spring-boot-starter-quartz&lt;/artifactId>\n    &lt;version>2.3.5.RELEASE&lt;/version>\n&lt;/dependency>\n配置yml\nspring:\n  quartz:\n    scheduler-name: communityScheduler//scheduler名称\n    job-store-type: jdbc//持久化方法\n实现Job接口，实现定时任务逻辑\npublic class AlphaJob implements Job &#123;\n    //实现Job接口\n    @Override\n    public void execute(JobExecutionContext jobExecutionContext) throws JobExecutionException &#123;\n        System.out.println(Thread.currentThread().getName()+\": execute a quartz job.\");\n    &#125;\n&#125;\n配值定时任务，创建一个Config类，设置\n//配置-》数据库-》调用\n//Quartz 定时任务配置类\n@Configuration\npublic class QuartzConfig &#123;\n    //FactoryBean可简化Bean的实例化过程：\n    //1.通过FactoryBean封装Bean的实例化过程\n    //2.将FactoryBean封装到Spring容器中\n    //3.将FactoryBean注入给其他的Bean\n    //4.该Bean得到的是FactoryBean所管理的对象实例\n\n    // 配置JobDetail\n    @Bean\n    public JobDetailFactoryBean alphaJobDetail()&#123;\n        JobDetailFactoryBean factoryBean = new JobDetailFactoryBean();\n        factoryBean.setJobClass(AlphaJob.class);\n        factoryBean.setName(\"alphaJob\");//设置名称\n        factoryBean.setGroup(\"alphaJobGroup\");//设置分组\n        factoryBean.setDurability(true);//是否持久(数据库中是否删除)\n        factoryBean.setRequestsRecovery(true);//是否可恢复\n        return factoryBean;\n    &#125;\n\n    // 配置Trigger(SimpleTriggerFactoryBean(简单任务用，按指定的时间间隔执行多少次任务的情况),CronTriggerFactoryBean(复杂任务用，通过Cron表达式来控制任务的执行时间))\n    @Bean\n    public SimpleTriggerFactoryBean alphaTrigger(JobDetail alphaJobDetail)&#123;\n        SimpleTriggerFactoryBean factoryBean = new SimpleTriggerFactoryBean();\n        factoryBean.setJobDetail(alphaJobDetail);//关联上述JobDetail\n        factoryBean.setName(\"alphaTrigger\");//设置名称\n        factoryBean.setGroup(\"alphaTriggerGroup\");//设置分组\n        factoryBean.setRepeatInterval(3000);//设置执行的时间间隔\n        factoryBean.setJobDataMap(new JobDataMap());\n        return factoryBean;\n    &#125;\n&#125;\n\nJobDetail绑定指定的Job，每次调用时，首先会拿到对应的JobDetail，然后创建Job实例，在去执行Job中execute()中的内容，任务结束后，关联的Job对象实例会被释放，且会被JVM GC清除。\n为什么设计成JobDetail+Job，不直接使用Job\n\nJobDetail定义的是任务数据，而真正执行逻辑在Job中\n如果直接使用Job，就会存在对同一个Job实例并发访问的问题，而JobDetail + Job方式，每次执行时，都会根据JobDetail创建一个新Job实例，这样可以避免并发问题\n\n\n\n到此为止，Scheduler会在底层自动调用我们上面定义的定时任务。\n参考：\n官网：http://www.quartz-scheduler.org/\nCron表达式：https://cron.qqe2.com/\n文章：https://blog.csdn.net/noaman_wgs/article/details/80984873\n文章：https://www.jianshu.com/p/06c4307214b7\n","categories":["SpringBoot"],"tags":["Spring","SpringBoot","Quartz"]},{"title":"OData在DotNetCore中的应用","url":"/2021/04/08/OData%E5%9C%A8DotNetCore%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8/","content":"什么是OData开放数据协议（Open Data Protocol，简称OData）是一种描述如何创建和访问Restful服务的OASIS标准。该标准由微软发起 [1] ，前三个版本1.0、2.0、3.0都是微软开放标准，遵循微软开放规范承诺书（Microsoft Open Specification Promise）。第四个版本4.0于2014年3月17日在OASIS投票通过成为开放工业标准\n上面是百度的答案，我们可以很清楚的知道这是一个协议\n使用OData开发以.NetCoreAPI为例，创建一个API项目\n添加ASP.NET Core OData和Microsoft.EntityFrameworkCore.InMemoryNuget程序包\n&lt;Project Sdk=&quot;Microsoft.NET.Sdk.Web&quot;&gt;\n\n  &lt;PropertyGroup&gt;\n    &lt;TargetFramework&gt;net5.0&lt;/TargetFramework&gt;\n    &lt;UserSecretsId&gt;0d1b65c3-336b-4511-be78-68c012362630&lt;/UserSecretsId&gt;\n    &lt;DockerDefaultTargetOS&gt;Linux&lt;/DockerDefaultTargetOS&gt;\n  &lt;/PropertyGroup&gt;\n\n  &lt;ItemGroup&gt;\n    &lt;PackageReference Include=&quot;Microsoft.AspNetCore.OData&quot; Version=&quot;7.4.1&quot; /&gt;\n    &lt;PackageReference Include=&quot;Microsoft.EntityFrameworkCore.InMemory&quot; Version=&quot;5.0.5&quot; /&gt;\n    &lt;PackageReference Include=&quot;Microsoft.VisualStudio.Azure.Containers.Tools.Targets&quot; Version=&quot;1.10.9&quot; /&gt;\n    &lt;PackageReference Include=&quot;Swashbuckle.AspNetCore&quot; Version=&quot;5.6.3&quot; /&gt;\n  &lt;/ItemGroup&gt;\n\n&lt;/Project&gt;\n\nASP.NET Core OData程序包是为了更方便的去开发而引入的\nMicrosoft.EntityFrameworkCore.InMemory则方便数据引入\n添加Model类// Book\npublic class Book\n&#123;\n  public int Id &#123; get; set; &#125;\n  public string ISBN &#123; get; set; &#125;\n  public string Title &#123; get; set; &#125;\n  public string Author &#123; get; set; &#125;\n  public decimal Price &#123; get; set; &#125;\n  public Address Location &#123; get; set; &#125;\n  public Press Press &#123; get; set; &#125;\n&#125;\n\n// Press\npublic class Press\n&#123;\n  public int Id &#123; get; set; &#125;\n  public string Name &#123; get; set; &#125;\n  public string Email &#123; get; set; &#125;\n  public Category Category &#123; get; set; &#125;\n&#125;\n\n// Category\npublic enum Category\n&#123;\n  Book,\n  Magazine,\n  EBook\n&#125;\n\n// Address\npublic class Address\n&#123;\n  public string City &#123; get; set; &#125;\n  public string Street &#123; get; set; &#125;\n&#125;\n\n在这里:\n\nBook，Press将作为实体类型\nAddress将用作“复杂”类型。\nCategory将用作枚举类型。\n\n建立EDM(Entity Data Model)模型OData基于实体数据模型(EDM)来描述数据结构，在ASP.Net Core OData中，可以轻松的基于上述模型建立，在Startup类末尾加一个私有方法\n        private static IEdmModel GetEdmModel()\n        &#123;\n            ODataConventionModelBuilder builder = new ODataConventionModelBuilder();\n            builder.EntitySet&lt;Book&gt;(&quot;Books&quot;);\n            builder.EntitySet&lt;Press&gt;(&quot;Presses&quot;);\n            return builder.GetEdmModel();\n        &#125;\n\n在这里我们定义了两个名为Books和Presses 的实体集\n通过依赖注入注册服务ASP.NET Core OData需要预先注册一些服务才能提供其功能，该库提供了一个名为AddOData()的扩展方法，以通过内置的依赖项注入来注册所需要的OData服务，因此，修改如下代码到ConfigureServices中\n    public class Startup\n    &#123;\n          // ...\n\n          public void ConfigureServices(IServiceCollection services)\n          &#123;\n                services.AddOData();\n                services.AddControllers();\n                services.AddSwaggerGen(c =&gt;\n                &#123;\n                    c.SwaggerDoc(&quot;v1&quot;, new OpenApiInfo &#123; Title = &quot;WebApplication1&quot;, Version = &quot;v1&quot; &#125;);\n                &#125;);\n          &#125;\n    &#125;\n\n注册OData端点我们需要添加OData路由来注册OData端点，并调用GetEdmModel()绑定EDM模型到端点\n    public class Startup\n    &#123;\n          // ...\n\n        public void Configure(IApplicationBuilder app, IWebHostEnvironment env)\n        &#123;\n            if (env.IsDevelopment())\n            &#123;\n                app.UseDeveloperExceptionPage();\n                app.UseSwagger();\n                app.UseSwaggerUI(c =&gt; c.SwaggerEndpoint(&quot;/swagger/v1/swagger.json&quot;, &quot;WebApplication1 v1&quot;));\n            &#125;\n\n            app.UseEndpoints(endpoints =&gt;\n            &#123;\n                endpoints.MapODataRoute(&quot;odata&quot;, &quot;odata&quot;, GetEdmModel());\n            &#125;);\n        &#125;\n    &#125;\n\n8.0版本无需在Configure中注册:\npublic class Startup\n&#123;\n    public void ConfigureServices(IServiceCollection services)\n    &#123;\n        services.AddDbContext&lt;BookStoreContext&gt;(opt =&gt; opt.UseInMemoryDatabase(&quot;BookLists&quot;));\n        services.AddControllers();\n        services.AddOData(opt =&gt; opt.AddModel(&quot;odata&quot;, GetEdmModel()));\n    &#125;\n\n    public void Configure(IApplicationBuilder app, IWebHostEnvironment env)\n    &#123;\n        app.UseRouting();\n        app.UseEndpoints(endpoints =&gt;\n        &#123;\n            endpoints.MapControllers();\n        &#125;);\n    &#125;\n\n    private static IEdmModel GetEdmModel()\n    &#123;\n        // …\n    &#125;\n&#125;\n\n查询元数据OData服务已经准备就绪，可以运行，并且提供基本的功能，例如查询元数据(EDM的XML表示)，构建并允许项目，我们任何客户端工具发出请求：\nGET http://localhost:5000/odata/$metadata\n然后，可以获取如下xml所示的元数据\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;\n&lt;edmx:Edmx Version=&quot;4.0&quot; xmlns:edmx=&quot;http://docs.oasis-open.org/odata/ns/edmx&quot;&gt;\n    &lt;edmx:DataServices&gt;\n        &lt;Schema Namespace=&quot;BookStore.Models&quot; xmlns=&quot;http://docs.oasis-open.org/odata/ns/edm&quot;&gt;\n            &lt;EntityType Name=&quot;Book&quot;&gt;\n                &lt;Key&gt;\n                    &lt;PropertyRef Name=&quot;Id&quot; /&gt;\n                &lt;/Key&gt;\n                &lt;Property Name=&quot;Id&quot; Type=&quot;Edm.Int32&quot; Nullable=&quot;false&quot; /&gt;\n                &lt;Property Name=&quot;ISBN&quot; Type=&quot;Edm.String&quot; /&gt;\n                &lt;Property Name=&quot;Title&quot; Type=&quot;Edm.String&quot; /&gt;\n                &lt;Property Name=&quot;Author&quot; Type=&quot;Edm.String&quot; /&gt;\n                &lt;Property Name=&quot;Price&quot; Type=&quot;Edm.Decimal&quot; Nullable=&quot;false&quot; /&gt;\n                &lt;Property Name=&quot;Location&quot; Type=&quot;BookStore.Models.Address&quot; /&gt;\n                &lt;NavigationProperty Name=&quot;Press&quot; Type=&quot;BookStore.Models.Press&quot; /&gt;\n            &lt;/EntityType&gt;\n            &lt;EntityType Name=&quot;Press&quot;&gt;\n                &lt;Key&gt;\n                    &lt;PropertyRef Name=&quot;Id&quot; /&gt;\n                &lt;/Key&gt;\n                &lt;Property Name=&quot;Id&quot; Type=&quot;Edm.Int32&quot; Nullable=&quot;false&quot; /&gt;\n                &lt;Property Name=&quot;Name&quot; Type=&quot;Edm.String&quot; /&gt;\n                &lt;Property Name=&quot;Email&quot; Type=&quot;Edm.String&quot; /&gt;\n                &lt;Property Name=&quot;Category&quot; Type=&quot;BookStore.Models.Category&quot; Nullable=&quot;false&quot; /&gt;\n            &lt;/EntityType&gt;\n            &lt;ComplexType Name=&quot;Address&quot;&gt;\n                &lt;Property Name=&quot;City&quot; Type=&quot;Edm.String&quot; /&gt;\n                &lt;Property Name=&quot;Street&quot; Type=&quot;Edm.String&quot; /&gt;\n            &lt;/ComplexType&gt;\n            &lt;EnumType Name=&quot;Category&quot;&gt;\n                &lt;Member Name=&quot;Book&quot; Value=&quot;0&quot; /&gt;\n                &lt;Member Name=&quot;Magazine&quot; Value=&quot;1&quot; /&gt;\n                &lt;Member Name=&quot;EBook&quot; Value=&quot;2&quot; /&gt;\n            &lt;/EnumType&gt;\n        &lt;/Schema&gt;\n        &lt;Schema Namespace=&quot;Default&quot; xmlns=&quot;http://docs.oasis-open.org/odata/ns/edm&quot;&gt;\n            &lt;EntityContainer Name=&quot;Container&quot;&gt;\n                &lt;EntitySet Name=&quot;Books&quot; EntityType=&quot;BookStore.Models.Book&quot;&gt;\n                    &lt;NavigationPropertyBinding Path=&quot;Press&quot; Target=&quot;Presses&quot; /&gt;\n                &lt;/EntitySet&gt;\n                &lt;EntitySet Name=&quot;Presses&quot; EntityType=&quot;BookStore.Models.Press&quot; /&gt;\n            &lt;/EntityContainer&gt;\n        &lt;/Schema&gt;\n    &lt;/edmx:DataServices&gt;\n&lt;/edmx:Edmx&gt;\n\n创建数据库上下文现在，可以添加更多实际的功能，首先将数据库上下文引入Web程序，在Models文件夹中创建BookStoreContext类\n    public class BookStoreContext : DbContext\n    &#123;\n        public BookStoreContext(DbContextOptions&lt;BookStoreContext&gt; options)\n          : base(options)\n        &#123;\n        &#125;\n\n        public DbSet&lt;Book&gt; Books &#123; get; set; &#125;\n        public DbSet&lt;Press&gt; Presses &#123; get; set; &#125;\n\n        protected override void OnModelCreating(ModelBuilder modelBuilder)\n        &#123;\n            modelBuilder.Entity&lt;Book&gt;().OwnsOne(c =&gt; c.Location);\n        &#125;\n    &#125;\n\nOnModelCreating中的代码将Address映射为复杂类型\n注册数据库上下文通过依赖注入在服务中注册数据库上下文，求改Startup类中的ConfigureServices方法\n    public class Startup\n    &#123;\n          // ...\n\n          public void ConfigureServices(IServiceCollection services)\n          &#123;\n                services.AddDbContext&lt;BookStoreContext&gt;(opt =&gt; opt.UseInMemoryDatabase(&quot;BookLists&quot;));\n                services.AddOData();\n                services.AddControllers();\n                services.AddSwaggerGen(c =&gt;\n                &#123;\n                    c.SwaggerDoc(&quot;v1&quot;, new OpenApiInfo &#123; Title = &quot;WebApplication1&quot;, Version = &quot;v1&quot; &#125;);\n                &#125;);\n          &#125;\n    &#125;\n\n模型数据为了简单起见，我们简单生成一些内容\n    public static class DataSource\n    &#123;\n        private static IList&lt;Book&gt; _books &#123; get; set; &#125;\n\n        public static IList&lt;Book&gt; GetBooks()\n        &#123;\n            if (_books != null)\n            &#123;\n                return _books;\n            &#125;\n\n            _books = new List&lt;Book&gt;();\n\n            // book #1\n            Book book = new Book\n            &#123;\n                Id = 1,\n                ISBN = &quot;978-0-321-87758-1&quot;,\n                Title = &quot;Essential C#5.0&quot;,\n                Author = &quot;Mark Michaelis&quot;,\n                Price = 59.99m,\n                Location = new Address &#123; City = &quot;Redmond&quot;, Street = &quot;156TH AVE NE&quot; &#125;,\n                Press = new Press\n                &#123;\n                    Id = 1,\n                    Name = &quot;Addison-Wesley&quot;,\n                    Category = Category.Book\n                &#125;\n            &#125;;\n            _books.Add(book);\n\n            // book #2\n            book = new Book\n            &#123;\n                Id = 2,\n                ISBN = &quot;063-6-920-02371-5&quot;,\n                Title = &quot;Enterprise Games&quot;,\n                Author = &quot;Michael Hugos&quot;,\n                Price = 49.99m,\n                Location = new Address &#123; City = &quot;Bellevue&quot;, Street = &quot;Main ST&quot; &#125;,\n                Press = new Press\n                &#123;\n                    Id = 2,\n                    Name = &quot;O&#39;Reilly&quot;,\n                    Category = Category.EBook,\n                &#125;\n            &#125;;\n            _books.Add(book);\n\n            return _books;\n        &#125;\n    &#125;\n\n操作资源构建Controller创建一个Controller命名为BooksController\n    [ApiController]\n    [Route(&quot;[controller]&quot;)]\n    public class BooksController : ODataController\n    &#123;\n        private BookStoreContext _db;\n\n        public BooksController(BookStoreContext context)\n        &#123;\n            _db = context;\n            if (context.Books.Count() == 0)\n            &#123;\n                foreach (var b in DataSource.GetBooks())\n                &#123;\n                    context.Books.Add(b);\n                    context.Presses.Add(b.Press);\n                &#125;\n                context.SaveChanges();\n            &#125;\n        &#125;\n\n        [EnableQuery]\n        public IActionResult Get()\n        &#123;\n            return Ok(_db.Books);\n        &#125;\n\n        [EnableQuery]\n        public IActionResult Get([FromODataUri] int key)\n        &#123;\n            return Ok(_db.Books.FirstOrDefault(c =&gt; c.Id == key));\n        &#125;\n    &#125;\n\n在上面定义的两个Action中：\n\nGet()返回所有内容\nGet(int Key)返回指定ID内容\n\n检索资源我们访问：GET http://localhost:5000/odata/Books 响应结果为：\n&#123;\n    &quot;@odata.context&quot;: &quot;http://localhost:5000/odata/$metadata#Books&quot;,\n    &quot;value&quot;: [\n        &#123;\n            &quot;Id&quot;: 1,\n            &quot;ISBN&quot;: &quot;978-0-321-87758-1&quot;,\n            &quot;Title&quot;: &quot;Essential C#5.0&quot;,\n            &quot;Author&quot;: &quot;Mark Michaelis&quot;,\n            &quot;Price&quot;: 59.99,\n            &quot;Location&quot;: &#123;\n                &quot;City&quot;: &quot;Redmond&quot;,\n                &quot;Street&quot;: &quot;156TH AVE NE&quot;\n            &#125;\n        &#125;,\n        &#123;\n            &quot;Id&quot;: 2,\n            &quot;ISBN&quot;: &quot;063-6-920-02371-5&quot;,\n            &quot;Title&quot;: &quot;Enterprise Games&quot;,\n            &quot;Author&quot;: &quot;Michael Hugos&quot;,\n            &quot;Price&quot;: 49.99,\n            &quot;Location&quot;: &#123;\n                &quot;City&quot;: &quot;Bellevue&quot;,\n                &quot;Street&quot;: &quot;Main ST&quot;\n            &#125;\n        &#125;\n    ]\n&#125;\n\n尝试发出：GET http://localhost:5000/odata/Books(2) 获取ID为2的书籍\n创建资源添加下列代码到Controller中\n[EnableQuery]\npublic IActionResult Post([FromBody] Book book)\n&#123;\n    _db.Books.Add(book);\n    _db.SaveChanges();\n    return Created(book);\n&#125;\n\n发出如下请求创建Book数据\n*POST* http://localhost:5000/odata/Books\nContent-Type: application/json\nContent:\n&#123;\n  &quot;Id&quot;:3,&quot;ISBN&quot;:&quot;82-917-7192-5&quot;,&quot;Title&quot;:&quot;Hary Potter&quot;,&quot;Author&quot;:&quot;J. K. Rowling&quot;,\n  &quot;Price&quot;:199.99,\n  &quot;Location&quot;:&#123;\n     &quot;City&quot;:&quot;Shanghai&quot;,\n     &quot;Street&quot;:&quot;Zhongshan RD&quot;\n   &#125;\n&#125;\n\n查询资源需要在Startup.cs中添加如下代码启用所有OData查询选项，例如$filter，$orderby，$expand等。\n    public class Startup\n    &#123;\n      // ...\n  \n        public void Configure(IApplicationBuilder app, IWebHostEnvironment env)\n        &#123;\n            if (env.IsDevelopment())\n            &#123;\n                app.UseDeveloperExceptionPage();\n                app.UseSwagger();\n                app.UseSwaggerUI(c =&gt; c.SwaggerEndpoint(&quot;/swagger/v1/swagger.json&quot;, &quot;WebApplication1 v1&quot;));\n            &#125;\n            \n            //...\n\n            app.UseEndpoints(endpoints =&gt;\n            &#123;\n                endpoints.Select().Expand().Filter().OrderBy().MaxTop(100).Count();\n                endpoints.MapODataRoute(&quot;odata&quot;, &quot;odata&quot;, GetEdmModel());\n            &#125;);\n        &#125;\n    &#125;\n\n基于$filter的示例:\nGET http://localhost:5000/odata/Books?$filter=Price le 50\n响应内容为:\n&#123;\n    &quot;@odata.context&quot;: &quot;https://localhost:5001/odata/$metadata#Books&quot;,\n    &quot;value&quot;: [\n        &#123;\n            &quot;Id&quot;: 2,\n            &quot;ISBN&quot;: &quot;063-6-920-02371-5&quot;,\n            &quot;Title&quot;: &quot;Enterprise Games&quot;,\n            &quot;Author&quot;: &quot;Michael Hugos&quot;,\n            &quot;Price&quot;: 49.99,\n            &quot;Location&quot;: &#123;\n                &quot;City&quot;: &quot;Bellevue&quot;,\n                &quot;Street&quot;: &quot;Main ST&quot;\n            &#125;\n        &#125;\n    ]\n&#125;\n\n它还支持更为复杂的查询选项，例如：\nGET http://localhost:5000/odata/Books?$filter=Price le 50&amp;$expand=Press($select=Name)&amp;$select=ISBN\n响应结果为:\n&#123;\n    &quot;@odata.context&quot;: &quot;http://localhost:5000/odata/$metadata#Books(ISBN,Press(Name))&quot;,\n    &quot;value&quot;: [\n        &#123;\n            &quot;ISBN&quot;: &quot;063-6-920-02371-5&quot;,\n            &quot;Press&quot;: &#123;\n                &quot;Name&quot;: &quot;O&#39;Reilly&quot;\n            &#125;\n        &#125;\n    ]\n&#125;\n\n更多的查询方式可以在官方网站查看，这些都是基于OData协议进行的\n如果在Swagger中显示OData路由使用NuGet安装OData.Swagger程序包\n打开Startup.cs文件，在ConfigureService方法中添加如下服务\nservices.AddOdataSwaggerSupport();\n\n重新启动程序即可\n如果你的控制器是继承自ODataController，则需要添加[ApiExplorerSettings(IgnoreApi = false)]\n    [ApiController]\n    [ApiExplorerSettings(IgnoreApi = false)]\n    [Route(&quot;[controller]&quot;)]\n    public class BooksController : ODataController\n    &#123;\n        //...\n    &#125;\n\n本文参考：\nOData参考：https://devblogs.microsoft.com/odata/asp-net-core-odata-now-available/\nOData参考：https://devblogs.microsoft.com/odata/asp-net-odata-8-0-preview-for-net-5/\n在Swagger中显示OData参考：https://github.com/KishorNaik/Sol_OData_Swagger_Support\nOData官网：https://www.odata.org/\n","categories":["DotNetCore"],"tags":["OData"]},{"title":"IDEA用Maven创建SpringMVC项目","url":"/2021/04/01/IDEA%E7%94%A8Maven%E5%88%9B%E5%BB%BASpringMVC%E9%A1%B9%E7%9B%AE/","content":"什么是SpringMVC什么是MVC\nMVC是模型，视图，控制器的简写，是一种软件设计规范\n将业务逻辑，数据，显示 分离的方法来组织代码\nMVC主要作用是降低了视图与业务逻辑间的双向耦合\nMVC不是一种设计模式，是一种架构模式，当然不同的MVC存在差异\n\nModel数据模型，提供要显示的数据，因此包含数据和行为，可以认为是领域模型或JavaBean组件（包含数据和行为），不过现在一般都分离开来：Value Object（数据Dao） 和 服务层（行为Service）。也就是模型提供了模型数据查询和模型数据的状态更新等功能，包括数据和业务。\nView负责进行模型的展示，一般就是我们见到的用户界面，客户想看到的东西。\nController接收用户请求，委托给模型进行处理，处理完后返回的模型数据返回给视图，由视图进行展示，也就是说控制器做了调度员的工作。\n最典型的MVC就是JSP + servlet + javabean的模式。\n\nModel-1时代\n在web开发早期，通常采用Model-1\nModel-1中，主要分为两层，视图层和模型层\n\n\nModel-1优点：架构简单，比较适合小型项目开发\nModel-1缺点：JSP职责不单一，职责过重，不便维护\nModel-2时代Model-2把一个项目分成三部分，视图，控制，模型\n\n\n用户发请求\nServlet接收请求数据，并调用对应的业务逻辑方法\n业务处理完毕，返回更新后的数据给servlet\nservlet转向到JSP，由JSP来渲染页面\n响应给前端更新后的页面\n\n职责分析：\nController：控制器\n\n取得表单数据\n调用业务逻辑\n转向指定的页面\n\nModel：模型\n\n业务逻辑\n保存数据的状态\n\nView：视图\n\n显示页面\n\n\nModel2这样不仅提高的代码的复用率与项目的扩展性，且大大降低了项目的维护成本。Model 1模式的实现比较简单，适用于快速开发小规模项目，Model1中JSP页面身兼View和Controller两种角色，将控制逻辑和表现逻辑混杂在一起，从而导致代码的重用性非常低，增加了应用的扩展性和维护的难度。Model2消除了Model1的缺点。\n说完这些，回到正题，SpringMVC是Spring Framework的一部分，是基于Java实现MVC的轻量级Web框架。\n查看官方文档：https://docs.spring.io/spring/docs/5.2.0.RELEASE/spring-framework-reference/web.html#spring-web\nSpring的web框架围绕DispatcherServlet [ 调度Servlet ] 设计。\nDispatcherServlet的作用是将请求分发到不同的处理器。从Spring 2.5开始，使用Java 5或者以上版本的用户可以采用基于注解形式进行开发，十分简洁；\n正因为SpringMVC好 , 简单 , 便捷 , 易学 , 天生和Spring无缝集成(使用SpringIoC和Aop) , 使用约定优于配置 . 能够进行简单的junit测试 . 支持Restful风格 .异常处理 , 本地化 , 国际化 , 数据验证 , 类型转换 , 拦截器 等等……所以我们要学习 .\nSpringMVC执行原理\n简要分析执行流程\n\nDispatcherServlet表示前置控制器，是整个SpringMVC的控制中心。用户发出请求，DispatcherServlet接收请求并拦截请求。\n我们假设请求的url为 : http://localhost:8080/SpringMVC/hello\n如上url拆分成三部分：\nhttp://localhost:8080服务器域名\nSpringMVC部署在服务器上的web站点\nhello表示控制器\n通过分析，如上url表示为：请求位于服务器localhost:8080上的SpringMVC站点的hello控制器。\n\nHandlerMapping为处理器映射。DispatcherServlet调用HandlerMapping,HandlerMapping根据请求url查找Handler。\n\nHandlerExecution表示具体的Handler,其主要作用是根据url查找控制器，如上url被查找控制器为：hello。\n\nHandlerExecution将解析后的信息传递给DispatcherServlet,如解析控制器映射等。\n\nHandlerAdapter表示处理器适配器，其按照特定的规则去执行Handler。\n\nHandler让具体的Controller执行。\n\nController将具体的执行信息返回给HandlerAdapter,如ModelAndView。\n\nHandlerAdapter将视图逻辑名或模型传递给DispatcherServlet。\n\nDispatcherServlet调用视图解析器(ViewResolver)来解析HandlerAdapter传递的逻辑视图名。\n\n视图解析器将解析的逻辑视图名传给DispatcherServlet。\n\nDispatcherServlet根据视图解析器解析的视图结果，调用具体的视图。\n\n最终视图呈现给用户。\n\n\n创建一个非注解SpringMVC项目\n\n创建完毕后，右键项目-》Add Framework Suppot勾选WebWebApplication\n\n项目创建完毕，下面配置一些依赖：\nweb.xml配置：\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;\n&lt;web-app xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot;\n         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;\n         xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot;\n         version=&quot;4.0&quot;&gt;\n    &lt;!--配置DispatcherServlet：这是SpringMVC的核心：请求分发器，前端控制器--&gt;\n    &lt;servlet&gt;\n        &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt;\n        &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;\n        &lt;!--        配置DispatcherServlet要绑定Spring配置文件--&gt;\n        &lt;init-param&gt;\n            &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;\n            &lt;param-value&gt;classpath:springmvc-servlet.xml&lt;/param-value&gt;\n        &lt;/init-param&gt;\n        &lt;!--启动级别--&gt;\n        &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;\n    &lt;/servlet&gt;\n\n    &lt;!--    springMVC中：--&gt;\n    &lt;!--    / :只匹配所有的请求，不会去匹配jsp页面--&gt;\n    &lt;!--    /* :匹配所有请求，包括jsp页面--&gt;\n    &lt;servlet-mapping&gt;\n        &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt;\n        &lt;url-pattern&gt;/&lt;/url-pattern&gt;\n    &lt;/servlet-mapping&gt;\n\n&lt;/web-app&gt;\n\n在resources文件夹中创建一个springmvc-servlet.xml文件\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;\n&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;\n       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;\n       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;\n       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans\n       http://www.springframework.org/schema/beans/spring-beans.xsd\n       http://www.springframework.org/schema/context\n       http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;\n\n    &lt;!--    处理器映射器--&gt;\n    &lt;bean class=&quot;org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping&quot;/&gt;\n    &lt;!--    处理器适配器--&gt;\n    &lt;bean class=&quot;org.springframework.web.servlet.mvc.SimpleControllerHandlerAdapter&quot;/&gt;\n    &lt;!--    视图解析器--&gt;\n    &lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot; id=&quot;internalResourceViewResolver&quot;&gt;\n        &lt;!--        前缀--&gt;\n        &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/jsp/&quot;/&gt;\n        &lt;!--        后缀--&gt;\n        &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot;/&gt;\n    &lt;/bean&gt;\n\n    &lt;bean id=&quot;/hello&quot; class=&quot;com.kuang.controller.HelloController&quot;/&gt;\n\n&lt;/beans&gt;\n\n注意点：\n\n配置DispatcherServlet\n\n关联SpringMVC配置文件\n\n启动级别为1\n\n映射路径为/【不要用/*】\n\n\n创建一个控制器com.kuang.controller.HelloController\npackage com.kuang.controller;\n\nimport org.springframework.web.servlet.ModelAndView;\nimport org.springframework.web.servlet.mvc.Controller;\n\npublic class HelloController implements Controller &#123;\n    @Override\n    public ModelAndView handleRequest(javax.servlet.http.HttpServletRequest httpServletRequest, javax.servlet.http.HttpServletResponse httpServletResponse) throws Exception &#123;\n        ModelAndView mv = new ModelAndView();\n\n        String res = &quot;Hello&quot;;\n\n        mv.addObject(&quot;msg&quot;, res);\n        mv.setViewName(&quot;test&quot;);//返回test.jsp\n\n        return mv;\n    &#125;\n&#125;\n\n到此，我们的项目就创建完毕了\n如果发现无法允许404错误，请确保lib依赖是否导入：\n点击file-》project Settings-》Artifacts\n\n\n右键WEB-INF添加lib文件夹，右键lib-》add copy of-》library Files将所有依赖添加\n注解开发用注解开发我们只需要更改springmvc-servlet.xml文件\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;\n&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;\n       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;\n       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;\n       xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot;\n       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans\n       http://www.springframework.org/schema/beans/spring-beans.xsd\n       http://www.springframework.org/schema/context\n       http://www.springframework.org/schema/context/spring-context.xsd\n       http://www.springframework.org/schema/mvc\n       http://www.springframework.org/schema/mvc/spring-mvc.xsd&quot;&gt;\n\n    &lt;!--    自动扫描包 让指定包下的注解生效 由IOC容器统一管理--&gt;\n    &lt;context:component-scan base-package=&quot;com.kuang.controller&quot;/&gt;\n    &lt;!--    让SpringMVC不处理静态资源文件--&gt;\n    &lt;mvc:default-servlet-handler/&gt;\n    &lt;!--    支持mvc注解驱动--&gt;\n    &lt;!--    在spring中一般采用@RequestMapping注解完成映射关系--&gt;\n    &lt;!--    要想使@RequestMapping注解生效--&gt;\n    &lt;!--    必须向上下文中注册DefaultAnnotationHandlerMapping--&gt;\n    &lt;!--    和一个AnnotationMethodHandlerAdapter实例--&gt;\n    &lt;!--    而annotation-driven配置帮我们自动完成了上述两个实例的注入--&gt;\n    &lt;mvc:annotation-driven/&gt;\n\n\n    &lt;!--    视图解析器--&gt;\n    &lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot; id=&quot;internalResourceViewResolver&quot;&gt;\n        &lt;!--        前缀--&gt;\n        &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/jsp/&quot;/&gt;\n        &lt;!--        后缀--&gt;\n        &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot;/&gt;\n    &lt;/bean&gt;\n\n&lt;/beans&gt;\n\n@Controller\n@RequestMapping(&quot;hello&quot;)\npublic class HelloController &#123;\n\n    @RequestMapping(&quot;/h1&quot;)\n    public String hello(Model model)&#123;\n        model.addAttribute(&quot;msg&quot;, &quot;hello&quot;);\n        return &quot;test&quot;;\n    &#125;\n\n&#125;\n\n使用springMVC必须配置三大件：\n处理器映射器、处理器适配器、视图解析器\n通常，我们只需要手动配置视图解析器，而处理器映射器和处理器适配器只需要开启注解驱动即可\n参考文章01：https://blog.csdn.net/weixin_44635198/article/details/107444925\n","categories":["Java"],"tags":["SpringMVC","Maven","IDEA"]},{"title":"Spring","url":"/2021/03/28/Spring/","content":"1、Spring1.2、优点\nSpring 是一个开源的免费框架（容器）\nSpring 是一个轻量级的、非入侵式的框架！\n控制反转（IOC），面向切面编程（AOP）\n支持事务的处理，对框架整合的支持\n\n总结一句话：Spring 是一个轻量级的控制反转和面向切面编程的框架\n1.3、组成\n1.4、拓展\nSpringBoot\n一个快速开发的脚手架\n基于 SpringBoot 可以快速的开发单个微服务\n约定大于配置！\n\n\nSpring Cloud\nSpringCloud 是基于 SpringBoot 实现的\n\n\n\n现在大多数公司都在使用 SpringBoot 进行快速开发，学习 SpringBoot 的前提，需要完全掌握 Spring 及 SpringMVC！承上启下\n2、IOC 理论推导\nUserDao 接口\nUserDaoImpl 实现类\nUserService 业务接口\nUserServiceImpl 业务实现类\n\n在我们之前的业务中，用户的需求可能会影响我们原来的代码，我们需要根据用户的需求去修改原代码！如果程序代码量十分大，修改一次的成本代价十分昂贵！\n我们使用一个 Set 接口实现:\nprivate UserDao userDao; //利用set进行动态实现值的注入！\n\npublic void setUserDao(UserDao userDao)\n&#123;\n    this.userDao=userDao;\n&#125;\n\n\n之前，程序是主动创建对象！控制权在程序员手上\n使用 set 之后，程序不在具有主动性，而是被动的接受对象（对扩展开发，对修改关闭）\n\n从本质上解决问题，不需要管理对象的创建，耦合性降低，专注于业务实现，这就是 IOC 的原型。\nIOC 本质IOC 控制反转是一种设计思想，DI(依赖注入) 是实现 IOC 的一种方法。没有 IOC 的程序中，我们使用面向对象编程，对象的创建与对象间的依赖关系完全硬编码在程序中，对象的创建由程序自己控制。控制反转之后将对象的创建转移给第三方，个人理解控制反转就是：获得依赖对象的方式发生转变了。\nIOC 是 Spring 框架的核心内容，使用多种方式完美的实现的 Ioc，可以使用 xml 配置，也可以使用注解，新版本的 Spring 也可以零配置实现 IOC（自动装配）。\n采用 xml 方式配置 Bean 的时候，Bean 的定义信息和实现是分离的，采用注解的方式可以把两者合为一体。Bean 的定义信息直接以注解的形式在定义在实现类中，从而达到零配置的目的。\n控制反转是一种通过描述 xml 或者注解，并通过第三方去生产或获取特定对象的方式。在 Spring 中实现控制反转的是 IOC 容器，其实现方式是依赖注入。\n3、HelloSpringpublic class Hello &#123;\n    private String str;\n\n    @Override\n    public String toString() &#123;\n        return &quot;Hello&#123;&quot; +\n                &quot;str=&#39;&quot; + str + &#39;\\&#39;&#39; +\n                &#39;&#125;&#39;;\n    &#125;\n\n    public String getStr() &#123;\n        return str;\n    &#125;\n\n    public void setStr(String str) &#123;\n        this.str = str;\n    &#125;\n&#125;\n\nhttps://docs.spring.io/spring-framework/docs/current/reference/html/core.html#spring-core\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;\n&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;\n       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;\n       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans\n        https://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;\n\n    &lt;bean id=&quot;hello&quot; class=&quot;com.kuang.pojo.Hello&quot;&gt;\n        &lt;property name=&quot;str&quot; value=&quot;Hello Spring&quot;/&gt;\n        &lt;!--\n            ref：引用Spring容器中创建好的对象\n            value：引用具体的值，基本数据类型\n        --&gt;\n    &lt;/bean&gt;\n&lt;/beans&gt;\n\npublic class MyTest &#123;\n    public static void main(String[] args) &#123;\n        //获取ApplicationContext：拿取Spring的容器\n        ApplicationContext context = new ClassPathXmlApplicationContext(&quot;beans.xml&quot;);\n\n        //需要什么，就get什么\n        Hello hello = (Hello) context.getBean(&quot;hello&quot;);\n\n        System.out.println(hello.toString());\n    &#125;\n&#125;\n\n\nHello 对象是谁创建的？\nhello 对象是由 Spring 创建的\n\n\nHello 对象的属性是怎么设置的\nhello 对象的属性是由 Spring 容器设置的\n\n\n\n上面就用配置文件的形式，实现了控制反转\n控制：谁来控制对象的创建，传统应用程序的对象是有程序本身来控制创建的，使用 Spring 后，对象是由 Spring 来创建\n反转：程序本身不创建对象，而变成被动的接收对象\n依赖注入：利用 set 的方法来进行注入\nIOC 是一种变成思想，由主动的编程变成被动的编程\n所谓 IOC 就是：对象由 Spring 来创建，管理，装配！\n4、IOC 创建对象的方式&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;\n&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;\n       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;\n       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans\n        https://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;\n\n    &lt;!--默认无参构造，有参会报错--&gt;\n    &lt;bean id=&quot;user&quot; class=&quot;com.kuang.pojo.User&quot;&gt;\n        &lt;property name=&quot;name&quot; value=&quot;saber01&quot;/&gt;\n    &lt;/bean&gt;\n\n    &lt;!--第一种：构造函数参数名赋值--&gt;\n    &lt;bean id=&quot;user&quot; class=&quot;com.kuang.pojo.User&quot;&gt;\n        &lt;constructor-arg name=&quot;name&quot; value=&quot;saber02&quot;/&gt;\n    &lt;/bean&gt;\n\n    &lt;!--第二种：构造函数参数索引赋值--&gt;\n    &lt;bean id=&quot;user&quot; class=&quot;com.kuang.pojo.User&quot;&gt;\n        &lt;constructor-arg index=&quot;0&quot; value=&quot;saber02&quot;/&gt;\n    &lt;/bean&gt;\n\n    &lt;!--第三种：构造函数参数类型匹配赋值--&gt;\n    &lt;bean id=&quot;user&quot; class=&quot;com.kuang.pojo.User&quot;&gt;\n        &lt;constructor-arg type=&quot;java.lang.String&quot; value=&quot;saber02&quot;/&gt;\n    &lt;/bean&gt;\n&lt;/beans&gt;\n\n总结：在配置文件加载时，容器中管理的对象就已经被初始化了，且是单例的\n5、Spring 配置5.1、别名&lt;alias name=&quot;user&quot; alias=&quot;userNew&quot;/&gt;\n\nUser user = (User) context.getBean(&quot;userNew&quot;);\n\n添加了别名(alias)，可以用别名获取对象\n5.2、Bean 的配置&lt;!--\n    id：bean的唯一标识，相当于对象名\n    class：bean对象所对应的全限定名：包名+类型\n    name：也是别名，而且name可以同时取多个，可以用各种符号分开\n--&gt;\n&lt;bean id=&quot;hello&quot; class=&quot;com.kuang.pojo.Hello&quot; name=&quot;user2 u2;u3,u4&quot;&gt;\n    &lt;property name=&quot;str&quot; value=&quot;Hello Spring&quot;/&gt;\n&lt;/bean&gt;\n\n5.3、import一般用于团队开发，可以将多个配置文件合并成一个:applicationContext.xml\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;\n&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;\n       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;\n       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;\n\n    &lt;import resource=&quot;beans.xml&quot;/&gt;\n    &lt;import resource=&quot;beans02.xml&quot;/&gt;\n\n&lt;/beans&gt;\n\n更多的信息可以前往\n进行查看\n6、依赖注入6.1、构造器方式注入上面的就是\n6.2、Set 方式注入【重点】\n依赖注入：Set 注入\n依赖：bean 对象的创建依赖于容器\n注入：bean 对象中的所有属性，由容器来注入\n\n\n\n【环境搭建】\n\n复杂类型\npublic class Address &#123;\n    private String address;\n\n    public String getAddress() &#123;\n        return address;\n    &#125;\n\n    public void setAddress(String address) &#123;\n        this.address = address;\n    &#125;\n&#125;\n\n\n真实测试对象\n//get set略\npublic class Student &#123;\n    private String name;\n    private Address address;\n    private String[] books;\n    private List&lt;String&gt; hobbys;\n    private Map&lt;String,String&gt; card;\n    private Set&lt;String&gt; games;\n    private String wife;\n    private Properties info;\n&#125;\n\n\nbeans.xml\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;\n&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;\n       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;\n       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;\n\n    &lt;bean id=&quot;student&quot; class=&quot;com.kuang.pojo.Student&quot;&gt;\n        &lt;property name=&quot;name&quot; value=&quot;saber&quot;/&gt;\n    &lt;/bean&gt;\n\n&lt;/beans&gt;\n\n\n测试类\npublic class MyTest &#123;\n    public static void main(String[] args) &#123;\n        ApplicationContext context = new ClassPathXmlApplicationContext(&quot;beans.xml&quot;);\n\n        Student student = (Student) context.getBean(&quot;student&quot;);\n\n        System.out.println(student.toString());\n    &#125;\n&#125;\n\n\n\n完善注入信息\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;\n&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;\n       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;\n       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;\n\n    &lt;bean id=&quot;address&quot; class=&quot;com.kuang.pojo.Address&quot;&gt;\n        &lt;property name=&quot;address&quot; value=&quot;000000000000000&quot;/&gt;\n    &lt;/bean&gt;\n\n    &lt;bean id=&quot;student&quot; class=&quot;com.kuang.pojo.Student&quot;&gt;\n\n        &lt;property name=&quot;name&quot; value=&quot;saber&quot;/&gt;\n        &lt;property name=&quot;address&quot; ref=&quot;address&quot;/&gt;\n\n        &lt;!--数组--&gt;\n        &lt;property name=&quot;books&quot;&gt;\n            &lt;array&gt;\n                &lt;value&gt;a1&lt;/value&gt;\n                &lt;value&gt;a2&lt;/value&gt;\n                &lt;value&gt;a3&lt;/value&gt;\n                &lt;value&gt;a4&lt;/value&gt;\n            &lt;/array&gt;\n        &lt;/property&gt;\n\n        &lt;!--list--&gt;\n        &lt;property name=&quot;hobbys&quot;&gt;\n            &lt;list&gt;\n                &lt;value&gt;l1&lt;/value&gt;\n                &lt;value&gt;l2&lt;/value&gt;\n                &lt;value&gt;l3&lt;/value&gt;\n                &lt;value&gt;l4&lt;/value&gt;\n            &lt;/list&gt;\n        &lt;/property&gt;\n\n        &lt;!--Map--&gt;\n        &lt;property name=&quot;card&quot;&gt;\n            &lt;map&gt;\n                &lt;entry key=&quot;a&quot; value=&quot;a1&quot;/&gt;\n                &lt;entry key=&quot;b&quot; value=&quot;b2&quot;/&gt;\n                &lt;entry key=&quot;c&quot; value=&quot;c3&quot;/&gt;\n            &lt;/map&gt;\n        &lt;/property&gt;\n\n        &lt;!--Set--&gt;\n        &lt;property name=&quot;games&quot;&gt;\n            &lt;set&gt;\n                &lt;value&gt;s1&lt;/value&gt;\n                &lt;value&gt;s2&lt;/value&gt;\n                &lt;value&gt;s3&lt;/value&gt;\n            &lt;/set&gt;\n        &lt;/property&gt;\n\n        &lt;!--null--&gt;\n        &lt;property name=&quot;wife&quot;&gt;\n            &lt;null&gt;&lt;/null&gt;\n        &lt;/property&gt;\n\n        &lt;!--Properties--&gt;\n        &lt;property name=&quot;info&quot;&gt;\n            &lt;props&gt;\n                &lt;prop key=&quot;Email_1&quot;&gt;1347216032@qq.com&lt;/prop&gt;\n                &lt;prop key=&quot;Email_2&quot;&gt;3081453914@qq.com&lt;/prop&gt;\n            &lt;/props&gt;\n        &lt;/property&gt;\n    &lt;/bean&gt;\n&lt;/beans&gt;\n\n6.3、拓展方式注入C 与 P 命名空间&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;\n&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;\n       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;\n       xmlns:p=&quot;http://www.springframework.org/schema/p&quot;\n       xmlns:c=&quot;http://www.springframework.org/schema/c&quot;\n       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;\n\n    &lt;!--p命名空间注入，可以直接注入属性的值：property--&gt;\n    &lt;bean id=&quot;user&quot; class=&quot;com.kuang.pojo.User&quot; p:name=&quot;saber-u&quot; p:age=&quot;18&quot;&gt;&lt;/bean&gt;\n\n    &lt;!--c命名空间注入，通过构造器注入属性的值：construct-args--&gt;\n    &lt;bean id=&quot;user2&quot; class=&quot;com.kuang.pojo.User&quot; c:name=&quot;saber-u-2&quot; c:age=&quot;20&quot;/&gt;\n\n&lt;/beans&gt;\n\n测试\n@Test\npublic void test2()&#123;\n    ApplicationContext context = new ClassPathXmlApplicationContext(&quot;userbeans.xml&quot;);\n    User user = context.getBean(&quot;user2&quot;, User.class);\n\n    System.out.println(user.toString());\n&#125;\n\n注意：p/c 命名空间不能直接使用，要引入 xml 约束\nxmlns:p=&quot;http://www.springframework.org/schema/p&quot;\nxmlns:c=&quot;http://www.springframew\n\n6.4、bean 的作用域\n\n单例模式（spring 的默认模式）\n&lt;!-- the following is equivalent, though redundant (singleton scope is the default) --&gt;\n&lt;bean id=&quot;accountService&quot; class=&quot;com.something.DefaultAccountService&quot; scope=&quot;singleton&quot;/&gt;\n\n\n\n原型模式：每次从容器 get 的时候，都会产生一个新的对象\n&lt;bean id=&quot;accountService&quot; class=&quot;com.something.DefaultAccountService&quot; scope=&quot;prototype&quot;/&gt;\n\n\n\n其余的request，session，applicatoin这些只能在 web 开发中使用！\n\n\n7、Bean 的自动装配\n自动装配是 Spring 满足 bean 依赖的一种方式\nSpring 会在上下文中自动寻找，并自动给 bean 装配属性\n\n在 Spring 中有三种装配方式\n\n在 xml 中显示的配置\n在 java 中显示配置\n隐式的自动装配 bean\n\n7.1、ByName 自动装配&lt;bean id=&quot;cat&quot; class=&quot;com.kuang.pojo.Cat&quot;&gt;&lt;/bean&gt;\n&lt;bean id=&quot;dog&quot; class=&quot;com.kuang.pojo.Dog&quot;&gt;&lt;/bean&gt;\n\n&lt;!--\n    byName:会自动在容器中上下文查找，和自己对象set方法后面的值对应的beanid\n--&gt;\n&lt;bean id=&quot;perple&quot; class=&quot;com.kuang.pojo.People&quot; autowire=&quot;byName&quot;&gt;\n    &lt;property name=&quot;name&quot; value=&quot;saber&quot;/&gt;\n&lt;/bean&gt;\n\n7.2、ByType 自动装配&lt;bean id=&quot;cat&quot; class=&quot;com.kuang.pojo.Cat&quot;&gt;&lt;/bean&gt;\n&lt;bean id=&quot;dog&quot; class=&quot;com.kuang.pojo.Dog&quot;&gt;&lt;/bean&gt;\n\n&lt;!--\n    byType:会自动在容器中上下文查找，和自己对象属性类型相同的bean，\n--&gt;\n&lt;bean id=&quot;perple&quot; class=&quot;com.kuang.pojo.People&quot; autowire=&quot;byType&quot;&gt;\n    &lt;property name=&quot;name&quot; value=&quot;saber&quot;/&gt;\n&lt;/bean&gt;\n\n小结：\n\nbyname 的时候，需要保证所有 bean 的 id 唯一，并且这个 bean 需要和自动注入的属性的 set 方法的值一致\nbytype 的时候，需要保证所有 bean 的 class 唯一，并且这个 bean 需要和自动注入的属的类型一致\n\n7.3、使用注解实现自动装配jdk1.5 支持的注解，Spring2.5 就支持注解了\nThe introduction of annotation-based configuration raised the question of whether this approach is “better” than XML.\n使用注解须知：\n\n导入约束\n\n配置注解的支持\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;\n&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;\n    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;\n    xmlns:context=&quot;http://www.springframework.org/schema/context&quot;\n    xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans\n        https://www.springframework.org/schema/beans/spring-beans.xsd\n        http://www.springframework.org/schema/context\n        https://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;\n    &lt;context:annotation-config/&gt;\n&lt;/beans&gt;\n\n\n\n@Autowired\n直接在属性上使用即可，也可以在 set 方法使用\n使用 Autowired 我们可以不用编写 Set 方法，前提是你这个自动装配的属性在 IOC（Spring）容器中存在，且符合名字 byname\n@Autowired 默认根据类型进行匹配，若 xml 中同时存在多个相同类型时，则按名称进行匹配，若没用相同名称的配置时，则需要使用@Qualifier(value = “name”)注解进行指定，同时@Autowired 中还存在 required 属性，默认为 true，若为 false 时，说明对象可以为 null，否则不允许为空\n    &lt;bean id=&quot;cat&quot; class=&quot;com.kuang.pojo.Cat&quot;&gt;&lt;/bean&gt;\n&lt;!--    &lt;bean id=&quot;dog&quot; class=&quot;com.kuang.pojo.Dog&quot;&gt;&lt;/bean&gt;--&gt;\n    &lt;bean id=&quot;dog2&quot; class=&quot;com.kuang.pojo.Dog&quot;&gt;&lt;/bean&gt;\n    &lt;bean id=&quot;dog22&quot; class=&quot;com.kuang.pojo.Dog&quot;&gt;&lt;/bean&gt;\n\n    &lt;bean id=&quot;perple&quot; class=&quot;com.kuang.pojo.People&quot;&gt;\n        &lt;property name=&quot;name&quot; value=&quot;saber&quot;/&gt;\n    &lt;/bean&gt;\n\n    @Autowired\n    private Cat cat;\n\n    @Autowired\n    @Qualifier(value = &quot;dog22&quot;)\n    private Dog dog;\n\n    private String name;\n\n@Resource\n    @Resource(name = &quot;cat22&quot;)\n    private Cat cat;\n\n    @Resource\n    private Dog dog;\n\n小结：\n@Resource 和@Autowired 的区别：\n\n都是用于自动装配，都可以放在字段上\n@Autowired 通过 bytype 的方式实现，而且对象必须存在\n@Resource 默认通过 byname 实现，如果找不到名字，则通过 bytyoe 实现，如果两个都找不到，则报错\n\n8、使用注解开发&lt;!--注意：需要引入AOP包--&gt;\n&lt;!--需要扫描的包--&gt;\n&lt;context:component-scan base-package=&quot;com.kuang.pojo&quot;/&gt;\n&lt;context:annotation-config/&gt;\n\n\n@Component 组件\n//等价于&lt;bean id=&quot;user&quot; class=&quot;com.kuang.pojo.User&quot;/&gt; 无须在xml中写\n@Component\npublic class User &#123;\n    public String name=&quot;saber&quot;;\n&#125;\n\n@Value\n@Component\npublic class User &#123;\n    //等价于 &lt;property name=&quot;name&quot; value=&quot;saber&quot;/&gt;\n    @Value(&quot;SABER&quot;)\n    public String name;\n&#125;\n\n@Component 衍生注解，根据不同的层使用不同的注解\n\ndao 层【@Repository】\nservice 层【@Service】\ncontroller 层【@Controller】\n\n这四个注解功能都是一样的，都代表将某个类注册到 Spring 中，装配 Bean\n作用域也可以直接通过@Scope(&quot;&quot;)实现\n小结：\nxml 与注解：\n\nxml 更加万能，适用于各种场合，维护简单\n注解不是自己类使用不了，维护相对复杂\n\nxml 与注解的最佳实践：\n\nxml 来管理 bean\n\n注解只负责完成属性的注入\n\n我们使用中，只需要注意一个问题：必须让注解生效，就需要开启注解的支持\n&lt;!--需要扫描的包--&gt;\n&lt;context:component-scan base-package=&quot;com.kuang&quot;/&gt;\n&lt;context:annotation-config/&gt;\n\n\n\n9、使用 Java 的方式配置 SpringJavaConfig 是 Spring 的一个子项目\n实体类：\npackage com.kuang.pojo;\n\nimport org.springframework.beans.factory.annotation.Value;\nimport org.springframework.stereotype.Component;\n\n//@Component\npublic class User &#123;\n    @Value(&quot;saber&quot;)\n    private String name;\n\n    public String getName() &#123;\n        return name;\n    &#125;\n\n    public void setName(String name) &#123;\n        this.name = name;\n    &#125;\n\n    @Override\n    public String toString() &#123;\n        return &quot;User&#123;&quot; +\n                &quot;name=&#39;&quot; + name + &#39;\\&#39;&#39; +\n                &#39;&#125;&#39;;\n    &#125;\n&#125;\n\n配置文件类：\npackage com.kuang.config;\n\nimport com.kuang.pojo.User;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.ComponentScan;\nimport org.springframework.context.annotation.Configuration;\n\n//这个也会被Spring容器托管，注册到容器中，因为它本身就是一个@Component\n//@Configuration表示这是一个配置类，就是之前的beans.xml\n@Configuration\n//@ComponentScan(&quot;com.kuang.pojo&quot;) //扫描指定包\n@Import(SaberConfig2.class) //相当于Import标签\npublic class SaberConfig &#123;\n\n    //注册一个bean 相当于之前的&lt;bean&gt;标签\n    //方法名相当于bean标签的id\n    //返回值相当于bean标签的class属性\n    @Bean\n    public User getUser()&#123;\n        return new User();//我们要注入到bean的对象\n    &#125;\n&#125;\n//如果你没用扫描指定包@ComponentScan(&quot;com.kuang.pojo&quot;) 则必须使用@Bean主动进行配置，\n//如果使用@ComponentScan(&quot;com.kuang.pojo&quot;)扫描，则扫描对象必须包含@Component\n\n测试方法:\n    public static void main(String[] args) &#123;\n        ApplicationContext ctx = new AnnotationConfigApplicationContext(SaberConfig.class);\n        User user = ctx.getBean(User.class);//也可以用方法名getUser,也可以用@Bean指定的名称\n        System.out.println(user.getName());\n    &#125;\n\n10、代理模式代理模式的分类：\n\n静态代理\n动态代理\n\n\n10.1、静态代理角色分析：\n\n抽象角色：一般会使用接口或抽象类来解决\n真实角色：被代理的角色\n代理角色：代理真实角色，代理真实角色后，我们一般会做一些附属操作\n客户：访问代理对象\n\n代码步骤：\n\n接口\n//租房\npublic interface Rent &#123;\n    public void rent();\n&#125;\n\n\n真实角色\npublic class Host implements Rent&#123;\n    @Override\n    public void rent() &#123;\n        System.out.println(&quot;房东要租房子&quot;);\n    &#125;\n&#125;\n\n\n代理角色\npublic class Proxy implements Rent&#123;\n\n    private Host host;\n\n    public Proxy() &#123;\n    &#125;\n\n    public Proxy(Host host) &#123;\n        this.host = host;\n    &#125;\n\n    @Override\n    public void rent() &#123;\n        seeHouse();\n        host.rent();\n        hetong();\n        fare();\n    &#125;\n\n    public void seeHouse()&#123;\n        System.out.println(&quot;kan fang&quot;);\n    &#125;\n\n    public void hetong()&#123;\n        System.out.println(&quot;qian he tong&quot;);\n    &#125;\n\n    public void fare()&#123;\n        System.out.println(&quot;shou zhong jie fei&quot;);\n    &#125;\n&#125;\n\n\n客户端访问代理角色\n    public static void main(String[] args) &#123;\n        Host host = new Host();\n//        host.rent();\n\n        Proxy proxy = new Proxy(host);\n        proxy.rent();\n    &#125;\n\n\n\n代理模式的好处：\n\n可以使真实角色的操作更加纯粹，不用去关注一些公共服务\n公共服务交给代理角色，实现业务划分\n公共业务发生扩展时，方便集中管理\n\n缺点：\n\n一个真实角色就会产生一个代理角色，代码量翻倍，开发效率变低\n\n10.2、动态代理\n动态代理和静态代理角色一样\n动态代理的代理类是动态生成的，不是写好的\n动态代理分为两大类：基于接口的动态代理，基于类的动态代理\n基于接口：JDK 实现动态代理\n基于类：cglib\njava 字节码实现：javasist\n\n\n\n需要了解两个类：Proxy：代理， InvocationHandler：调用处理程序\n动态代理的好处：\n\n可以使真实角色的操作更加纯粹，不用去关注一些公共服务\n公共服务交给代理角色，实现业务划分\n公共业务发生扩展时，方便集中管理\n一个动态代理类代理的是一个接口，一般是对应的一类业务\n一个动态代理类可以代理多个类，只要实现了同一个接口即可\n\n动态代理的代码实现：\nimport java.lang.reflect.InvocationHandler;\nimport java.lang.reflect.Method;\nimport java.lang.reflect.Proxy;\n\npublic class StarProxy implements InvocationHandler\n&#123;\n    // 目标类，也就是被代理对象\n    private Object target;\n\n    public void setTarget(Object target)\n    &#123;\n        this.target = target;\n    &#125;\n\n    @Override\n    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable\n    &#123;\n        // 这里可以做增强\n        System.out.println(&quot;收钱&quot;);\n\n        Object result = method.invoke(target, args);\n\n        return result;\n    &#125;\n\n    // 生成代理类\n    public Object CreatProxyedObj()\n    &#123;\n        return Proxy.newProxyInstance(target.getClass().getClassLoader(), target.getClass().getInterfaces(), this);\n    &#125;\n\n&#125;\n\n11、AOP11.1、什么是 AOPAOP（Aspect Oriented Programming）称为面向切面编程，在程序开发中主要用来解决一些系统层面上的问题，比如日志，事务，权限等待，AOP 是 OOP 的延续，是软件开发中的热点，是函数是编程的一种衍生范型，利用 AOP 可以对业务逻辑的各部分进行隔离，从而使业务逻辑各部分之间的耦合降低，提高可重用性。\n11.2、AOP 在 Spring 的作用提供声明性事务，允许用户自定义切面\n\n横切关注点：跨越应用程序多个模块的方法或功能，即是，与我们业务逻辑无关，但是我们需要关注的部分，就是横切关注点，如日志，安全，缓存，事务等等….\n切面（ASPECT）：横切关注点 被模块化 的特殊对象。即，它是一个类。\n通知（Advice）：切面必须要完成的工作。即，它是类中的一个方法。\n目标（Target）：被通知的对象。\n代理（Proxy）：向目标对象应用通知之后创建的对象\n切入点（PointCut）：切面通知 执行的“地点”的定义\n连接点（JointPoint）：与切入点匹配的执行点\n\n\nSpringAOP 中，通过 Advice 定义横切逻辑，Spring 中支持 5 种类型的 Advice：\n\n即 AOP 在不改变原有代码的情况下，去增加新的功能\n11.3、使用 Spring 实现 AOP使用 AOP 织入，需要导入一个依赖包\n&lt;dependency&gt;\n    &lt;groupId&gt;org.aspectj&lt;/groupId&gt;\n    &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt;\n    &lt;version&gt;1.9.4&lt;/version&gt;\n&lt;/dependency&gt;\n\n方法一：使用 Spring 接口@Component\npublic class Log implements MethodBeforeAdvice &#123;\n    //method：要执行的目标对象的方法\n    //objects：参数\n    //o：目标对象\n    @Override\n    public void before(Method method, Object[] objects, Object o) throws Throwable &#123;\n        System.out.println(o.getClass().getName() +&quot;的&quot;+method.getName()+&quot;方法被执行&quot;);\n    &#125;\n&#125;\n\n@Component\npublic class AfterLog implements AfterReturningAdvice &#123;\n    //returnValue：返回值\n    @Override\n    public void afterReturning(Object returnValue, Method method, Object[] args, Object target) throws Throwable &#123;\n        System.out.println(&quot;执行了&quot;+method.getName() +&quot;方法,返回结果:&quot;+returnValue);\n    &#125;\n&#125;\n\n上面实现两个测试用的切面方法\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;\n&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;\n       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;\n       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;\n       xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;\n       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans\n        https://www.springframework.org/schema/beans/spring-beans.xsd\n        http://www.springframework.org/schema/context\n        https://www.springframework.org/schema/context/spring-context.xsd\n        http://www.springframework.org/schema/aop\n        https://www.springframework.org/schema/aop/spring-aop.xsd&quot;&gt;\n\n    &lt;context:component-scan base-package=&quot;com.kuang&quot;/&gt;\n    &lt;context:annotation-config/&gt;\n\n    &lt;!--方法一：使用原生SpringAPI接口--&gt;\n    &lt;!--配置aop：需要导入aop约束--&gt;\n    &lt;aop:config&gt;\n        &lt;!--DOTO:切入点：expression：表达式，execution(要执行的位置！)--&gt;\n        &lt;aop:pointcut id=&quot;pointuct&quot; expression=&quot;execution(* com.kuang.service.UserServiceImpl.*(..))&quot;/&gt;\n\n        &lt;!--要执行的环绕增加--&gt;\n        &lt;aop:advisor advice-ref=&quot;afterLog&quot; pointcut-ref=&quot;pointuct&quot;/&gt;\n        &lt;aop:advisor advice-ref=&quot;log&quot; pointcut-ref=&quot;pointuct&quot;/&gt;\n    &lt;/aop:config&gt;\n\n&lt;/beans&gt;\n\npublic class MyTest &#123;\n    public static void main(String[] args) &#123;\n        ApplicationContext context = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);\n        UserService userService = context.getBean(&quot;userServiceImpl&quot;,UserService.class);\n\n        userService.add();\n    &#125;\n&#125;\n\n方法二：自定义类实现 AOP将配置文件修改为：\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;\n&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;\n       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;\n       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;\n       xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;\n       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans\n        https://www.springframework.org/schema/beans/spring-beans.xsd\n        http://www.springframework.org/schema/context\n        https://www.springframework.org/schema/context/spring-context.xsd\n        http://www.springframework.org/schema/aop\n        https://www.springframework.org/schema/aop/spring-aop.xsd&quot;&gt;\n\n    &lt;context:component-scan base-package=&quot;com.kuang&quot;/&gt;\n    &lt;context:annotation-config/&gt;\n\n    &lt;!--方法二：自定义类--&gt;\n    &lt;aop:config&gt;\n        &lt;!--自定义切面，ref要引用的类--&gt;\n        &lt;aop:aspect ref=&quot;diyPintCut&quot;&gt;\n            &lt;!--切入点--&gt;\n            &lt;aop:pointcut id=&quot;point&quot; expression=&quot;execution(* com.kuang.service.UserServiceImpl.*(..))&quot;/&gt;\n\n            &lt;!--通知--&gt;\n            &lt;aop:after method=&quot;after&quot; pointcut-ref=&quot;point&quot;/&gt;\n            &lt;aop:before method=&quot;before&quot; pointcut-ref=&quot;point&quot;/&gt;\n        &lt;/aop:aspect&gt;\n    &lt;/aop:config&gt;\n\n&lt;/beans&gt;\n\n实现的自定义类：\nimport org.springframework.stereotype.Component;\n@Component\npublic class DiyPintCut &#123;\n    public void before()&#123;\n        System.out.println(&quot;=======berfre========&quot;);\n    &#125;\n    public void after()&#123;\n        System.out.println(&quot;=======after========&quot;);\n    &#125;\n&#125;\n\n方式三：使用注解实现import org.aspectj.lang.ProceedingJoinPoint;\nimport org.aspectj.lang.annotation.After;\nimport org.aspectj.lang.annotation.Around;\nimport org.aspectj.lang.annotation.Aspect;\nimport org.aspectj.lang.annotation.Before;\nimport org.springframework.stereotype.Component;\n\n@Aspect //标注这是一个切面\n@Component\npublic class AnnotationPointCut &#123;\n    @Before(&quot;execution(* com.kuang.service.UserServiceImpl.*(..))&quot;)//注意 这是annotation包下的注解\n    public void before() &#123;\n        System.out.println(&quot;=======berfre========&quot;);\n    &#125;\n\n    @After(&quot;execution(* com.kuang.service.UserServiceImpl.*(..))&quot;)\n    public void after() &#123;\n        System.out.println(&quot;=======after========&quot;);\n    &#125;\n\n    //在环绕增强中，我们可以定一个参数，代表我们要获取处理的切入点\n    @Around(&quot;execution(* com.kuang.service.UserServiceImpl.*(..))&quot;)\n    public void around(ProceedingJoinPoint jp) throws Throwable &#123;\n        System.out.println(&quot;before-around&quot;);\n        System.out.println(jp.getSignature());//获取签名\n\n        Object proceed = jp.proceed();//执行方法 proceed：返回值\n\n        System.out.println(&quot;after-around&quot;);\n        System.out.println(proceed);\n    &#125;\n&#125;\n\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;\n&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;\n       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;\n       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;\n       xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;\n       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans\n        https://www.springframework.org/schema/beans/spring-beans.xsd\n        http://www.springframework.org/schema/context\n        https://www.springframework.org/schema/context/spring-context.xsd\n        http://www.springframework.org/schema/aop\n        https://www.springframework.org/schema/aop/spring-aop.xsd&quot;&gt;\n\n    &lt;context:component-scan base-package=&quot;com.kuang&quot;/&gt;\n    &lt;context:annotation-config/&gt;\n    &lt;!--开启注解支持 需要添加这个才能使用注解AOP--&gt;\n    &lt;!--有一个参数 默认为false 则为使用JDK实现动态代理 true则使用cglib   proxy-target-class=&quot;true&quot;--&gt;\n    &lt;aop:aspectj-autoproxy/&gt;\n\n&lt;/beans&gt;\n\n参考：\n文章：https://www.jianshu.com/p/34efe69582c8\n","categories":["Spring"],"tags":["Spring","AOP","IOC"]},{"title":"SpringBoot自定义校验注解","url":"/2021/03/19/SpringBoot%E8%87%AA%E5%AE%9A%E4%B9%89%E6%A0%A1%E9%AA%8C%E6%B3%A8%E8%A7%A3/","content":"引入指定包&lt;dependency>\n     \t&lt;groupId>javax.validation&lt;/groupId>\n       &lt;artifactId>validation-api&lt;/artifactId>\n       &lt;version>2.0.1.Final&lt;/version>\n   &lt;/dependency>\n\n创建自定义校验类//必须包含一下注解\n@Documented\n@Constraint(validatedBy = &#123; ListValueConstraintValidator.class &#125;)//具体校验的实现，可以指定多个，适配不同的参数\n@Target(&#123; METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER, TYPE_USE &#125;)//我们的自定义注解可以在哪里使用\n@Retention(RUNTIME)\npublic @interface ListValue &#123;\n    \n\t//jsr303规范中 校验注解必须包含下面三个属性\n    String message() default \"&#123;com.atguigu.common.valid.ListValue.message&#125;\";//当校验出错时 错误信息去哪里取 和下面配置文件需要匹配\n    Class&lt;?>[] groups() default &#123; &#125;; //必须支持分组校验\n    Class&lt;? extends Payload>[] payload() default &#123; &#125;; //自定义负载信息\n\n    int[] vals() default &#123; &#125;;//校验的具体参数\n&#125;\n\n\n实体类中使用@ListValue(vals=&#123;0,1&#125;)//可以使用message自定义信息，也可以写在配置文件中\nprivate Integer showStatus;\n\n错误信息配置文件com.atguigu.common.valid.ListValue.message=必须提交指定的值\n\n校验的实现/*\n*\t需要实现ConstraintValidator\n*\t&lt;ListValue,Integer> 校验注解，校验参数类型\n*/\npublic class ListValueConstraintValidator implements ConstraintValidator&lt;ListValue,Integer> &#123;\n\n    private Set&lt;Integer> set = new HashSet&lt;>();\n    //初始化方法\n    @Override\n    public void initialize(ListValue constraintAnnotation) &#123;\n\n        int[] vals = constraintAnnotation.vals();//获取我们给定的值\n        for (int val : vals) &#123;\n            set.add(val);\n        &#125;\n    &#125;\n\n    //判断是否校验成功\n\n    /**\n     *\n     * @param value 需要校验的值，也就是我们提交的值\n     * @param context\n     * @return\n     */\n    @Override\n    public boolean isValid(Integer value, ConstraintValidatorContext context) &#123;\n\n        return set.contains(value);\n    &#125;\n&#125;\n\n\n","categories":["SpringBoot"],"tags":["Spring","SpringBoot"]},{"title":"SpringBoot分组校验","url":"/2021/03/19/SpringBoot%E5%88%86%E7%BB%84%E6%A0%A1%E9%AA%8C/","content":"在实际开发中，难免遇到对一个实体类的一些属性，不同的请求会有不同的校验规则的场景，比如：用户注册时，User 类的 id 需校验为空，因为 User 的 id 肯定是由系统生成并维护而不是让用户自己填写的。但是在修改用户密码时，又需要传入 Id 来作为 where 语句的条件去更新，此时分组校验就派上用场了。\n先上代码：\n/*\n*\t一个普通的实体类\n*\t在我们常用的校验注解中，有一个groups参数，用于标注校验注解属于哪一种情况才进行校验，可以指定多种情况\n*\tgroups = &#123;AddGroup.class,UpdateGroup.class&#125;\n*/\n@Data\n@TableName(\"pms_brand\")\npublic class BrandEntity implements Serializable &#123;\n\tprivate static final long serialVersionUID = 1L;\n\n\t/**\n\t * 品牌id\n\t */\n\t@NotNull(message = \"修改必须指定品牌id\",groups = &#123;UpdateGroup.class&#125;)\n\t@Null(message = \"新增不能指定id\",groups = &#123;AddGroup.class&#125;)\n\t@TableId\n\tprivate Long brandId;\n\t/**\n\t * 品牌名\n\t */\n\t@NotBlank(message = \"品牌名必须提交\",groups = &#123;AddGroup.class,UpdateGroup.class&#125;)\n\tprivate String name;\n\t/**\n\t * 品牌logo地址\n\t */\n\t@NotBlank(groups = &#123;AddGroup.class&#125;)\n\t@URL(message = \"logo必须是一个合法的url地址\",groups=&#123;AddGroup.class,UpdateGroup.class&#125;)\n\tprivate String logo;\n\t/**\n\t * 介绍\n\t */\n\tprivate String descript;\n\t/**\n\t * 显示状态[0-不显示；1-显示]\n\t */\n\t@NotNull(groups = &#123;AddGroup.class, UpdateStatusGroup.class&#125;)\n  \t@ListValue(vals=&#123;0,1&#125;,groups = &#123;AddGroup.class, UpdateStatusGroup.class&#125;)\n\tprivate Integer showStatus;\n\t/**\n\t * 检索首字母\n\t */\n\t@NotEmpty(groups=&#123;AddGroup.class&#125;)\n\t@Pattern(regexp=\"^[a-zA-Z]$\",message = \"检索首字母必须是一个字母\",groups=&#123;AddGroup.class,UpdateGroup.class&#125;)\n\tprivate String firstLetter;\n\t/**\n\t * 排序\n\t */\n\t@NotNull(groups=&#123;AddGroup.class&#125;)\n\t@Min(value = 0,message = \"排序必须大于等于0\",groups=&#123;AddGroup.class,UpdateGroup.class&#125;)\n\tprivate Integer sort;\n\n&#125;\n\n上面我们定义了AddGroup.class,UpdateGroup.class我们需要创建它们，它们以接口的形式存在，空接口就行了\n/*\n*\t格式如下\n*/\npublic interface AddGroup &#123;\n&#125;\n\n\n具体需要实现分组校验功能，我们需要在controller做些修改\n我们不能使用普通的@Valid注解，它不具备实现分组校验的功能，我们需要换成@Validated注解，它可以指定一个或多个分组\n/**\n *\t保存\n *\t返回结果R的实现去看我的 SpringBoot全局异常处理 文章\n */\n@RequestMapping(\"/save\")\npublic R save(@Validated(&#123;AddGroup.class&#125;) @RequestBody BrandEntity brand)&#123;\n\n    brandService.save(brand);\n\n    return R.ok();\n&#125;\n\n使用注意事项：\n当你启用了分组校验功能时@Validated(&#123;AddGroup.class&#125;)，但你的实体类中某个字段却没用指定分组，这种情况下，是不会对字段进行任何校验的\n相反，当你没用启用分组校验时@Validated，只有没用标注分组校验的字段才会生效\n","categories":["SpringBoot"],"tags":["Spring","SpringBoot"]},{"title":"SpringBoot全局异常处理","url":"/2021/03/19/SpringBoot%E5%85%A8%E5%B1%80%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/","content":"在做Web应用的时候，请求处理过程中发生错误是非常常见的情况，那我们如何才能统一且友好地返回系统异常给前台呢。\n关键在于：注解@ControllerAdvice和@ExceptionHandler\n视频参考：\n开始通过使用@ControllerAdvice修饰一个类，表示该类是Controller的全局配置类。\n在此类中，可以对Controller进行如下三种全局配置：异常处理方案：@ExceptionHandler，数据绑定方案：@ModelAttribute，绑定参数方案:@InitBinder\n本文演示@ExceptionHandler的使用\n定义统一的异常处理类，而不是在每个Controller中逐个定义。@ExceptionHandler用来定义函数针对的异常类型\n创建一个最简单Springboot项目\nController层代码:@RestController\n@RequestMapping(&quot;product/brand&quot;)\npublic class UserController &#123;\n\n    @Autowired\n    private BrandService brandService;\n\n    /**\n     * 保存\n     */\n    @RequestMapping(&quot;/save&quot;)\n    public R save(@Valid @RequestBody BrandEntity brand)&#123;\n        brandService.save(brand);//这只是一个普通的写入操作，随意实现即可\n        return R.ok();\n    &#125;\n&#125;\n\n统一结果返回枚举类/***\n * 错误码和错误信息定义类\n * 1. 错误码定义规则为5为数字\n * 2. 前两位表示业务场景，最后三位表示错误码。例如：100001。10:通用 001:系统未知异常\n * 3. 维护错误码后需要维护错误描述，将他们定义为枚举形式\n * 错误码列表：\n *  10: 通用\n *      001：参数格式校验\n *  11: 商品\n *  12: 订单\n *  13: 购物车\n *  14: 物流\n *    ...\n */\npublic enum BizCodeEnume &#123;\n    UNKNOW_EXCEPTION(10000,&quot;系统未知异常&quot;),\n    VAILD_EXCEPTION(10001,&quot;参数格式校验失败&quot;);\n\n    private int code;\n    private String msg;\n    BizCodeEnume(int code,String msg)&#123;\n        this.code = code;\n        this.msg = msg;\n    &#125;\n\n    public int getCode() &#123;\n        return code;\n    &#125;\n\n    public String getMsg() &#123;\n        return msg;\n    &#125;\n&#125;\n\n统一返回工具类/**\n * Copyright (c) 2016-2019 人人开源 All rights reserved.\n *\n * https://www.renren.io\n *\n * 版权所有，侵权必究！\n */\npublic class R extends HashMap&lt;String, Object&gt; &#123;\n    private static final long serialVersionUID = 1L;\n    \n    public R() &#123;\n        put(&quot;code&quot;, 0);\n        put(&quot;msg&quot;, &quot;success&quot;);\n    &#125;\n    \n    public static R error() &#123;\n        return error(HttpStatus.SC_INTERNAL_SERVER_ERROR, &quot;未知异常，请联系管理员&quot;);\n    &#125;\n    \n    public static R error(String msg) &#123;\n        return error(HttpStatus.SC_INTERNAL_SERVER_ERROR, msg);\n    &#125;\n    \n    public static R error(int code, String msg) &#123;\n        R r = new R();\n        r.put(&quot;code&quot;, code);\n        r.put(&quot;msg&quot;, msg);\n        return r;\n    &#125;\n\n    public static R ok(String msg) &#123;\n        R r = new R();\n        r.put(&quot;msg&quot;, msg);\n        return r;\n    &#125;\n    \n    public static R ok(Map&lt;String, Object&gt; map) &#123;\n        R r = new R();\n        r.putAll(map);\n        return r;\n    &#125;\n    \n    public static R ok() &#123;\n        return new R();\n    &#125;\n\n    public R put(String key, Object value) &#123;\n        super.put(key, value);\n        return this;\n    &#125;\n    public  Integer getCode() &#123;\n\n        return (Integer) this.get(&quot;code&quot;);\n    &#125;\n\n&#125;\n\n集中处理类通过使用@ControllerAdvice定义统一的异常处理类，而不是在每个Controller中逐个定义。@ExceptionHandler用来定义函数针对的异常类型\n/**\n * 集中处理所有异常\n */\n@Slf4j\n//@ResponseBody\n//@ControllerAdvice(basePackages = &quot;com.atguigu.gulimall.product.controller&quot;)\n@RestControllerAdvice(basePackages = &quot;com.atguigu.gulimall.product.controller&quot;)//这是上面两个注解的结合 参数为需要集中处理的包\npublic class GulimallExceptionControllerAdvice &#123;\n    \n    @ExceptionHandler(value= MethodArgumentNotValidException.class)//处理什么类型的异常\n    public R handleVaildException(MethodArgumentNotValidException e)&#123;\n        log.error(&quot;数据校验出现问题&#123;&#125;，异常类型：&#123;&#125;&quot;,e.getMessage(),e.getClass());\n        BindingResult bindingResult = e.getBindingResult();\n\n        Map&lt;String,String&gt; errorMap = new HashMap&lt;&gt;();\n        bindingResult.getFieldErrors().forEach((fieldError)-&gt;&#123;\n            errorMap.put(fieldError.getField(),fieldError.getDefaultMessage());\n        &#125;);\n        return R.error(BizCodeEnume.VAILD_EXCEPTION.getCode(),BizCodeEnume.VAILD_EXCEPTION.getMsg()).put(&quot;data&quot;,errorMap);\n    &#125;\n\n    @ExceptionHandler(value = Throwable.class)\n    public R handleException(Throwable throwable)&#123;\n\n        log.error(&quot;错误：&quot;,throwable);\n        return R.error(BizCodeEnume.UNKNOW_EXCEPTION.getCode(),BizCodeEnume.UNKNOW_EXCEPTION.getMsg());\n    &#125;\n\n\n&#125;\n\n至此，我们的功能就已经实现了，可以运行测试了。\n","categories":["SpringBoot"],"tags":["Spring","SpringBoot"]},{"title":"JAVA多线程基础","url":"/2021/03/18/JAVA%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80/","content":"线程的创建方式继承Thread类public class ThreadCreateDemo1 &#123;\n    public static void main(String[] args) &#123;\n        MyThread thread = new MyThread();\n        thread.start(); //该方法调用多次,出现IllegalThreadStateException\n    &#125;\n&#125;\n\nclass MyThread extends Thread &#123;\n    @Override\n    public void run() &#123;\n        super.run();\n        System.out.println(&quot;hellow_world!&quot;);\n    &#125;\n&#125;\n\n继承Runnable接口public class ThreadCreateDemo2 &#123;\n    public static void main(String[] args) &#123;\n        Runnable runnable = new MyRunnable();\n        new Thread(runnable).start();\n    &#125;\n&#125;\n\nclass MyRunnable implements Runnable &#123;\n    public void run() &#123;\n        System.out.println(&quot;通过Runnable创建的线程!&quot;);\n    &#125;\n&#125;\n\n 上述两种创建方式,工作时性质一样。但是建议使用实现Runable接口方式。解决单继承的局限性\n线程运行结果与执行顺序无关线程的调度是由CPU决定，CPU执行子任务时间具有不确定性。\npublic class ThreadRandomDemo1 &#123;\n    public static void main(String[] args) &#123;\n        Thread[] threads = new Thread[10];\n        for (int i = 0; i &lt; 10; i++) &#123;\n            threads[i] = new RandomThread(&quot;RandomThread:&quot; + i);\n        &#125;\n        for(Thread thread : threads) &#123;\n            thread.start();\n        &#125;\n    &#125;\n&#125;\n\nclass RandomThread extends Thread &#123;\n    \n    public RandomThread(String name) &#123;\n        super(name);\n    &#125;\n    \n    @Override\n    public void run() &#123;\n        try &#123;\n            Thread.sleep(1000);\n            System.out.println(Thread.currentThread().getName());\n        &#125; catch (InterruptedException e) &#123;\n            e.printStackTrace();\n        &#125;\n    &#125;\n&#125;\n\n以上10个线程，代码按照顺序执行，但是结果可以看出没有按照顺序执行，而且多次执行结果基本不同。\n\n线程实例变量与安全问题线程之间变量有共享与不共享之分，共享理解为大家都使用同一份，不共享理解为每个单独持有一份。\n共享数据的情况public class ThreadShareVariableDemo &#123;\n    public static void main(String[] args) &#123;\n        Runnable runnable = new ShareVariableRunnable();\n        Thread[] threads = new Thread[5];\n        for (int i = 0; i &lt; 5; i++) &#123;\n            threads[i] = new Thread(runnable, &quot;thread:&quot; + (i+1));\n        &#125;\n        for (Thread thread : threads) &#123;\n            thread.start();\n        &#125;\n    &#125;\n&#125;\n\nclass ShareVariableRunnable implements Runnable &#123;\n    private int count = 5;\n    \n    public void run() &#123;\n        System.out.println(&quot;&quot; + Thread.currentThread().getName() + &quot;,count:&quot; + count--);\n    &#125;\n&#125;\n\n\n从上图结果可以看出，count变量是共享的，不然都会打印5。但是也发现了一点thread:1 与 thread:2 打印值一样，该现象就是我们通常称为的脏数据【多线程对同一变量进行读写操作不同步产生】。\n解决方案在访问变量方法中增加synchronized关键字：\nclass ShareVariableRunnable implements Runnable &#123;\n    private int count = 5;\n    \n    public synchronized void run() &#123;\n        System.out.println(&quot;&quot; + Thread.currentThread().getName() + &quot;,count:&quot; + count--);\n    &#125;\n&#125;\n\n\n如图每次打印count都是正常递减，这里解释一下synchronized关键字，含有synchronized关键字的这个方法称为“互斥区” 或“临界区”，只有获得这个关键字对应的锁才能执行方法体，方法体执行完自动会释放锁。\n停止线程终止正在运行的线程方法有三种：  1. 使用退出标志,使线程正常的执行完run方法终止  2. 使用interrupt方法,使线程异常，线程进行捕获或抛异常，正常执行完run方法终止       3. 使用stop方法强制退出\n这里主要说明前两种方法；\n\n使用退出标志位\npublic class ThreadVariableStopDemo &#123;\n    public static void main(String[] args) throws InterruptedException &#123;\n        VariableStopThread thread = new VariableStopThread(&quot;thread_1&quot;);\n        thread.start();\n        Thread.sleep(1);\n        thread.Stop();\n    &#125;\n&#125;\n\nclass VariableStopThread extends Thread &#123;\n    private boolean interrupt = true;\n    \n    public VariableStopThread(String name) &#123;\n        super(name);\n    &#125;\n    \n    public void run() &#123;\n        System.out.println(Thread.currentThread().getName() + &quot;:线程开始运行!&quot;);\n        int i = 0;\n        while(interrupt) &#123;\n            System.out.println(&quot;&quot; + (i++));\n        &#125;\n        System.out.println(&quot;我停止了! timer:&quot; + System.currentTimeMillis());\n    &#125;\n    \n    public void Stop() &#123;\n        System.out.println(Thread.currentThread().getName() + &quot;:线程设置了停止! timer:&quot; + System.currentTimeMillis());\n        this.interrupt = false;\n    &#125;\n&#125;\n\n\n\n使用interrupt方法\npublic class ThreadInterruptDemo &#123;\n    public static void main(String[] args) throws InterruptedException &#123;\n        Thread thread = new InterruptThread(&quot;thread_1&quot;);\n        thread.start();\n        Thread.sleep(1);\n        System.out.println(thread.getName() + &quot;线程设置:interrupt&quot;);\n        thread.interrupt();\n    &#125;\n&#125;\n\nclass InterruptThread extends Thread &#123;\n    \n    public InterruptThread(String name) &#123;\n        super(name);\n    &#125;\n    \n    @Override\n    public void run() &#123;\n        System.out.println(Thread.currentThread().getName() + &quot;线程开始!&quot;);\n        for(int i =0; i &lt; 1000; i++) &#123;\n            try &#123;\n                Thread.sleep(0);\n                System.out.println(&quot;&quot; + (i + 1));\n            &#125; catch (InterruptedException e) &#123;\n                System.out.println(Thread.currentThread().getName() + &quot;线程捕获异常,退出循环!&quot;);\n                break;\n            &#125;\n        &#125;\n        System.out.println(Thread.currentThread().getName() + &quot;线程结束!&quot;);\n    &#125;\n&#125;\n\n\n\n\n线程优先级线程优先级范围为1-10，API提供等级分为：低（MIN_PRIORITY = 1)，中（NORM_PRIORITY=5），高（MAX_PRIORITY=10）。 线程优先级有以下特点：\n\n继承特性【线程A中启动线程B，线程B继承了A的优先级】\n\n随机性【线程调度的顺序不一定是根据优先级，具有随机性】\npublic class ThreadPriorityDemo &#123;\n    public static void main(String[] args) &#123;\n        Thread thread = new ThreadPriority(&quot;thread_1&lt;&lt;&lt;&lt;&quot;);\n        Thread thread_1 = new ThreadPriority(&quot;&gt;&gt;&gt;thread_2&quot;);\n        thread_1.setPriority(Thread.MIN_PRIORITY); //&lt;设置线程优先级\n        thread.setPriority(Thread.MAX_PRIORITY);\n        thread_1.start();\n        thread.start();\n    &#125;\n&#125;\n\nclass ThreadPriority extends Thread &#123;\n    public ThreadPriority(String name) &#123;\n        super(name);\n    &#125;\n    \n    @Override\n    public void run() &#123;\n        for (int i = 0; i &lt; 10; i++) &#123;\n            System.out.println(&quot;&quot; + Thread.currentThread().getName() + &quot;,number:&quot; + i + &quot;,Priority:&quot; + Thread.currentThread().getPriority());\n        &#125;\n    &#125;\n&#125;\n\n\n\n\n守护线程守护线程顾名思义是一个线程守护另一个线程【此线程为非守护线程】，故守护的线程称为守护线程，被守护的线程称为非守护线程。作用是为其他线程运行提供便利服务。\npublic class DaemonThreadDemo &#123;\n    public static void main(String[] args) throws InterruptedException &#123;\n        Thread thread = new DaemonThread();\n        thread.setDaemon(true);//设置线程为守护线程\n        thread.start();\n        System.out.println(&quot;&quot; + Thread.currentThread().getName() + &quot;停止运行!&quot; );\n    &#125;\n&#125;\n\nclass DaemonThread extends Thread &#123;\n    @Override\n    public void run() &#123;\n        while (true) &#123;\n            System.out.println(&quot;DaemonThread 正在运行!&quot;);\n        &#125;\n    &#125;\n&#125;\n\n\n从上图可以看出，主线程停止DaemonThread线程也相应的停止了，但不是立即停止。\n线程让步线程让步yield()让当前线程释放CPU资源，让其他线程抢占。\npublic class ThreadYieldDemo &#123;\n    public static void main(String[] args) &#123;\n        Thread thread = new ThreadYield();\n        thread.start();\n    &#125;\n&#125;\nclass ThreadYield extends Thread &#123;\n    @Override\n    public void run() &#123;\n        long time_start = System.currentTimeMillis();\n        for(int i = 0; i &lt; 500000; i++) &#123;\n            Thread.yield();\n        &#125;\n        long time_end = System.currentTimeMillis();\n        System.out.println(&quot;用时：&quot; + (time_end - time_start));\n    &#125;\n&#125;\n\n","categories":["Java"],"tags":[]},{"title":"理解JVM","url":"/2021/03/16/%E7%90%86%E8%A7%A3JVM/","content":"JVM 是 Java Virtual Machine 的缩写，它是一个虚构出来的计算机，类似于小电脑运行在 Windows 或 Linux 这些系统上，它与系统直接交互，但不与硬件直接交互。\n\nJava 文件是如何被运行的一个.java 文件需要被编译成.class 文件，在将其装进一个类加载器中，它就像搬运工，把所有.class 文件搬进 JVM 中，JVM 简易结构如下：\n\n\nJVM模型架构Java编译器输入的指令流基本上是一种基于栈的指令集架构，另外一种指令集架构则是基于寄存器的指令集架构\n基于栈式架构的特点\n\n设计和实现更简单，适用于资源受限的系统\n\n避开了寄存器的分配难题：使用零地址指令方式分配\n\n指令流中的指令大部分是零地址指令，其执行过程依赖于操作栈。指令集更小，编译器容易实现\n\n不需要硬件支持，可移植性更好，更好实现跨平台\n\n\n基于寄存器架构的特点\n\n典型的应用是x86的二进制指令集：比如传统的PC以及Android的Davlik虚拟机\n\n指令集架构则完全依赖硬件，可移植性差\n\n性能优秀和执行更高效\n\n花费更少的指令去完成一项操作\n\n在大部分情况下，基于寄存器架构的指令集往往都以一地址指令、二地址指令和三地址指令为主，而基于栈式架构的指令集却是以零地址指令为主\n\n\n总结由于跨平台性的设计，Java的指令都是根据栈来设计的。不同平台CPU架构不同，所以不能设计为基于寄存器的。优点是跨平台，指令集小，编译器容易实现，缺点是性能下降，实现同样的功能需要更多的指令。\n时至今日，尽管嵌入式平台已经不是Java程序的主流运行平台了（准确来说应该是HotSpotVM的宿主环境已经不局限于嵌入式平台了），那么为什么不将架构更换为基于寄存器的架构呢？答：已经够用了\n栈：跨平台性、指令集小、指令多：执行性能比寄存器差\nJVM生命周期虚拟机的启动\nJava虚拟机的启动是通过引导类加载器（bootstrap class loader）创建一个初始类（initial class）来完成的，这个类是由虚拟机的具体实现指定的。\n虚拟机的执行\n\n一个运行中的Java虚拟机有着一个清晰的任务：执行Java程序。\n\n程序开始执行时他才运行，程序结束时他就停止。\n\n执行一个所谓的Java程序的时候，真真正正在执行的是一个叫做Java虚拟机的进程。\n\n\n虚拟机的退出\n有如下的几种情况：\n\n程序正常执行结束\n\n程序在执行过程中遇到了异常或错误而异常终止\n\n由于操作系统用现错误而导致Java虚拟机进程终止\n\n某线程调用Runtime类或system类的exit方法，或Runtime类的halt方法，并且Java安全管理器也允许这次exit或halt操作。\n\n\n除此之外，JNI（Java Native Interface）规范描述了用JNI Invocation API来加载或卸载 Java虚拟机时，Java虚拟机的退出情况。\n类加载器\n\n类加载器只负责class文件的加载，至于它是否可以运行，则由Execution Engine（执行引擎）决定。\n加载的类信息存放于一块称为方法区的内存空间。除了类的信息外，方法区中还会存放运行时常量池信息，可能还包括字符串字面量和数字常量（这部分常量信息是Class文件中常量池部分的内存映射）\n说白了，类加载器会把类的详细详细加载到JVM中\n类加载的过程加载阶段\n通过一个类的全限定名获取定义此类的二进制字节流\n\n将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构\n\n在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口\n\n\n补充：加载class文件的方式\n\n从本地系统中直接加载\n\n通过网络获取，典型场景：Web Applet\n\n从zip压缩包中读取，成为日后jar、war格式的基础\n\n运行时计算生成，使用最多的是：动态代理技术\n\n由其他文件生成，典型场景：JSP应用\n\n从专有数据库中提取.class文件，比较少见\n\n从加密文件中获取，典型的防Class文件被反编译的保护措施\n\n\n链接阶段\n验证（Verify）\n\n判断Class文件的字节流是否符合当前虚拟机的规范，保证类的正确性\n\n主要有四种方式：文件格式验证、元数据验证、字节码验证、符号引用验证。\n去查看Class文件的二进制字节码时，你会发现开头几个都是CA FE BA BE这就是一个验证\n\n\n\n准备（Prepare）\n\n会为类中的变量分配内存，并设置初始值，即为0\n不包含用final修饰的static变量，因为final在编译时就分配了，准备阶段会显示初始化\n不会为实例变量初始化，因为实例变量是在对象实例化时随着对象一起分配在java堆中的\n\n\n解析（Resolve）\n\n将常量池内的符号引用转换为直接引用的过程。\n\n事实上，解析操作往往会伴随着JVM在执行完初始化之后再执行。\n\n符号引用就是一组符号来描述所引用的目标。符号引用的字面量形式明确定义在《java虚拟机规范》的Class文件格式中。直接引用就是直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄。\n\n解析动作主要针对类或接口、字段、类方法、接口方法、方法类型等。对应常量池中的CONSTANT_Class_info，CONSTANT_Fieldref_info、CONSTANT_Methodref_info等。\n\n\n\n\n初始化阶段\n初始化阶段就是执行类构造器方法()的过程。此方法不需定义，是javac编译器自动收集类中的所有类变量的赋值动作和静态代码块中的语句合并而来，构造器方法中指令按语句在源文件中出现的顺序执行。ps:方法只在拥有静态变量或静态代码块时才有\n\n()不同于类的构造器（构造方法）。（关联：构造器是虚拟机视角下的()）\n\n若该类具有父类，JVM会保证子类的()执行前，父类的()已经执行完毕。\n\n虚拟机必须保证一个类的()方法在多线程下被同步加锁。(说白了，如果在中如果有死循环之类的，会卡住，多个线程new这个对象的话无法正常运行)\n\n\n类加载器的加载顺序 从下往上\nBootStrap ClassLoader（引导类加载器）：rt.jar\nExtention ClassLoader（扩展类加载器）: 加载扩展的 jar 包\nApp ClassLoader（系统类加载器）：指定的 classpath 下面的 jar 包\nCustom ClassLoader：自定义的类加载器\n\n引导类加载器\n这个类加载使用**C/C++**语言实现的，嵌套在JVM内部。\n\n它用来加载Java的核心库（JAVA_HOME/jre/lib/rt.jar、resources.jar或sun.boot.class.path路径下的内容），用于提供JVM自身需要的类\n\n并不继承自ava.lang.ClassLoader，没有父加载器。\n\n加载扩展类和应用程序类加载器，并指定为他们的父类加载器。\n\n出于安全考虑，Bootstrap启动类加载器只加载包名为java、javax、sun等开头的类\n\n\n扩展类加载器\nJava语言编写，由sun.misc.Launcher$ExtClassLoader实现。\n\n派生于ClassLoader类\n\n父类加载器为启动类加载器（这不是继承，是指它由引导类加载器加载）\n\n从java.ext.dirs系统属性所指定的目录中加载类库，或从JDK的安装目录的jre/lib/ext子目录（扩展目录）下加载类库。如果用户创建的JAR放在此目录下，也会自动由扩展类加载器加载。\n\n\n系统类加载器\njava语言编写，由sun.misc.LaunchersAppClassLoader实现\n\n派生于ClassLoader类\n\n父类加载器为扩展类加载器（这不是继承，是指它由引导类加载器加载）\n\n它负责加载环境变量classpath或系统属性java.class.path指定路径下的类库\n\n该类加载是程序中默认的类加载器，一般来说，Java应用的类都是由它来完成加载\n\n通过ClassLoader.getSystemclassLoader() 方法可以获取到该类加载器\n\n\n自定义类加载器在Java的日常应用程序开发中，类的加载几乎是由上述3种类加载器相互配合执行的，在必要时，我们还可以自定义类加载器，来定制类的加载方式。 为什么要自定义类加载器？\n\n隔离加载类\n\n修改类加载的方式\n\n扩展加载源\n\n防止源码泄漏\n\n\n用户自定义类加载器实现步骤：\n\n开发人员可以通过继承抽象类ava.lang.ClassLoader类的方式，实现自己的类加载器，以满足一些特殊的需求\n\n在JDK1.2之前，在自定义类加载器时，总会去继承ClassLoader类并重写loadClass() 方法，从而实现自定义的类加载类，但是在JDK1.2之后已不再建议用户去覆盖loadclass() 方法，而是建议把自定义的类加载逻辑写在findClass()方法中\n\n在编写自定义类加载器时，如果没有太过于复杂的需求，可以直接继承URLClassLoader类，这样就可以避免自己去编写findClass()  方法及其获取字节码流的方式，使自定义类加载器编写更加简洁。\n\n\n一般情况下了解一下就行了\n双亲委派机制Java虚拟机对class文件采用的是按需加载的方式，也就是说当需要使用该类时才会将它的class文件加载到内存生成class对象。而且加载某个类的class文件时，Java虚拟机采用的是双亲委派模式，即把请求交由父类处理，它是一种任务委派模式\n工作原理\n\n如果一个类加载器收到了类加载请求，它并不会自己先去加载，而是把这个请求委托给父类的加载器去执行；\n\n如果父类加载器还存在其父类加载器，则进一步向上委托，依次递归，请求最终将到达顶层的启动类加载器；\n\n如果父类加载器可以完成类加载任务，就成功返回，倘若父类加载器无法完成此加载任务，子加载器才会尝试自己去加载，这就是双亲委派模式。\n\n\n\n优势\n\n避免类的重复加载\n保护程序安全，防止核心API被随意篡改\n自定义类：java.lang.String\n自定义类：java.lang.ShkStart（报错：阻止创建 java.lang开头的类）\n\n\n\n沙箱安全机制自定义String类，但是在加载自定义String类的时候会率先使用引导类加载器加载，而引导类加载器在加载的过程中会先加载jdk自带的文件（rt.jar包中java\\lang\\String.class），报错信息说没有main方法，就是因为加载的是rt.jar包中的string类。这样可以保证对java核心源代码的保护，这就是沙箱安全机制。\nJava 安全模型的核心就是 Java 沙箱，什么是沙箱？沙箱是一个限制程序运行的环境。沙箱机制就是将 Java 代码限定在虚拟机(JVM)特定的运行范围中，并严格限制代码对本地系统资源的访问，通过这样的措施来保证对代码的隔离，防止对本地系统造成破坏。沙箱主要限制系统资源访问，那系统资源包括什么？——CPU、内存、文件系统、网络。不同级别的沙箱对这些资源访问的限制也可以不一样。详情点击\nJVM运行时数据区我们通过磁盘或者网络IO得到的数据，都需要先加载到内存中，然后CPU从内存中获取数据进行读取，也就是说内存充当了CPU和磁盘之间的桥梁\n\n每个线程：独立包括程序计数器、栈、本地方法栈。\n线程间共享（进程）：堆、堆外内存（永久代或元空间、代码缓存）\n\n线程线程是一个程序里的运行单元。JVM允许一个应用有多个线程并行的执行。 在Hotspot JVM里，每个线程都与操作系统的本地线程直接映射。\n当一个Java线程准备好执行以后，此时一个操作系统的本地线程也同时创建。Java线程执行终止后，本地线程也    会回收。\n操作系统负责所有线程的安排调度到任何一个可用的CPU上。一旦本地线程初始化成功，它就会调用Java线程中的run()方法。\n如果你使用console或者是任何一个调试工具，都能看到在后台有许多线程在运行。这些后台线程不包括调用public static void main(String[] args)的main线程以及所有这个main线程自己创建的线程。\n这些主要的后台系统线程在Hotspot JVM里主要是以下几个：\n\n虚拟机线程：这种线程的操作是需要JVM达到安全点才会出现。这些操作必须在不同的线程中发生的原因是他们都需要JVM达到安全点，这样堆才不会变化。这种线程的执行类型包括”stop-the-world”的垃圾收集，线程栈收集，线程挂起以及偏向锁撤销。\n\n周期任务线程：这种线程是时间周期事件的体现（比如中断），他们一般用于周期性操作的调度执行。\n\nGC线程：这种线程对在JVM里不同种类的垃圾收集行为提供了支持。\n\n编译线程：这种线程在运行时会将字节码编译成到本地代码。\n\n信号调度线程：这种线程接收信号并发送给JVM，在它内部通过调用适当的方法进行处理\n\n\n程序计数器程序计数器：Program counter register\n也可以叫PC寄存器\n每个线程都有一个程序计数器，是线程私有的，就是一直指针，指向下一条指令的地址（指令地址/偏移地址），也就是即将执行的指令，在执行引擎读取下一条指令，是一个非常小的内存空间，几乎可以忽略不记。也是运行速度最快的存储区域。\n任何时间一个线程都只有一个方法在执行，也就是所谓的当前方法。程序计数器会存储当前线程正在执行的Java方法的JVM指令地址；或者，如果是在执行native方法，则是未指定值（undefined）。\n它是程序控制流的指示器，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。\n字节码解释器工时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令。\n它是唯一一个在Java虚拟机规范中没有规定任何OutofMemoryError情况的区域。\n常见面试问题使用PC寄存器储存字节码指令地址有什么用？\n为什么使用PC寄存器记录当前线程的执行地址？\n因为CPU需要不停的切换各个线程，这时候切换回来以后，就得知道接着从哪开始继续执行。\nJVM的字节码解释器就需要通过改变PC寄存器的值来明确下一条应该执行什么样的字节码指令。\n\nPC寄存器为什么被设置为线程私有的？\n我们都知道所谓的多线程在一个特定的时间段内只会执行其中某一个线程的方法，CPU会不停地做任务切换，这样必然导致经常中断或恢复，如何保证分毫无差呢？为了能够准确地记录各个线程正在执行的当前字节码指令地址，最好的办法自然是为每一个线程都分配一个PC寄存器，这样一来各个线程之间便可以进行独立计算，从而不会出现相互干扰的情况。\n由于CPU时间片轮限制，众多线程在并发执行过程中，任何一个确定的时刻，一个处理器或者多核处理器中的一个内核，只会执行某个线程中的一条指令。\n这样必然导致经常中断或恢复，如何保证分毫无差呢？每个线程在创建后，都会产生自己的程序计数器和栈帧，程序计数器在各个线程之间互不影响。\nJAVA栈由于跨平台性的设计，Java的指令都是根据栈来设计的，不同平台CPU架构不同，所以不能设计为基于寄存器。\n优点：跨平台、指令集小、编译器容易实现\n缺点：性能下降、实现同样的功能需要更多指令\n栈是运行时的单位，而堆是存储的单位\n\n栈解决程序的运行问题，即程序如何执行，或者说如何处理数据。\n\n堆解决的是数据存储的问题，即数据怎么放，放哪里\n\n\n每个线程都会创建一个Java栈，其内部保存一个个栈帧，对应着一次次Java方法的调用\n线程创建的时候会创建，生命周期和线程生命周期一样，线程结束栈也就释放了，描述的是 Java 方法执行的内存模型：每个方法在执行时都会创建一个栈帧(Stack Frame)用于存储局部变量表、操作数栈、动态链接、方法出口等信息。每一个方法从调用直至执行结束，就对应着一个栈帧从虚拟机栈中入栈到出栈的过程。\n主管Java程序的运行，它保存方法的局部变量、部分结果，并参与方法的调用和返回。\nJVM对Java栈只有进栈和出栈两个操作，不存在垃圾回收\n对于栈来说不存在垃圾回收问题（栈存在溢出的情况）\n栈中可能出现的异常\nJava 虚拟机规范允许Java栈的大小是动态的或者是固定不变的。\n\n如果采用固定大小的Java虚拟机栈，那每一个线程的Java虚拟机栈容量可以在线程创建的时候独立选定。如果线程请求分配的栈容量超过Java虚拟机栈允许的最大容量，Java虚拟机将会抛出一个StackOverflowError 异常。\n\n如果Java虚拟机栈可以动态扩展，并且在尝试扩展的时候无法申请到足够的内存，或者在创建新的线程时没有足够的内存去创建对应的虚拟机栈，那Java虚拟机将会抛出一个 OutOfMemoryError 异常。\n\n\n设置栈内存大小\n我们可以使用参数 -Xss选项来设置线程的最大栈空间，栈的大小直接决定了函数调用的最大可达深度\nJava方法有两种返回函数的方式，一种是正常的函数返回，使用return指令；另外一种是抛出异常。不管使用哪种方式，都会导致栈帧被弹出。\n栈帧的内部结构每个栈帧中存储着：\n\n局部变量表（Local Variables）\n\n操作数栈（operand Stack）（或表达式栈）\n\n动态链接（DynamicLinking）（或指向运行时常量池的方法引用）\n\n方法返回地址（Return Address）（或方法正常退出或者异常退出的定义）\n\n一些附加信息\n\n\n\n\n局部变量表(Local Variables)局部变量表也被称之为局部变量数组或本地变量表\n\n定义为一个数字数组，主要用于存储方法参数和定义在方法体内的局部变量，这些数据类型包括各类基本数据类型、对象引用（reference），以及returnAddress类型。\n\n由于局部变量表是建立在线程的栈上，是线程的私有数据，因此不存在数据安全问题\n\n局部变量表所需的容量大小是在编译期确定下来的，并保存在方法的Code属性的maximum local variables数据项中。在方法运行期间是不会改变局部变量表的大小的。\n\n方法嵌套调用的次数由栈的大小决定。一般来说，栈越大，方法嵌套调用次数越多。对一个函数而言，它的参数和局部变量越多，使得局部变量表膨胀，它的栈帧就越大，以满足方法调用所需传递的信息增大的需求。进而函数调用就会占用更多的栈空间，导致其嵌套调用次数就会减少。\n\n局部变量表中的变量只在当前方法调用中有效。在方法执行时，虚拟机通过使用局部变量表完成参数值到参数变量列表的传递过程。当方法调用结束后，随着方法栈帧的销毁，局部变量表也会随之销毁。\n\n\n关于Solt的理解\n\n在局部变量表中最基本的存储单元是Slot（变量槽）\n\n参数值的存放总是在局部变量数组的index0开始，到数组长度-1的索引结束。\n\n局部变量表中存放编译期可知的各种基本数据类型（8种），引用类型（reference），returnAddress类型的变量。\n\n在局部变量表里，32位以内的类型只占用一个slot（包括returnAddress类型），64位的类型（long和double）占用两个slot。\n\nbyte、short、char 在存储前被转换为int，boolean也被转换为int，0表示false，非0表示true。\nlong和double则占据两个solt\n\n\nJVM会为局部变量表中的每一个Slot都分配一个访问索引，通过这个索引即可成功访问到局部变量表中指定的局部变量值\n\n当一个实例方法被调用的时候，它的方法参数和方法体内部定义的局部变量将会按照顺序被复制到局部变量表中的每一个slot上\n\n如果需要访问局部变量表中一个64bit的局部变量值时，只需要使用前一个索引即可。（比如：访问long或doub1e类型变量）\n\n如果当前帧是由构造方法或者实例方法创建的，那么该对象引用this将会存放在index为0的slot处，其余的参数按照参数表顺序继续排列。\n\n\n\n\n在栈帧中，与性能调优关系最为密切的部分就是前面提到的局部变量表。在方法执行时，虚拟机使用局部变量表完成方法的传递。\n局部变量表中的变量也是重要的垃圾回收根节点，只要被局部变量表中直接或间接引用的对象都不会被回收。\n操作数栈(Operand Stack)每一个独立的栈帧除了包含局部变量表以外，还包含一个后进先出（Last-In-First-Out）的操作数栈，也可以称之为表达式栈（Expression Stack）\n操作数栈，在方法执行过程中，根据字节码指令，往栈中写入数据或提取数据，即入栈（push）和 出栈（pop）\n\n某些字节码指令将值压入操作数栈，其余的字节码指令将操作数取出栈。使用它们后再把结果压入栈\n\n比如：执行复制、交换、求和等操作\n\n\n\n操作数栈，主要用于保存计算过程的中间结果，同时作为计算过程中变量临时的存储空间。\n操作数栈就是JVM执行引擎的一个工作区，当一个方法刚开始执行的时候，一个新的栈帧也会随之被创建出来，这个方法的操作数栈是空的。\n每一操作数栈都会拥有一个明确的栈深度用于存储数值，其所需的最大深度在编译期就定义好了，保存在方法的Code属性中，为max_stack的值。\n栈中的任何一个元素都是可以任意的Java数据类型\n\n32bit的类型占用一个栈单位深度\n\n64bit的类型占用两个栈单位深度\n\n\n操作数栈并非采用访问索引的方式来进行数据访问的(虽然操作数栈是通过数组实现的)，而是只能通过标准的入栈和出栈操作来完成一次数据访问\n如果被调用的方法带有返回值的话，其返回值将会被压入当前栈帧的操作数栈中，并更新PC寄存器中下一条需要执行的字节码指令。\n操作数栈中元素的数据类型必须与字节码指令的序列严格匹配，这由编译器在编译器期间进行验证，同时在类加载过程中的类检验阶段的数据流分析阶段要再次验证。\n另外，我们说Java虚拟机的解释引擎是基于栈的执行引擎，其中的栈指的就是操作数栈。\n详情图文\n动态链接(DynamicLinking)动态链接、方法返回地址、附加信息 ： 有些地方被称为帧数据区\n每一个栈帧内部都包含一个指向运行时常量池中该栈帧所属方法的引用。包含这个引用的目的就是为了支持当前方法的代码能够实现动态链接（Dynamic Linking）。比如：invokedynamic指令\n在Java源文件被编译到字节码文件中时，所有的变量和方法引用都作为符号引用（Symbolic Reference）保存在class文件的常量池里。比如：描述一个方法调用了另外的其他方法时，就是通过常量池中指向方法的符号引用来表示的，那么动态链接的作用就是为了将这些符号引用转换为调用方法的直接引用。\n\n\n为什么需要运行时常量池呢？\n常量池的作用：就是为了提供一些符号和常量，便于指令的识别\n方法返回地址(Return Address)存放调用该方法的pc寄存器的值。一个方法的结束，有两种方式：\n\n正常执行完成\n\n出现未处理的异常，非正常退出\n\n\n无论通过哪种方式退出，在方法退出后都返回到该方法被调用的位置。方法正常退出时，调用者的pc计数器的值作为返回地址，即调用该方法的指令的下一条指令的地址。而通过异常退出的，返回地址是要通过异常表来确定，栈帧中一般不会保存这部分信息。\n当一个方法开始执行后，只有两种方式可以退出这个方法：\n\n执行引擎遇到任意一个方法返回的字节码指令（return），会有返回值传递给上层的方法调用者，简称正常完成出口；\n\n\n\n一个方法在正常调用完成之后，究竟需要使用哪一个返回指令，还需要根据方法返回值的实际数据类型而定。\n\n\n\n在字节码指令中，返回指令包含ireturn（当返回值是boolean，byte，char，short和int类型时使用），lreturn（Long类型），freturn（Float类型），dreturn（Double类型），areturn。另外还有一个return指令声明为void的方法，实例初始化方法，类和接口的初始化方法使用\n\n\n\n\n在方法执行过程中遇到异常（Exception），并且这个异常没有在方法内进行处理，也就是只要在本方法的异常表中没有搜索到匹配的异常处理器，就会导致方法退出，简称异常完成出口。\n\n方法执行过程中，抛出异常时的异常处理，存储在一个异常处理表，方便在发生异常的时候找到处理异常的代码\nException table:\nfrom to target type\n4    16   19   any\n19   21   19   any\n\n本质上，方法的退出就是当前栈帧出栈的过程。此时，需要恢复上层方法的局部变量表、操作数栈、将返回值压入调用者栈帧的操作数栈、设置PC寄存器值等，让调用者方法继续执行下去。\n正常完成出口和异常完成出口的区别在于：通过异常完成出口退出的不会给他的上层调用者产生任何的返回值。\n一些附加信息栈帧中还允许携带与Java虚拟机实现相关的一些附加信息。例如：对程序调试提供支持的信息。\n栈面试题\n举例栈溢出的情况？（StackOverflowError）-&gt;方法调用过多，堆满了栈空间\n\n\n通过 -Xss设置栈的大小\n\n\n调整栈大小，就能保证不出现溢出么？\n\n\n不能保证不溢出\n\n\n分配的栈内存越大越好么？\n\n\n不是，一定时间内降低了OOM概率，但是会挤占其它的线程空间，因为整个空间是有限的。\n\n\n垃圾回收是否涉及到虚拟机栈？\n\n\n不会\n\n\n方法中定义的局部变量是否线程安全？-&gt;看实际情况\n\n\n具体问题具体分析。如果对象是在内部产生，并在内部消亡，没有返回到外部，那么它就是线程安全的，反之则是线程不安全的。\n\n\n\n\n\n\n运行时数据区\n是否存在Error\n是否存在GC\n\n\n\n程序计数器\n否\n否\n\n\n虚拟机栈\n是（SOE）\n否\n\n\n本地方法栈\n是\n否\n\n\n方法区\n是（OOM）\n是\n\n\n堆\n是\n是\n\n\n本地方法接口本地方法本地接口 简称 JNI：Java Native Interface\n简单地讲，一个Native Method是一个Java调用非Java代码的接囗。一个Native Method是这样一个Java方法：该方法的实现由非Java语言实现，比如C。这个特征并非Java所特有，很多其它的编程语言都有这一机制，比如在C中，你可以用extern “c” 告知c编译器去调用一个c的函数。\n\nA native method is a Java method whose implementation is provided by non-java code.\n\n在定义一个native method时，并不提供实现体（有些像定义一个Java interface），因为其实现体是由非java语言在外面实现的。\n本地接口的作用是融合不同的编程语言为Java所用，它的初衷是融合C/C++程序。\n举例\npublic class IHaveNatives&#123;\n    public native void methodNative1(int x);\n    public native static long methodNative2();\n    private native synchronized float methodNative3(Object o);\n    native void methodNative4(int[] ary) throws Exception;\n&#125;\n\n标识符native可以与其它java标识符连用，但是abstract除外\n为什么使用Native Method？\nJava使用起来非常方便，然而有些层次的任务用Java实现起来不容易，或者我们对程序的效率很在意时，问题就来了。\n与Java环境的交互\n有时Java应用需要与Java外面的环境交互，这是本地方法存在的主要原因。你可以想想Java需要与一些底层系统，如操作系统或某些硬件交换信息时的情况。本地方法正是这样一种交流机制：它为我们提供了一个非常简洁的接口，而且我们无需去了解Java应用之外的繁琐的细节。\n与操作系统的交互\nJVM支持着Java语言本身和运行时库，它是Java程序赖以生存的平台，它由一个解释器（解释字节码）和一些连接到本地代码的库组成。然而不管怎样，它毕竟不是一个完整的系统，它经常依赖于一底层系统的支持。这些底层系统常常是强大的操作系统。通过使用本地方法，我们得以用Java实现了jre的与底层系统的交互，甚至JVM的一些部分就是用c写的。还有，如果我们要使用一些Java语言本身没有提供封装的操作系统的特性时，我们也需要使用本地方法。\nSun’s Java\nSun的解释器是用C实现的，这使得它能像一些普通的C一样与外部交互。jre大部分是用Java实现的，它也通过一些本地方法与外界交互。例如：类java.lang.Thread的setPriority()方法是用Java实现的，但是它实现调用的是该类里的本地方法setPriority()。这个本地方法是用C实现的，并被植入JVM内部，在Windows 95的平台上，这个本地方法最终将调用Win32 setPriority() ApI。这是一个本地方法的具体实现由JVM直接提供，更多的情况是本地方法由外部的动态链接库（external dynamic link library）提供，然后被JVw调用。\n现状\n目前该方法使用的越来越少了，除非是与硬件有关的应用，比如通过Java程序驱动打印机或者Java系统管理生产设备，在企业级应用中已经比较少见。因为现在的异构领域间的通信很发达，比如可以使用Socket通信，也可以使用Web Service等等，不多做介绍。\n本地方法栈Java虚拟机栈于管理Java方法的调用，而本地方法栈用于管理本地方法的调用。\n本地方法栈，也是线程私有的。\n允许被实现成固定或者是可动态扩展的内存大小。（在内存溢出方面是相同的）\n\n如果线程请求分配的栈容量超过本地方法栈允许的最大容量，Java虚拟机将会抛出一个StackOverflowError 异常。\n\n如果本地方法栈可以动态扩展，并且在尝试扩展的时候无法申请到足够的内存，或者在创建新的线程时没有足够的内存去创建对应的本地方法栈，那么Java虚拟机将会抛出一个OutOfMemoryError异常。\n\n\n本地方法是使用C语言实现的。\n它的具体做法是Native Method Stack中登记native方法，在Execution Engine 执行时加载本地方法库。\n\n\n当某个线程调用一个本地方法时，它就进入了一个全新的并且不再受虚拟机限制的世界。它和虚拟机拥有同样的权限。\n\n本地方法可以通过本地方法接口来访问虚拟机内部的运行时数据区。\n\n它甚至可以直接使用本地处理器中的寄存器\n\n直接从本地内存的堆中分配任意数量的内存。\n\n\n并不是所有的JVM都支持本地方法。因为Java虚拟机规范并没有明确要求本地方法栈的使用语言、具体实现方式、数据结构等。如果JVM产品不打算支持native方法，也可以无需实现本地方法栈。\n在Hotspot JVM中，直接将本地方法栈和虚拟机栈合二为一。\n堆Heap，一个 JVM 只有一个堆内存，堆内存的大小是可以调节的。\nJava虚拟机用来存储对象实例用的，在我们开发中，只要通过new创建的对象都分配在堆中，注意堆中的对象内存需要等待GC回收，也是Java虚拟机线程共享区域，内部会划分出多个线程私有的分配缓冲区（Thread Local Allocation Buffer，TLAB）。\n类加载器读取了类文件后，一般会把 类、方法、常量、变量、保存我们所有引用类型的真实对象\n堆内存中还要细分为三个区域：\n\n新生区（伊甸园区）\n养老区\n元空间/永久区\n\n\nGC 垃圾回收，主要是在伊甸园和养老区\n假设内存满了，OOM，堆内存不够\nJDK 8 中永久区向元空间的转换的原因：\n\n1、字符串存在永久代中，容易出现性能问题和内存溢出。\n2、类及方法的信息等比较难确定其大小，因此对于永久代的大小指定比较困难，太小容易出现永久代溢出，太大则容易导致老年代溢出。\n3、永久代会为 GC 带来不必要的复杂度，并且回收效率偏低。\n4、Oracle 可能会将 HotSpot 与 JRockit 合二为一。\n\n设置堆空间大小Java堆区用于存储Java对象实例，那么堆的大小在JVM启动时就已经设定好了，大家可以通过选项”-Xmx”和”-Xms”来进行设置。\n\n“-Xms”用于表示堆区的起始内存，等价于-XX:InitialHeapSize\n\n-X 是jvm的运行参数\nms 是memory start\n\n\n“-Xmx”则用于表示堆区的最大内存，等价于-XX:MaxHeapSize\n\n\n一旦堆区中的内存大小超过“-Xmx”所指定的最大内存时，将会抛出OutOfMemoryError异常。\n通常会将-Xms和-Xmx两个参数配置相同的值，其目的是为了能够在ava垃圾回收机制清理完堆区后不需要重新分隔计算堆区的大小，从而提高性能。\n默认情况下\n\n初始内存大小：物理电脑内存大小 / 64\n\n最大内存大小：物理电脑内存大小 / 4\n\n\n\n存储在JVM中的Java对象可以被划分为两类：\n\n一类是生命周期较短的瞬时对象，这类对象的创建和消亡都非常迅速\n\n另外一类对象的生命周期却非常长，在某些极端的情况下还能够与JVM的生命周期保持一致\n\n\nJava堆区进一步细分的话，可以划分为年轻代（YoungGen）和老年代（oldGen）\n其中年轻代又可以划分为Eden空间、Survivor0空间和Survivor1空间（有时也叫做from区、to区）\n\n配置新生代与老年代在堆结构的占比。\n\n默认-XX:NewRatio=2，表示新生代占1，老年代占2，新生代占整个堆的1/3\n\n可以修改-XX:NewRatio=4，表示新生代占1，老年代占4，新生代占整个堆的1/5\n\n\n在HotSpot中，Eden空间和另外两个survivor空间所占的比例是8：1：1\n但是实际情况下，不会严格按照8：1：1进行分配，它会有一个自适应的过程\n当然开发人员可以通过选项-xx:SurvivorRatio调整这个空间比例。比如-xx:SurvivorRatio=8，这样调整的话就会严格执行8：1：1\n几乎所有的Java对象都是在Eden区被new出来的。绝大部分的Java对象的销毁都在新生代进行了。\n\nIBM公司专门研究表明，新生代中80%的对象都是“朝生夕死”的。\n\n可以使用选项-Xmn设置新生代最大内存大小，这个参数一般使用默认值就可以了。\n对象分配过程为新对象分配内存是一件非常严谨和复杂的任务，JVM的设计者们不仅需要考虑内存如何分配、在哪里分配等问题，并且由于内存分配算法与内存回收算法密切相关，所以还需要考虑GC执行完内存回收后是否会在内存空间中产生内存碎片。\n\nnew的对象先放伊甸园区。此区有大小限制。 \n当伊甸园的空间填满时，程序又需要创建对象，JVM的垃圾回收器将对伊甸园区进行垃圾回收（MinorGC），将伊甸园区中的不再被其他对象所引用的对象进行销毁。再加载新的对象放到伊甸园区 \n然后将伊甸园中的剩余对象移动到幸存者0区。 \n如果再次触发垃圾回收，此时上次幸存下来的放到幸存者0区的，如果没有回收，就会放到幸存者1区。 \n如果再次经历垃圾回收，此时会重新放回幸存者0区，接着再去幸存者1区。 \n啥时候能去养老区呢？可以设置次数。默认是15次。 \n可以设置参数：进行设置-Xx:MaxTenuringThreshold= N\n\n\n在养老区，相对悠闲。当养老区内存不足时，再次触发GC：Major GC，进行养老区的内存清理 \n若养老区执行了Major GC之后，发现依然无法进行对象的保存，就会产生OOM异常。  \n\n\n总结：针对幸存者 s0,s1 区：复制之后有交换，谁空谁是 to。\n关于垃圾回收：频繁在新生区收集，很少在养老区收集，几乎不再永久区/元空间收集。\n注意：只有伊甸园满了才会触轻 GC,而幸存者区满了是绝对不会触发轻 GC 的。\nMinor GC,MajorGC,Full GCJVM在进行GC时，并非每次都对上面三个内存区域一起回收的，大部分时候回收的都是指新生代。\n针对Hotspot VM的实现，它里面的GC按照回收区域又分为两大种类型：一种是部分收集（Partial GC），一种是整堆收集（FullGC）\n\n部分收集：不是完整收集整个Java堆的垃圾收集。其中又分为： \n\n新生代收集（Minor GC / Young GC）：只是新生代的垃圾收集\n老年代收集（Major GC / Old GC）：只是老年代的圾收集。 \n目前，只有CMSGC会有单独收集老年代的行为。\n注意，很多时候Major GC会和Full GC混淆使用，需要具体分辨是老年代回收还是整堆回收。\n\n\n混合收集（MixedGC）：收集整个新生代以及部分老年代的垃圾收集。 \n目前，只有G1 GC会有这种行为\n\n\n\n\n整堆收集（Full GC）：收集整个java堆和方法区的垃圾收集。\n\n\n永久区这个区域常驻内存的，用来存放 jdk 自身携带的 Class 对象，interfac 元数据，存储的是 java 运行时的环境，这个区域不存在垃圾回收，关闭 vm 虚拟机的时候会释放这个区域的内存。\n如果一个启动类，加载了大量第三方 jar 包，tomcat 部署了太多的应用，大量动态生成的反射类，不断的被加载，直到内存满，就会出现 OOM\n\njdk1.6 之前：永久代，常量池在方法区\njdk1.7：永久代，但是慢慢退化，去永久代，常量池在堆中\njdk1.8 之后：无永久代，常量池在元空间\n\n元空间在逻辑上存在，物理上不存在（也可以说它存在于本地内存，不占用堆内存）\n总结//vm常用参数 可以调整堆内存 和 打印信息\n-XX:+PrintFlagsInitial 查看所有参数的默认初始值\n-XX:+PrintFlagsFinal 查看所有参数的最终值\n-Xms 设置初始化内存分配大小 默认1/64\n-Xmx 设置最大分配内存 默认1/4\n-Xmn 设置新生代的大小\n-XX:NewRatio 设置新生代和老年代在堆中的结构比例\n-XX:SurvivorRatio 设置新生代中Eden和s0/s1空间比例\n-XX:MaxTenuringThreshold 设置新生代垃圾的最大年龄\n-XX:+PrintGCDetails 打印GC垃圾回收信息\n//打印GC简要信息\n    1. -XX:+PrintGC\n    2. -verbose:gc\n-XX:HandlePromotionFalilure：//是否设置空间分配担保\n-Xms8m -Xmx8m -XX:+PrintGCDetails\n\n空间分配担保策略\n在发生Minor GC之前，虚拟机会检查老年代最大可用的连续空间是否大于新生代所有对象的总空间。\n\n如果大于，则此次Minor GC是安全的\n\n如果小于，则虚拟机会查看-XX:HandlePromotionFailure设置值是否允担保失败。 \n\n如果HandlePromotionFailure=true，那么会继续检查老年代最大可用连续空间是否大于历次晋升到老年代的对象的平均大小。 \n如果大于，则尝试进行一次Minor GC，但这次Minor GC依然是有风险的；\n如果小于，则改为进行一次Full GC。\n\n\n如果HandlePromotionFailure=false，则改为进行一次Full Gc。\n\n\n\n在JDK6 Update24之后，HandlePromotionFailure参数不会再影响到虚拟机的空间分配担保策略，观察openJDK中的源码变化，虽然源码中还定义了HandlePromotionFailure参数，但是在代码中已经不会再使用它。JDK6 Update 24之后的规则变为只要老年代的连续空间大于新生代对象总大小或者历次晋升的平均大小就会进行Minor GC，否则将进行FullGC。\n逃逸分析:代码优化使用逃逸分析，编译器可以对代码做如下优化：\n栈上分配将堆分配转化为栈分配。如果一个对象在子程序中被分配，要使指向该对象的指针永远不会发生逃逸，对象可能是栈上分配的候选，而不是堆上分配\n\nJIT编译器在编译期间根据逃逸分析的结果，发现如果一个对象并没有逃逸出方法的话，就可能被优化成栈上分配。分配完成后，继续在调用栈内执行，最后线程结束，栈空间被回收，局部变量对象也被回收。这样就无须进行垃圾回收了。\n\n\n常见的栈上分配的场景\n\n\n在逃逸分析中，已经说明了。分别是给成员变量赋值、方法返回值、实例引用传递。\n\n同步省略如果一个对象被发现只有一个线程被访问到，那么对于这个对象的操作可以不考虑同步。\n\n线程同步的代价是相当高的，同步的后果是降低并发性和性能。\n\n\n在动态编译同步块的时候，JIT编译器可以借助逃逸分析来判断同步块所使用的锁对象是否只能够被一个线程访问而没有被发布到其他线程。如果没有，那么JIT编译器在编译这个同步块的时候就会取消对这部分代码的同步。这样就能大大提高并发性和性能。这个取消同步的过程就叫同步省略，也叫锁消除。\n\n分离对象/标量替换有的对象可能不需要作为一个连续的内存结构存在也可以被访问到，那么对象的部分（或全部）可以不存储在内存，而是存储在CPU寄存器中。\n\n标量（scalar）是指一个无法再分解成更小的数据的数据。Java中的原始数据类型就是标量。\n\n\n相对的，那些还可以分解的数据叫做聚合量（Aggregate），Java中的对象就是聚合量，因为他可以分解成其他聚合量和标量。\n\n\n在JIT阶段，如果经过逃逸分析，发现一个对象不会被外界访问的话，那么经过JIT优化，就会把这个对象拆解成若干个其中包含的若干个成员变量来代替。这个过程就是标量替换。\n\n举例\npublic static void main(String args[]) &#123;\n    alloc();\n&#125;\nprivate static void alloc() &#123;\n    Point point = new Point(1,2);\n    System.out.println(\"point.x\" + point.x + \";point.y\" + point.y);\n&#125;\nclass Point &#123;\n    private int x;\n    private int y;\n&#125;\n\n以上代码，经过标量替换后，就会变成\nprivate static void alloc() &#123;\n    int x = 1;\n    int y = 2;\n    System.out.println(\"point.x = \" + x + \"; point.y=\" + y);\n&#125;\n\n可以看到，Point这个聚合量经过逃逸分析后，发现他并没有逃逸，就被替换成两个标量了。那么标量替换有什么好处呢？就是可以大大减少堆内存的占用。因为一旦不需要创建对象了，那么就不再需要分配堆内存了。 标量替换为栈上分配提供了很好的基础。\n标量替换参数设置\n参数-XX:EliminateAllocations：开启了标量替换（默认打开），允许将对象打散分配到栈上。\n总结关于逃逸分析的论文在1999年就已经发表了，但直到JDK1.6才有实现，而且这项技术到如今也并不是十分成熟。\n其根本原因就是无法保证逃逸分析的性能消耗一定能高于他的消耗。虽然经过逃逸分析可以做标量替换、栈上分配、和锁消除。但是逃逸分析自身也是需要进行一系列复杂的分析的，这其实也是一个相对耗时的过程。 \n一个极端的例子，就是经过逃逸分析之后，发现没有一个对象是不逃逸的。那这个逃逸分析的过程就白白浪费掉了。\n虽然这项技术并不十分成熟，但是它也是即时编译器优化技术中一个十分重要的手段。\n注意到有一些观点，认为通过逃逸分析，JVM会在栈上分配那些不会逃逸的对象，这在理论上是可行的，但是取决于JVM设计者的选择。据我所知，Oracle Hotspot JVM中并未这么做，这一点在逃逸分析相关的文档里已经说明，所以可以明确所有的对象实例都是创建在堆上。\n多书籍还是基于JDK7以前的版本，JDK已经发生了很大变化，intern字符串的缓存和静态变量曾经都被分配在永久代上，而永久代已经被元数据区取代。但是，intern字符串缓存和静态变量并不是被转移到元数据区，而是直接在堆上分配，所以这一点同样符合前面一点的结论：对象实例都是分配在堆上。\n方法区Method area 方法区\n《Java虚拟机规范》中明确说明：“尽管所有的方法区在逻辑上是属于堆的一部分，但一些简单的实现可能不会选择去进行垃圾收集或者进行压缩。”但对于HotSpotJVM而言，方法区还有一个别名叫做Non-Heap（非堆），目的就是要和堆分开。\n所以，方法区看作是一块独立于Java堆的内存空间。\n\n方法区（Method Area）与Java堆一样，是各个线程共享的内存区域。\n\n方法区在JVM启动的时候被创建，并且它的实际的物理内存空间中和Java堆区一样都可以是不连续的。\n\n方法区的大小，跟堆空间一样，可以选择固定大小或者可扩展。\n\n方法区的大小决定了系统可以保存多少个类，如果系统定义了太多的类，导致方法区溢出，虚拟机同样会抛出内存溢出错误：java.lang.OutOfMemoryError: PermGen space 或者java.lang.OutOfMemoryError: Metaspace \n\n加载大量的第三方的jar包；Tomcat部署的工程过多（30~50个）；大量动态的生成反射类\n\n\n关闭JVM就会释放这个区域的内存。\n\n\n在jdk7及以前，习惯上把方法区，称为永久代。到了JDK8，终于完全废弃了永久代的概念，改用与JRockit、J9一样在本地内存中实现的元空间（Metaspace）来代替\n元空间的本质和永久代类似，都是对JVM规范中方法区的实现。不过元空间与永久代最大的区别在于：元空间不在虚拟机设置的内存中，而是使用本地内存\n设置方法区大小方法区的大小不是固定的,jvm可以根据需求动态调整.\njdk7及以前\n\n通过来设置永久代初始分配空间。默认值是20.75M-XX:Permsize\n\n通过来设定永久代最大可分配空间。32位机器默认是64M，64位机器模式是82M-XX:MaxPermsize\n\n当JVM加载的类信息容量超过了这个值，会报异常OutOfMemoryError:PermGen space。\n\n\njdk8以后\n\n元数据区大小可以使用参数 -XX:MetaspaceSize 和 -XX:MaxMetaspaceSize指定\n\n默认值依赖于平台。windows下，-XX:MetaspaceSize=21M -XX:MaxMetaspaceSize=-1//即没有限制。\n\n与永久代不同，如果不指定大小，默认情况下，虚拟机会耗尽所有的可用系统内存。如果元数据区发生溢出，虚拟机一样会抛出异常OutOfMemoryError:Metaspace\n\n-XX:MetaspaceSize：设置初始的元空间大小。对于一个64位的服务器端JVM来说，其默认的-XX:MetaspaceSize值为21MB。这就是初始的高水位线，一旦触及这个水位线，Full GC将会被触发并卸载没用的类（即这些类对应的类加载器不再存活），然后这个高水位线将会重置。新的高水位线的值取决于GC后释放了多少元空间。如果释放的空间不足，那么在不超过MaxMetaspaceSize时，适当提高该值。如果释放空间过多，则适当降低该值。\n\n如果初始化的高水位线设置过低，上述高水位线调整情况会发生很多次。通过垃圾回收器的日志可以观察到Full GC多次调用。为了避免频繁地GC，建议将-XX:MetaspaceSize设置为一个相对较高的值。\n\n\n方法区的内部结构\n方法区（Method Area）与Java堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载 的类型信息、常量、静态变量、即时编译器编译后的代码缓存等数据。                                                                                                                                                                                                                    \n\n\n类信息对于每个加载的类型(类class、接口interface、枚举enum、注解annotation),JVM必须在方法区中存储一下类型信息:\n\n类型的完整有效名称(包名.类名)\n类型直接父类的完整有效名(对于interface或是java.lang.object，都没有父类)\n类型的修饰符(public，abstract，final的某个子集)\n类型直接接口的一个有序列表\n\n域(Field)信息JVM必须在方法区中保存类型的所有域的相关信息以及域的声明顺序\n域的相关信息包括: 域名称、域类型、域修饰符(public，private，protected，static，final，volatile，transient的某个子集)\n方法(Method)信息JVM必须保存所有方法的一下信息,同域信息一样包括声明顺序:\n\n方法名称\n方法返回类型(或void)\n方法参数的数量和类型(按顺序)\n方法的修饰符(public，private，protected，static，final，synchronized，native，abstract的一个子集)\n方法的字节码(bytecodes)、操作数栈、局部变量表及大小(abstract和native方法除外)\n异常表(abstract和native方法除外)\n每个异常处理的开始位置、结束位置、代码处理在程序计数器中的偏移地址、被捕获的异常类的常量池索引\n\n\n\nnon-final的类变量\n静态变量和类关联在一起，随着类的加载而加载，他们成为类数据在逻辑上的一部分\n\n类变量被类的所有实例共享，即使没有类实例时，你也可以访问它\n\n\npublic class MethodAreaTest &#123;\n    public static void main(String[] args) &#123;\n        Order order = new Order();\n        order.hello();\n        System.out.println(order.count);\n    &#125;\n&#125;\nclass Order &#123;\n    public static int count = 1;\n    public static void hello() &#123;\n        System.out.println(\"hello!\");\n    &#125;\n&#125;\n\n补充说明：全局常量（static final）被声明为final的类变量的处理方法则不同，每个全局常量在编译的时候就会被分配了。\n运行时常量池/常量池\n方法区，内部包含了运行时常量池\n\n字节码文件，内部包含了常量池\n\n要弄清楚方法区，需要理解清楚ClassFile，因为加载类的信息都在方法区。\n\n要弄清楚方法区的运行时常量池，需要理解清楚ClassFile中的常量池。\n\n\n官方文档：https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html\n\n常量池一个java源文件中的类、接口，编译后产生一个字节码文件。而Java中的字节码需要数据支持，通常这种数据会很大以至于不能直接存到字节码里，换另一种方式，可以存到常量池，这个字节码包含了指向常量池的引用。在动态链接的时候会用到运行时常量池，之前有介绍。\n主要包含数据类型为:\n\n数量值\n字符串值\n类引用\n字段引用\n方法引用\n\n总结:常量池、可以看做是一张表，虚拟机指令根据这张常量表找到要执行的类名、方法名、参数类型、字面量等类型\n运行时常量池\n运行时常量池（Runtime Constant Pool）是方法区的一部分。\n\n常量池表（Constant Pool Table）是Class文件的一部分，用于存放编译期生成的各种字面量与符号引用，这部分内容将在类加载后存放到方法区的运行时常量池中。\n\n运行时常量池，在加载类和接口到虚拟机后，就会创建对应的运行时常量池。\n\nJVM为每个已加载的类型（类或接口）都维护一个常量池。池中的数据项像数组项一样，是通过索引访问的。\n\n运行时常量池中包含多种不同的常量，包括编译期就已经明确的数值字面量，也包括到运行期解析后才能够获得的方法或者字段引用。此时不再是常量池中的符号地址了，这里换为真实地址。\n\n运行时常量池，相对于Class文件常量池的另一重要特征是：具备动态性。\n\n运行时常量池类似于传统编程语言中的符号表（symboltable），但是它所包含的数据却比符号表要更加丰富一些。\n\n当创建类或接口的运行时常量池时，如果构造运行时常量池所需的内存空间超过了方法区所能提供的最大值，则JVM会抛OutOfMemoryError异常。\n\n\n方法区的演化\n\n\nJDK1.6及之前\n有永久代(Permanent Generation),静态变量存放在永久代上\n\n\n\nJDK1.7\n有永久代,但已经逐步’去永久代’,字符串常量池、静态变量移除,保存在堆中\n\n\nJDK1.8及之后\n无永久代,类型信息、字段、方法、常量保存在本地内存的元空间,但字符串常量池、静态变量仍在堆\n\n\n\n\n\n\n\n\n方法区的垃圾回收有些人认为方法区（如Hotspot虚拟机中的元空间或者永久代）是没有垃圾回收的,非也,《Java虚拟机规范》对方法区的约束是非常宽松的，提到过可以不要求虚拟机在方法区中实现垃圾收集。事实上也确实有未实现或未能完整实现方法区类型卸载的收集器存在（如JDK11时期的zGC收集器就不支持类卸载）.\n一般来说方法区中的回收效果难以令人满意,尤其是卸载类型,条件苛刻,但是这区域的回收有时又是必要的.以前sun公司的Bug列表中，曾出现过的若干个严重的Bug就是由于低版本的HotSpot虚拟机对此区域未完全回收而导致内存泄漏.\n方法区的垃圾收集只要针对两部分: 常量池中的废弃常量和不在使用的类型.\n先来说说方法区内常量池之中主要存放的两大类常量：字面量和符号引用。字面量比较接近Java语言层次的常量概念，如文本字符串、被声明为final的常量值等。而符号引用则属于编译原理方面的概念，包括下面三类常量：\n\n类和接口的全限定名\n\n字段的名称和描述符\n\n方法的名称和描述符\n\n\nHotSpot虚拟机对常量池的回收策略是很明确的，只要常量池中的常量没有被任何地方引用，就可以被回收。\n回收废弃常量和回收Java堆中的对象非常相似.\n判断常量是否”废弃”相对简单,但是要判定应该类型是否属于”不在被使用的类”的条件就十分苛刻,必须同时满足下列三个条件:\n\n 该类所有的实例都已经被回收，也就是Java堆中不存在该类及其任何派生子类的实例。 \n 加载该类的类加载器已经被回收，这个条件除非是经过精心设计的可替换类加载器的场景，如OSGi、JSP的重加载等，否则通常是很难达成的。 \n 该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。 \n\nJava虚拟机允许对满足上述三个条件的无用类进行回收,也止步于”被允许”,而不是像对象一样,没有引用就必然被回收,关于是否要对类型进行回收，HotSpot虚拟机提供了-Xnoclassgc参数进行控制，还可以使用-verbose:class 以及 -XX:+TraceClassLoading、-XX:+TraceClassUnLoading查看类加载和卸载信息\n在大量使用反射、动态代理、CGLib等字节码框架，动态生成JSP以及OSGi这类频繁自定义类加载器的场景中，通常都需要Java虚拟机具备类型卸载的能力，以保证不会对方法区造成过大的内存压力。\n常见面试题\n百度：\n说一下JVM内存模型吧，有哪些区？分别干什么的？\n蚂蚁金服：\nJava8的内存分代改进 JVM内存分哪几个区，每个区的作用是什么？\n一面：JVM内存分布/内存结构？栈和堆的区别？堆的结构？为什么两个survivor区？\n二面：Eden和survior的比例分配\n小米：\njvm内存分区，为什么要有新生代和老年代\n字节跳动：\n二面：Java的内存分区\n二面：讲讲jvm运行时数据库区 什么时候对象会进入老年代？\n京东：\nJVM的内存结构，Eden和Survivor比例。\nJVM内存为什么要分成新生代，老年代，持久代。\n新生代中为什么要分为Eden和survivor。\n天猫：\n一面：Jvm内存模型以及分区，需要详细到每个区放什么。\n一面：JVM的内存模型，Java8做了什么改\n拼多多：\nJVM内存分哪几个区，每个区的作用是什么？\n美团：\njava内存分配 jvm的永久代中会发生垃圾回收吗？\n一面：jvm内存分区，为什么要有新生代和老年代？\n\n对象实例化创建对象的方式\nnew：最常见的方式、Xxx的静态方法，XxxBuilder/XxxFactory的静态方法\n\nClass的newInstance方法：反射的方式，只能调用空参的构造器，权限必须是public\n\nConstructor的newInstance(XXX)：反射的方式，可以调用空参、带参的构造器，权限没有要求\n\n使用clone()：不调用任何的构造器，要求当前的类需要实现Cloneable接口，实现clone()\n\n使用序列化：从文件中、从网络中获取一个对象的二进制流\n\n第三方库 Objenesis\n\n\n创建对象的步骤\n判断对象对应的类是否加载、链接、初始化\n\n虚拟机遇到一条new指令，首先去检查这个指令的参数能否在Metaspace的常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已经被加载，解析和初始化（即判断类元信息是否存在）。\n如果没有，那么在双亲委派模式下，使用当前类加载器以ClassLoader + 包名 + 类名为key进行查找对应的 .class文件；\n\n如果没有找到文件，则抛出ClassNotFoundException异常\n\n如果找到，则进行类加载，并生成对应的Class对象\n\n\n\n\n为对象分配内存\n\n首先计算对象占用空间的大小，接着在堆中划分一块内存给新对象。如果实例成员变量是引用变量，仅分配引用变量空间即可，即4个字节大小\n如果内存规整：虚拟机将采用的是指针碰撞法（Bump The Point）来为对象分配内存。\n\n意思是所有用过的内存在一边，空闲的内存放另外一边，中间放着一个指针作为分界点的指示器，分配内存就仅仅是把指针指向空闲那边挪动一段与对象大小相等的距离罢了。如果垃圾收集器选择的是Serial ，ParNew这种基于压缩算法的，虚拟机采用这种分配方式。一般使用带Compact（整理）过程的收集器时，使用指针碰撞。\n\n如果内存不规整：虚拟机需要维护一个空闲列表（Free List）来为对象分配内存。\n\n已使用的内存和未使用的内存相互交错，那么虚拟机将采用的是空闲列表来为对象分配内存。意思是虚拟机维护了一个列表，记录上那些内存块是可用的，再分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的内容。\n选择哪种分配方式由Java堆是否规整所决定，而Java堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定。\n\n\n\n\n处理并发问题\n\n\n采用CAS失败重试、区域加锁保证更新的原子性\n\n每个线程预先分配一块TLAB：通过设置 -XX:+UseTLAB参数来设定\n\n\n\n\n初始化分配到的内存\n\n所有属性设置默认值，保证对象实例字段在不赋值时可以直接使用\n\n\n设置对象的对象头\n\n将对象的所属类（即类的元数据信息）、对象的HashCode和对象的GC信息、锁信息等数据存储在对象的对象头中。这个过程的具体设置方式取决于JVM实现。    \n\n\n执行init方法进行实例化\n\n在Java程序的视角看来，初始化才正式开始。初始化成员变量，执行实例化代码块，调用类的构造方法，并把堆内对象的首地址赋值给引用变量。\n因此一般来说（由字节码中跟随invokespecial指令所决定），new指令之后会接着就是执行方法，把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完成创建出来。\n\n\n\n给对象属性赋值的操作\n\n属性的默认初始化\n\n显式初始化\n\n代码块中初始化\n\n构造器中初始化\n\n\n对象内存布局\n消息头(Header) - PS:如果是数组,还需记录数组的长度\n运行时元数据(Mark Word)\n哈希值(HashCode)\nGC分代年龄\n锁状态标志\n线程持有的锁\n偏向线程ID\n偏向时间戳\n\n\n类型指针 - 执行类元数据InstanceKlass,确定该对象所属的类型\n\n\n实例数据(Instance Data)\n说明 - 它是对象真正存储的有效信息,包括程序代码中定义的各种类型的字段(包括从父类继承下来的和本身拥有的字段)\n规则\n相同宽度的字段总是被分配在一起\n父类中定义的变量会出现在子类之前\n如果CompactFields参数为true(默认为true): 子类的窄变量可能插入到父类变量的空袭\n\n\n\n\n对其填充(Padding)\n不是必须的,也没有特别含义,仅仅起到占位符的作用\n\n\n\n\n对象访问定位Java虚拟机规范中并没有定义应该通过什么方法去定位/访问到堆中对象的具体位置,所以对方访问方式是由虚拟机实现而定,主流有两种方式访问:句柄和直接指针\n\n如果使用句柄访问,在Java堆中就需要划分一块内存作为句柄池,栈帧中局部变量表中的对象存储句柄地址,而句柄中包含了对象的对象实例和类型数据的地址信息.\n\n\n\n如果使用直接指针访问的话,Java堆中对象的内存布局就必须考虑如何放置访问类型数据的相关信息,栈帧中局部变量表中的对象直接存储对象地址,如果访问对象本身的话,就不需要多一次间接访问的开销.\n\n\n这两种方式各有各的优点.\n使用句柄的话最大的好处是对象存储的是稳定的句柄地址,在对象被移动时(垃圾收集时移动对象是非常普遍的行为)只改变句柄中的实例数据指针.\n使用直接指针最大的好处是速度更快,节省了一次指针定位的时间开销,由于对象访 问在Java中非常频繁,因此这类开销积少成多也是一项极为可观的执行成本.\n对于HotSpot而言,它使用第二种方式进行对象访问(有例外情况，如果使用了Shenandoah收集器的 话也会有一次额外的转发),但纵观整个软件开发行业,各种语言,隔着框架中,使用句柄是十分常见的.\n执行引擎执行引擎是Java虚拟机组成的核心部分之一,属于JVM的下层,里面包括解释器、即时编译器、垃圾回收器.\n“虚拟机”有一个相对的概念叫”物理机”,它们都有代码执行的能力,区别在于,”物理机”的执行引擎直接建立在处理器、缓存、指令集和操作系统层面.\n而**”虚拟机”的执行引擎则是由软件自行实现的**,因此可以不受物理条件制约地定制指令集与执行引擎的结构体系,能够执行那些不被硬件直接支持的指令集格式.\nJVM的主要任务是负责装载字节码到其内部，但字节码并不能够直接运行在操作系统之上，因为字节码指令并非等价于本地机器指令，它内部包含的仅仅只是一些能够被JVM所识别的字节码指令、符号表，以及其他辅助信息。\n\n\n执行引擎(Execution Engine)的任务是将字节码指令解释/编译为对应平台上的本地机器指令,可以简单的理解为一个翻译官的角色.\\\nJava代码编译和执行过程\n大部分部分程序代码转换为 物理机代码 或者 虚拟机代码 能够执行的指令集之前,都需要经过上图的步骤.\nJava代码的编译是由Java源码编译器(前端编译器)来完成的,流程如下:\n\nJava字节码的执行是由JVM执行引擎(后端编译器)来完成的,如图:\n\n\n解释器: 当Java虚拟机启动时会根据预定义的规范对字节码文件采用逐行解释的方式执行,将字节码文件中的内容”翻译”为对应平台的本地机器执行指令.\nJIT(Just In Time Compiler)编译器: 虚拟机将源代码直接编译成和本地机器平台相关的机器语言\nJDK1.0时代,将Java语言定义为”解释执行”还是比较准确的,后来,Java也发展出可以直接生成本地代码的编译器,现在JVM在执行Java代码的时候,通常都会将 “解释执行” 与 “编译执行” 二者结合运行\n\n\n语言的演化机器码\n各种用二进制编码方式表示的指令，叫做机器指令码。开始，人们就用它采编写程序，这就是机器语言。\n机器语言虽然能够被计算机理解和接受，但和人们的语言差别太大，不易被人们理解和记忆，并且用它编程容易出差错。\n用它编写的程序一经输入计算机，CPU直接读取运行，因此和其他语言编的程序相比，执行速度最快。\n机器指令与CPU紧密相关，所以不同种类的CPU所对应的机器指令也就不同。\n\n指令\n由于机器码是有0和1组成的二进制序列，可读性实在太差，于是人们发明了指令。\n指令就是把机器码中特定的0和1序列，简化成对应的指令（一般为英文简写，如mov，inc等），可读性稍好\n由于不同的硬件平台，执行同一个操作，对应的机器码可能不同，所以不同的硬件平台的同一种指令（比如mov），对应的机器码也可能不同。****\n\n指令集\n不同的硬件平台，各自支持的指令，是有差别的。因此每个平台所支持的指令，称之为对应平台的指令集。 如常见的\n\nx86指令集，对应的是x86架构的平台\n\nARM指令集，对应的是ARM架构的平台\n\n\n\n汇编语言\n由于指令的可读性还是太差，于是人们又发明了汇编语言。\n在汇编语言中，用助记符（Mnemonics）代替机器指令的操作码，用&lt;mark地址符号（Symbol）或标号（Label）代替指令或操作数的地址。在不同的硬件平台，汇编语言对应着不同的机器语言指令集，通过汇编过程转换成机器指令。\n由于计算机只认识指令码，所以用汇编语言编写的程序还必须翻译成机器指令码，计算机才能识别和执行。\n\n高级语言\n为了使计算机用户编程序更容易些，后来就出现了各种高级计算机语言。高级语言比机器语言、汇编语言更接近人的语言\n当计算机执行高级语言编写的程序时，仍然需要把程序解释和编译成机器的指令码。完成这个过程的程序就叫做解释程序或编译程序。\n\n\n高级语言也不是直接翻译成机器指令，而是翻译成汇编语言码.\n解释器JVM设计者们的初衷仅仅只是单纯地为了满足Java程序实现跨平台特性，因此避免采用静态编译的方式直接生成本地机器指令，从而诞生了实现解释器在运行时采用逐行解释字节码执行程序的想法。\n解释器工作机制\n解释器真正意义上所承担的角色就是一个运行时“翻译者”，将字节码文件中的内容“翻译”为对应平台的本地机器指令执行。\n当一条字节码指令被解释执行完成后，接着再根据PC寄存器中记录的下一条需要被执行的字节码指令执行解释操作。\n解释器分类\n在Java的发展历史里，一共有两套解释执行器，即古老的字节码解释器、现在普遍使用的模板解释器。\n\n字节码解释器在执行时通过纯软件代码模拟字节码的执行，效率非常低下。\n\n而模板解释器将每一条字节码和一个模板函数相关联，模板函数中直接产生这条字节码执行时的机器码，从而很大程度上提高了解释器的性能。\n\n\n在HotSpot VM，解释器主要由Interpreter模块和Code模块构成。\n\nInterpreter模块：实现了解释器的核心功能\n\nCode模块：用于管理HotSpot VM在运行时生成的本地机器指令\n\n\n现状\n由于解释器在设计和实现上非常简单，因此除了Java语言之外，还有许多高级语言同样也是基于解释器执行的，比如Python、Perl、Ruby等。但是在今天，基于解释器执行已经沦落为低效的代名词，并且时常被一些C/C++程序员所调侃。\n为了解决这个问题，JVM平台支持一种叫作即时编译的技术。即时编译的目的是避免函数被解释执行，而是将整个函数体编译成为机器码，每次函数执行时，只执行编译后的机器码即可，这种方式可以使执行效率大幅度提升。\n不过无论如何，基于解释器的执行模式仍然为中间语言的发展做出了不可磨灭的贡献。\nJIT编译器\n三种 JVM\nSun 公司 HotSopt，也就是我们常用的\nBEA JRockit 一般用于前端商务和军事应用\nIBM J9VM 一般 IBM 硬件独占\n\nGC 题目：\nJVM 的内存模型和分区，详细到每个分区放什么？\n堆里面的分区有那些？Eden，from，to，老年区，说说他们的特点\nGC 的算法有那些？标记清除法，标记整理法，复制算法，引用计数法，怎么用的？\n轻 GC 和重 GC 分别在什么时候发生？\n\n引用计数法（很少用）：\n\n复制算法：\n好处：没用内存碎片\n坏处：浪费内存空间，多了一半空间永远是空的\n复制算法最佳使用场景：对象存活度较低的时候（也就是新生区\n\n标记清除法：\n标记/清除算法的基本思想就跟它的名字一样，分为“标记”和“清除”两个阶段：首先标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象。\n标记阶段：标记的过程其实就是前面介绍的可达性分析算法的过程，遍历所有的 GC Roots 对象，对从 GC Roots 对象可达的对象都打上一个标识，一般是在对象的 header 中，将其记录为可达对象；\n清除阶段：清除的过程是对堆内存进行遍历，如果发现某个对象没有被标记为可达对象（通过读取对象 header 信息），则将其回收。\n不足：\n\n标记和清除过程效率都不高\n会产生大量碎片，内存碎片过多可能导致无法给大对象分配内存。\n\n\n标记整理法：\n标记—整理算法和标记—清除算法一样，但是标记—整理算法不是把存活对象复制到另一块内存，而是把存活对象往内存的一端移动，然后直接回收边界以外的内存，因此其不会产生内存碎片。标记—整理算法提高了内存的利用率，并且它适合在收集对象存活时间较长的老年代。\n不足：\n效率不高，不仅要标记存活对象，还要整理所有存活对象的引用地址，在效率上不如复制算法。\n\nSTW机制JVM在执行CG回收或其他特殊任务时，会挂起除了JVM之外所有JAVA应用程序线程，表现为全局停顿，所有JAVA代码停止，native代码可以执行，但不能于JVM交互\n垃圾收集器总结内存效率：复制算法&gt;标记清除算法&gt;标记整理法 （时间复杂度）\n内存整齐度：复制算法=标记整理法&gt;标记清除算法\n内存利用率：标记整理法=标记清除法&gt;复制算法\n参考详细笔记：https://www.yuque.com/u21195183/jvm/\nSTW机制：https://www.csdn.net/tags/NtTakgwsMTEwODUtYmxvZwO0O0OO0O0O.html\nJVM：https://docs.oracle.com/javase/8/docs/technotes/tools/unix/java.html\n","categories":["Java"],"tags":["Jvm"]},{"title":"DotNetCore模型验证统一处理","url":"/2021/01/06/DotNetCore%E6%A8%A1%E5%9E%8B%E9%AA%8C%E8%AF%81%E7%BB%9F%E4%B8%80%E5%A4%84%E7%90%86/","content":"ASP.Net Core 模型验证统一处理判断验证状态时一般会在Action里判断ModelState.IsValid是否为true\npublic IActionResult Create([FromBody]CreateOrderDto dto)\n&#123;\n        if(ModelState.IsValid)\n        &#123;\n            //TODO:...\n        &#125;\n&#125;\n\n如果每个需要验证的Action里面都写这个判断岂不是太麻烦，我们是否可以在进入所有的Action之前都进行验证，如果错误，就直接返回错误信息，不去执行Action了，当然时可以的。我们可以利用MVC的ActionFilter即Action过滤器，在执行Action之前统一判断处理。\n这里通过ActionFilterAttribute过滤器来实现这个功能\n首先创建应该过滤器ValidateModelFilter\n    /// &lt;summary&gt;\n    /// 统一模型验证返回\n    /// &lt;/summary&gt;\n    public class ValidateModelFilter : ActionFilterAttribute\n    &#123;\n        public override void OnActionExecuting(ActionExecutingContext context)\n        &#123;\n            if (!context.ModelState.IsValid)\n            &#123;\n                var result = context.ModelState.Keys\n                        .SelectMany(key =&gt; context.ModelState[key].Errors.Select(x =&gt; new ValidationError(key, x.ErrorMessage)))\n                        .ToList();\n                var res = new &#123; code = &quot;10001&quot;, message = &quot;实体类验证错误&quot;, data = result &#125;;\n                context.Result = new ObjectResult(res);\n            &#125;\n        &#125;\n    &#125;\n\n    public class ValidationError\n    &#123;\n        [JsonProperty(NullValueHandling = NullValueHandling.Ignore)]\n        public string Field &#123; get; &#125;\n        public string Message &#123; get; &#125;\n        public ValidationError(string field, string message)\n        &#123;\n            Field = field != string.Empty ? field : null;\n            Message = message;\n        &#125;\n    &#125;\n\n然后将这个过滤器应用到全局设置，当然也可以局部应用\n            //全局注册异常过滤器\n            services.AddControllersWithViews(option =&gt; &#123;\n                option.Filters.Add&lt;ValidateModelFilter&gt;();\n            &#125;);\n\n最后不要忘记要禁用.NetCore默认的验证处理器\nservices.Configure&lt;ApiBehaviorOptions&gt;(options =&gt; options.SuppressModelStateInvalidFilter = true);\n\n","categories":["Net"],"tags":["DotNetCore"]},{"title":"腾讯云COS前端直传","url":"/2021/01/05/%E8%85%BE%E8%AE%AF%E4%BA%91COS%E5%89%8D%E7%AB%AF%E7%9B%B4%E4%BC%A0/","content":"腾讯云COS前端直传\n首先你需要创建应该储存桶，得到 Bucket（存储桶名称） 和 Region（地域名称）\n\n进入基础配置页面，设置跨域访问的基本设置，详情看文档\n\n获取临时密钥，服务端使用固定密钥SecretId、SecretKey 向 STS 服务获取临时密钥，得到tmpSecretId、tmpSecretKey、sessionToken。各语言Demo\n\n前端通过tmpSecretId、tmpSecretKey，计算签名。下列使用vue调用JavaScript SDK为示例：\n&lt;template&gt;\n  &lt;div class=&quot;hello&quot;&gt;\n    &lt;p class=&quot;fileT&quot;&gt;\n      选择文件 &lt;input accept=&quot;&quot; type=&quot;file&quot; ref=&quot;file&quot; id=&quot;upload&quot; /&gt;\n    &lt;/p&gt;\n    &lt;button class=&quot;sure&quot; @click=&quot;uploadFile()&quot;&gt;上传&lt;/button&gt;\n  &lt;/div&gt;\n&lt;/template&gt;\n\n&lt;script&gt;\nimport COS from &quot;cos-js-sdk-v5&quot;;\nimport axios from &quot;axios&quot;;\nexport default &#123;\n  components: &#123;&#125;,\n  data() &#123;\n    return &#123;&#125;;\n  &#125;,\n  name: &quot;HelloWorld&quot;,\n  methods: &#123;\n    getTime() &#123;\n      var date = new Date();\n      var seperator1 = &quot;-&quot;;\n      var year = date.getFullYear();\n      var month = date.getMonth() + 1;\n      var strDate = date.getDate();\n      if (month &gt;= 1 &amp;&amp; month &lt;= 9) &#123;\n        month = &quot;0&quot; + month;\n      &#125;\n      if (strDate &gt;= 0 &amp;&amp; strDate &lt;= 9) &#123;\n        strDate = &quot;0&quot; + strDate;\n      &#125;\n      var currentdate = year + seperator1 + month + seperator1 + strDate;\n      return currentdate;\n    &#125;,\n    //上传腾讯云\n    uploadFile() &#123;\n      let result = Object;\n      var cos = new COS(&#123;\n        // 必选参数\n        getAuthorization: function (options, callback) &#123;\n          axios.post(&quot;http://localhost:5010/api/COS/getToken&quot;).then((data) =&gt; &#123;\n            result = data.data;\n            console.log(result);\n            // this.$options.methods.uploadFile.bind(this)(data.data);\n            callback(&#123;\n              TmpSecretId: result.Credentials.TmpSecretId,\n              TmpSecretKey: result.Credentials.TmpSecretKey,\n              XCosSecurityToken: result.Credentials.Token,\n              StartTime: result.StartTime, // 时间戳，单位秒，如：1580000000\n              ExpiredTime: result.ExpiredTime, // 时间戳，单位秒，如：1580000900\n            &#125;);\n          &#125;);\n        &#125;,\n      &#125;);\n      var fileObj = document.getElementById(&quot;upload&quot;).files[0];\n      cos.putObject(\n        &#123;\n          Bucket: &quot;myblog-1302916147&quot; /* 必须 */,\n          Region: &quot;ap-guangzhou&quot; /* 存储桶所在地域，必须字段 */,\n          Key: this.$options.methods.getTime() + &quot;/123.jpg&quot; /* 必须 */,\n          StorageClass: &quot;STANDARD&quot;,\n          Body: fileObj, // 上传文件对象\n          onProgress: function (progressData) &#123;\n            console.log(JSON.stringify(progressData));\n          &#125;,\n        &#125;,\n        function (err, data) &#123;\n          console.log(err || data);\n        &#125;\n      );\n    &#125;,\n  &#125;,\n&#125;;\n&lt;/script&gt;\n\n&lt;style scoped&gt;\n&lt;/style&gt;\n\n\n\n","categories":["COS"],"tags":["HTML","腾讯云","Vue","COS"]},{"title":"JWT身份验证教程","url":"/2020/10/16/JWT%E8%BA%AB%E4%BB%BD%E9%AA%8C%E8%AF%81%E6%95%99%E7%A8%8B/","content":"JWT身份验证教程\n通过 NuGet 安装 Microsoft.AspNetCore.Authentication.JwtBearer\n\n\n\n打开 Startup.cs 在 ConfigureServices 添加如下代码\nservices.AddScoped&lt;IUserService, UserService&gt;();\n\n//将appsettings.json中的jwtsettings部分读取到jwtsettings中，给其他地方用\nservices.Configure&lt;JwtSettings&gt;(config.GetSection(&quot;JwtSettings&quot;));\n//由于初始化的时候我们就需要用，所有用bind方法读取配置\nvar jwtSettings = new JwtSettings();\nconfig.Bind(&quot;JwtSettings&quot;, jwtSettings);\n\n//添加身份验证\nservices.AddAuthentication(option =&gt;\n&#123;\n    //认证middleware配置\n    option.DefaultAuthenticateScheme = JwtBearerDefaults.AuthenticationScheme;\n    option.DefaultChallengeScheme = JwtBearerDefaults.AuthenticationScheme;\n&#125;).AddJwtBearer(o =&gt;\n&#123;\n    //jwt token参数设置\n    o.TokenValidationParameters = new TokenValidationParameters\n    &#123;\n        NameClaimType = JwtClaimTypes.Name,\n        RoleClaimType = JwtClaimTypes.Role,\n        //token颁发机构\n        ValidIssuer = jwtSettings.Issuer,\n        //颁发给谁\n        ValidAudience = jwtSettings.Audience,\n        //这里的key要加密\n        IssuerSigningKey = new SymmetricSecurityKey(Encoding.UTF8.GetBytes(jwtSettings.SecretKey))\n    &#125;;\n&#125;);\n\n\nConfigure 配置认证中间件\napp.UseAuthentication();//认证中间件\n\n\n创建登录用实体类，也可以直接使用 Identity Server 的，这里图个方便\npublic class LoginInput\n&#123;\n\n    public string Username &#123; get; set; &#125;\n\n    public string Password &#123; get; set; &#125;\n&#125;\n\n\n创建一个UserService类用于验证用户凭据和返回JWT令牌\n文件的顶部包含一个定义用户服务的接口，下面是实现该接口的具体用户服务类。\n身份验证成功后，该Authenticate()方法将使用JwtSecurityTokenHandler该类生成JWT（JSON Web令牌），该类将生成使用存储在appsettings.json中的密钥进行数字签名的令牌。\n标准中注册的声明 (建议但不强制使用) ：\n\niss: jwt签发者\nsub: jwt所面向的用户\naud: 接收jwt的一方\nexp: jwt的过期时间，这个过期时间必须要大于签发时间\nnbf: 定义在什么时间之前，该jwt都是不可用的.\niat: jwt的签发时间\njti: jwt的唯一身份标识，主要用来作为一次性token,从而回避重放攻击。\n\n public interface IUserService\n    &#123;\n        Task&lt;AuthenticateResponse&gt; Authenticate(LoginDto model);\n    &#125;\n\n    public class UserService : IUserService\n    &#123;\n        private readonly UserManager&lt;IdentityUser&gt; _userManager;\n\n        public JwtSettings _JwtSettings &#123; get; &#125;\n\n        public UserService(UserManager&lt;IdentityUser&gt; userManager, IOptions&lt;JwtSettings&gt; jwtSettings)\n        &#123;\n            this._userManager = userManager;\n            this._JwtSettings = jwtSettings.Value;\n        &#125;\n\n        /// &lt;summary&gt;\n        /// 进行身份验证\n        /// &lt;/summary&gt;\n        /// &lt;param name=&quot;model&quot;&gt;LoginDto模型&lt;/param&gt;\n        /// &lt;returns&gt;AuthenticateResponse&lt;/returns&gt;\n        public async Task&lt;AuthenticateResponse&gt; Authenticate(LoginDto model)\n        &#123;\n            var user = await _userManager.FindByNameAsync(model.UserName);\n\n            // 没用用户或密码错误返回null\n            if (user == null &amp;&amp; !await _userManager.CheckPasswordAsync(user, model.Password)) return null;\n\n            // 验证成功 生成jwt令牌\n            var token = generateJwtToken(user);\n\n            return new AuthenticateResponse(user, token);\n        &#125;\n\n        //获取Jwt Token\n        private string generateJwtToken(IdentityUser user)\n        &#123;\n            var tokenHandler = new JwtSecurityTokenHandler();\n            var tokenDescriptor = new SecurityTokenDescriptor\n            &#123;\n                Subject = new ClaimsIdentity(new[] &#123;\n                    new Claim(JwtClaimTypes.Audience, _JwtSettings.Audience),\n                    new Claim(JwtClaimTypes.Issuer, _JwtSettings.Issuer),\n                    new Claim(JwtClaimTypes.Name, user.UserName),\n                    new Claim(&quot;id&quot;, user.Id.ToString())\n                &#125;),\n                Expires = DateTime.UtcNow.AddDays(1),//有效日期\n                SigningCredentials = new SigningCredentials(new SymmetricSecurityKey(Encoding.UTF8.GetBytes(_JwtSettings.SecretKey)), SecurityAlgorithms.HmacSha256Signature)\n            &#125;;\n            var token = tokenHandler.CreateToken(tokenDescriptor);\n            return tokenHandler.WriteToken(token);\n        &#125;\n    &#125;\n\n\n添加登录控制器\n    [Route(&quot;api/[controller]&quot;)]\n    [ApiController]\n    public class UserController : ControllerBase\n    &#123;\n        private readonly IUserService userService;\n\n        public UserController(IUserService userService)\n        &#123;\n            this.userService = userService;\n        &#125;\n        \n        /// &lt;summary&gt; \n        /// 实现用户登录 post: /api/user/Login/model\n        /// &lt;/summary&gt;\n        /// &lt;param name=&quot;model&quot;&gt;LoginInput&lt;/param&gt;\n        /// &lt;returns&gt;&lt;/returns&gt;\n        [HttpPost]\n        [Route(&quot;Login&quot;)]\n        [AllowAnonymous]\n        public async Task&lt;IActionResult&gt; Login(LoginInput model)\n        &#123;\n            var response = await userService.Authenticate(model);\n\n            if (response == null)\n                return BadRequest(new &#123; message = &quot;用户名或密码错误&quot; &#125;);\n\n            return Ok(response);\n        &#125;\n    &#125;\n\n\nappsettings.json\n  &quot;JwtSettings&quot;: &#123;\n    &quot;Issuer&quot;: &quot;https://localhost:44336&quot;,\n    &quot;Audience&quot;: &quot;https://localhost:44336&quot;,\n    &quot;SecretKey&quot;: &quot;Hello-key----------&quot;//注意 必须达到16位\n  &#125;\n\n\n\n","categories":["Net"],"tags":["DotNetCore","JWT"]},{"title":"WPF使用CefSharp","url":"/2020/09/25/WPF%E4%BD%BF%E7%94%A8CefSharp/","content":"WPF中使用CefSharp（.net core 3.1）\n首先使用NuGet安装CefSharp.WPF\n\n指定特定的平台，x64或者x86，默认是Any CPU，不进行配置的话，CefSharp是不支持Any CPU的\n\n打开.csproj文件添加如下标签\n  &lt;ItemGroup&gt;\n    &lt;Reference Update=&quot;CefSharp&quot;&gt;\n      &lt;Private&gt;true&lt;/Private&gt;\n    &lt;/Reference&gt;\n    &lt;Reference Update=&quot;CefSharp.Core&quot;&gt;\n      &lt;Private&gt;true&lt;/Private&gt;\n    &lt;/Reference&gt;\n    &lt;Reference Update=&quot;CefSharp.Wpf&quot;&gt;\n      &lt;Private&gt;true&lt;/Private&gt;\n    &lt;/Reference&gt;\n  &lt;/ItemGroup&gt;\n\n\nWPF使用\nxmlns:cefSharpWPF=&quot;clr-namespace:CefSharp.Wpf;assembly=CefSharp.Wpf&quot;      \n&lt;cefSharpWPF:ChromiumWebBrowser x:Name=&quot;cefSp&quot;&gt;&lt;/cefSharpWPF:ChromiumWebBrowser&gt;\n\n\n\n","categories":["WPF"],"tags":["CefSharp","DotNetCore","WPF"]},{"title":"EF Core 软删除","url":"/2020/09/15/EFCore%E8%BD%AF%E5%88%A0%E9%99%A4/","content":"EF CORE 软删除向应用添加软删除有如下步骤：\n\n向需要软删除的实体类添加软删除属性\n\n向 DbContext 中添加代码，以对这些实体类应用查询过滤器\n\n如何设置/重置软删除\n\n\n1.添加软删除属性对于标准的软删除实现，你需要一个布尔标志来控制软删除，例如，这里有一个名叫 SoftDeleted 属性的 Book 实体。\npublic class Book : ISoftDelete\n&#123;\n    public int BookId &#123; get; set; &#125;\n    public string Title &#123; get; set; &#125;\n    //... 其它无关属性\n\n    public bool SoftDeleted &#123; get; set; &#125;\n&#125;\n\n你可以通过它的名字SoftDeleted来区分软删除属性，如果它的值是true则该实体删除了，这意味着当你创建一个新实体时，它不会被软删除。\n我还添加了一个 Book 类的ISoftDelete接口（第 1 行），这个接口表示该类必须有一个可以读写的公共SoftDeleted属性。这个接口将使得在DbContext中配置软删除查询过滤器变得更加容易。\n2.配置查询过滤器你必须告诉 EF Core 哪个实体类需要一个查询过滤器，该过滤器是查询表达式，用来把不需要被看到的实体过滤掉。你可以在 DbContext 中使用以下代码手动完成此操作。\npublic class EfCoreContext : DbContext\n&#123;\n    public EfCoreContext(DbContextOptions&lt;EfCoreContext&gt; option)\n        : base(options)\n    &#123;&#125;\n\n    protected override OnModelCreating(ModelBuilder modelBuilder)\n    &#123;\n        // 省略其它和软删除无关的代码\n\n        modelBuilder.Entity&lt;Book&gt;().HasQueryFilter(p =&gt; !p.SoftDeleted);\n    &#125;\n&#125;\n\n这很好，但是让我向你展示一种自动添加查询过滤器的方法。\n在 DbContext 中的 OnModelCreating 方法中，你可以通过 Fluent API 配置 EF Core。但是也有一种方法可以判断每个实体类并决定如何配置它。在下面的代码中，你可以看到 foreach 循环依次遍历每个实体类，检查实体类是否实现了 ISoftDelete 接口，如果实现了，它将调用我创建的扩展方法来应用正确的软删除过滤器配置。\nprotected override void OnModelCreating(ModelBuilder modelBuilder)\n&#123;\n    // 省略其它无关的代码\n\n    foreach (var entityType in modelBuilder.Model.GetEntityTypes())\n    &#123;\n        // 省略其它无关的代码\n\n        if (typeof(ISoftDelete).IsAssignableFrom(entityType.ClrType))\n        &#123;\n            entityType.AddSoftDeleteQueryFilter();\n        &#125;\n    &#125;\n&#125;\n\n有许多配置可以直接应用于 GetEntityTypes 方法返回的类型，但是设置查询过滤器需要更多的工作。这是因为查询过滤器中的 LINQ 查询需要实体类的类型来创建正确的 LINQ 表达式。为此，我创建了一个小型扩展类，它可以动态创建正确的 LINQ 表达式来配置查询过滤器。\npublic static class SoftDeleteQueryExtension\n&#123;\n    public static void AddSoftDeleteQueryFilter(\n        this IMutableEntityType entityData)\n    &#123;\n        var methodToCall = typeof(SoftDeleteQueryExtension)\n            .GetMethod(nameof(GetSoftDeleteFilter),\n                BindingFlags.NonPublic | BindingFlags.Static)\n            .MakeGenericMethod(entityData.ClrType);\n        var filter = methodToCall.Invoke(null, new object[] &#123; &#125;);\n        entityData.SetQueryFilter((LambdaExpression)filter);\n    &#125;\n\n    private static LambdaExpression GetSoftDeleteFilter&lt;TEntity&gt;()\n        where TEntity : class, ISoftDelete\n    &#123;\n        Expression&lt;Func&lt;TEntity, bool&gt;&gt; filter = x =&gt; !x.SoftDeleted;\n        return filter;\n    &#125;\n&#125;\n\n我真的很喜欢这个操作，因为它可以节省我的时间，也避免我忘记配置每一个查询过滤器。\n3.如何设置/重置软删除将“软删除”属性设置为 true 很容易，对应的场景是用户选择一个条目并单击(软)“删除”，这会返回实体的主键。用代码实现如下：\nvar entity = context.Books.Single(x =&gt; x.BookId == id);\nentity.SoftDeleted = true;\ncontext.SaveChanges();\n\n重置软删除属性在实际的业务场景中有点复杂。首先，你很可能想要向用户显示一个已删除实体的列表——把它想象成显示某个实体类类型的实例回收站，例如 Book。要做到这一点，需要在你的查询中使用IgnoreQueryFilters方法，这意味着你将得到所有的实体（包括那些没有被软删除的和被软删除的），然后再根据需要选出那些 SoftDeleted 属性为 true 的。\nvar softDelEntities = _context.Books.IgnoreQueryFilters()\n    .Where(x =&gt; x.SoftDeleted).ToList();\n\n相应的，当你收到一个重设 SoftDeleted 属性的请求时（它通常包含实体类的主键），则要加载此条目时，需要在查询中使用IgnoreQueryFilters方法。\nvar entity = context.Books.IgnoreQueryFilters()\n     .Single(x =&gt; x.BookId == id);\nentity.SoftDeleted = false;\ncontext.SaveChanges();\n\n使用软删除注意事项首先，需要说的是查询过滤器是非常安全的。我的意思是，如果查询过滤器返回 false，那么特定的实体/行将不会包含在查询（包括 Find 和 Include 等）返回的结果集中。你可以使用直接 SQL 绕过它，但除此之外，EF Core 会隐藏你软删除的数据。\n但有几点你需要注意。\n小心软删除过滤器与其它过滤器的混合使用查询过滤器非常适合于软删除，但是查询过滤器更适合于控制对数据组的访问。例如，假设您想要构建一个 Web 应用程序来为多个公司提供服务，比如工资单。在这种情况下，你需要确保 A 公司看不到 B 公司的数据，反之亦然。这种类型的系统称为多租户应用程序，而查询过滤器非常适合此类场景。\n问题是，每个实体类型只允许使用一个查询过滤器，因此，如果您想在多租户系统中使用软删除，那么您必须将这两个部分结合起来形成查询过滤器——下面是查询过滤器的示例：\nmodelBuilder.Entity&lt;MyEntity&gt;()\n    .HasQueryFilter(x =&gt; !x.SoftDeleted\n      &amp;&amp; x.TenantId == currentTenantId);\n\n这看上去很好，但是当你使用IgnoreQueryFilters方法忽略软删除标记进行查询时，它会忽略整个查询过滤器，包括多租户部分。因此，如果不小心，还会显示多租户数据！\n答案是为自己构建一个特定于应用程序的IgnoreSoftDeleteFilter方法，如下所示：\npublic static IQueryable&lt;TEntity&gt; IgnoreSoftDeleteFilter&lt;TEntity&gt;(\n    this IQueryable&lt;TEntity&gt; baseQuery, string currentTenantId)\n    where TEntity : class, ITenantId\n&#123;\n    return baseQuery.IgnoreQueryFilters()\n        .Where(x =&gt; x.TenantId == currentTenantId)\n&#125;\n\n这将忽略所有筛选器，然后把多租户筛选器添加回去。这将使它更容易更安全地处理显示/重置被软删除的实体。\n更多的看这里吧:连接\n","categories":["DotNetCore"],"tags":["EFCore"]},{"title":"Docker安装RabbitMQ","url":"/2020/09/15/Docker%E5%AE%89%E8%A3%85RabbitMQ/","content":"Docker 下安装 RabbitMQ获取镜像\n#指定版本，该版本包含了web控制页面\ndocker pull rabbitmq:management\n\n允许镜像\n#方式一：默认guest 用户，密码也是 guest\ndocker run -d --hostname my-rabbit --name rabbit -p 15672:15672 -p 5672:5672 rabbitmq:management\n\n#方式二：设置用户名和密码\ndocker run -d --hostname my-rabbit --name rabbit -e RABBITMQ_DEFAULT_USER=user -e RABBITMQ_DEFAULT_PASS=password -p 15672:15672 -p 5672:5672 rabbitmq:management\n\n访问 UI 界面\nhttp://localhost:15672/\n\n","categories":["Docker"],"tags":["Docker","RabbitMQ"]},{"title":"Docker安装MySql","url":"/2020/09/15/Docker%E5%AE%89%E8%A3%85MySql/","content":"Docker 安装 Mysqldocker pull mysql\n\ndocker run --name mysql  -p 3307:3306 -e MYSQL_ROOT_PASSWORD=123456 -d mysql\n\n#进入容器内部  mysql 是上边运行时为容器取的别名 也可以用id替代\ndocker exec -it dockermysql bash\n\n# 给用于授予权限\ngrant all privileges on *.*  to &#39;root&#39;@&#39;%&#39; ;\n\n# 刷新权限\nflush privileges;\n\n#Mysql远程连接报错：authentication plugin caching_sha2\nALTER USER &#39;root&#39;@&#39;%&#39; IDENTIFIED WITH mysql_native_password BY &#39;密码&#39;;\n\n","categories":["Docker"],"tags":["Docker","MySql"]},{"title":"Docker安装","url":"/2020/09/15/Docker%E5%AE%89%E8%A3%85/","content":"Docker 安装\n更新 Ubuntu 的 apt 源索引\nsudo apt-get update\n\n\n安装包允许 apt 通过 HTTPS 使用仓库\nsudo dpkg --configure -a\nsudo apt-get install apt-transport-https ca-certificates curl software-properties-common\n\n\n添加 Docker 官方 GPG key\ncurl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add -\n\n\n设置 Docker 稳定版仓库\nsudo add-apt-repository &quot;deb [arch=amd64] https://download.docker.com/linux/ubuntu $(lsb_release -cs) stable&quot;\n\n\n更新 apt 源索引\nsudo apt-get update\n\n\n安装最新版本 Docker CE（社区版）\nsudo apt-get install docker-ce\n\n\n查看安装 Docker 的版本\ndocker --version\n\n\n检查 Docker CE 是否安装正确\nsudo docker run hello-world\n\n\n配置 Docker 镜像加速\nsudo mkdir -p /etc/docker\nsudo tee /etc/docker/daemon.json &lt;&lt;-&#39;EOF&#39;\n&#123;\n  &quot;registry-mirrors&quot;: [&quot;https://rd0abcx3.mirror.aliyuncs.com&quot;]\n&#125;\nEOF\nsudo systemctl daemon-reload\nsudo systemctl restart docker\n\n\n\n","categories":["Docker"],"tags":["Docker"]},{"title":"Redis主从连接","url":"/2020/09/15/Redis%E4%B8%BB%E4%BB%8E%E8%BF%9E%E6%8E%A5/","content":"主从连接\n方法一:客户端发送命令\nslaveof &lt;masterip&gt; &lt;masterport&gt;\n\n\n方法二:启动服务器参数\nredis-server --slaveof &lt;masterip&gt; &lt;masterport&gt;\n\n\n方法三:服务器配置\nslaveof &lt;masterip&gt; &lt;masterport&gt;\n\n\n\n主从断开连接slaveof no one\n\n授权访问\nmaster 配置文件设置密码\nrequirepass &lt;password&gt;\n\n\nmaster 客户端发生命令设置密码\nconfig set requirepass &lt;password&gt;\nconfig get requirepass\n\n\nslave 客户端发送命令设置密码\nauth &lt;password&gt;\n\n\nslave 配置文件设置密码\nmasterauth &lt;password&gt;\n\n\n启动客户端设置密码\nredis-cli -a &lt;password&gt;\n\n\n\n数据同步阶段 master 说明\n如果 master 数据量巨大，数据同步阶段应避开流量高峰期，避免造成 master 阻塞，影响业务正常执行\n\n复制缓冲区大小设定不合理，会导致数据溢出。如进行全量复制周期太长，进行部分复制时发现数据已经存在丢失的情况，必须进行第二次全量复制，致使 slave 陷入死循环状态。\nrepl-backlog-size 1mb\n\n\nmaster 单机内存占用主机内存的比例不应过大，建议使用 50%-70%的内存，留下 30%-50%的内存用于执行 bgsave 命令和创建复制缓冲区\n\n\n数据同步阶段 slave 说明\n为避免 slave 进行全量复制、部分复制时服务器响应阻塞或数据不同步，建议关闭此期间的对外服务\nslave-server-stale-data yes|no\n\n\n数据同步阶段，master 发送给 slave 信息可以理解 master 是 slave 的一个客户端，主动向 slave 发送命令\n\n多个 slave 同时对 master 请求数据同步，master 发送的 RDB 文件增多，会对带宽造成巨大冲击，如果 master 带宽不足，因此数据同步需要根据业务需求，适量错峰\n\nslave 过多时，建议调整拓扑结构，由一主多从结构变为树状结构，中间的节点既是 master，也是 slave。注意使用树状结构时，由于层级深度，导致深度越高的 slave 与最顶层 master 间数据同步延迟较大，数据一致性变差，应谨慎选择\n\n\n复制缓冲区\n概念：复制缓冲区，又名复制积压缓中区，是一个先进先出（FIFO）的队列，用于存储服务器执行过的命令，每次传播命令，master 都会将传播的命令记录下来，并存储在复制缓冲区\n由来：每台服务器启动时，如果开启有 AOF 或被连接成为 master 节点，即创建复制缓冲区·\n作用：用于保存 master 收到的所有指令（仅影响数据变更的指令，例 set,select)\n数据来源：当 master 接收到主客户端的指令时，除了将指令执行，会将该指令存储到缓冲区中\n\n主从服务器复制偏移量(offset)\n概念：一个数字，描述复制缓冲区中的指令字节位置\n分类：\nmaster 复制偏移量：记录发送给所有 slave 的指令字节对应的位置（多个）\nslave 复制偏移量：记录 slave 接收 master 发送过来的指令字节对应的位置（一个）\n\n\n数据来源：\nmaster 端：发送一次记录一次\nslave 端：接收一次记录一次\n\n\n作用：同步信息，比对 master 与 slave 的差异，当 slave 断线后，恢复数据使用\n\n\n心跳机制\n进入命令传播阶段候，master 与 slave 间需要进行信息交换，使用心跳机制进行维护，实现双方连接保持在线\nmaster 心跳：\n​ 指令：PING\n周期：由 repl-ping-slave-period 决定，默认 10 秒\n作用：判断 slave 是否在线\n查询：INFO replication 获取 slave 最后一次连接时间间隔，lag 项维持在 0 或 1 视为正常\n\n\nslave 心跳任务\n指令：REPLCONF ACK{offset}\n周期：1 秒\n作用 1：汇报 slave 自己的复制偏移量，获取最新的数据变更指令\n作用 2：判断 master 是否在线\n\n\n\n心跳阶段注意事项\n当 slave 多数掉线，或延迟过高时，master 为保障数据稳定性，将拒绝所有信息同步操作\nmin-slaves-to-write 2\nmin-slaves-max-lag 10\n\nslave 数量少于 2 个，或所有 slave 的延迟都大于等于 10 秒，强制关闭 master 写功能，停止数据同步\n\nslave 数量由 slave 发送 REPLCONF ACK 命令做确认\n\nslave 延迟由 slave 发送 REPLCONF ACK 命令做确认\n\n\n\n\nrepl-timeout\n\nrepl-ping-slave-period\n\n","categories":["Redis"],"tags":["Redis"]},{"title":"Redis哨兵","url":"/2020/09/15/Redis%E5%93%A8%E5%85%B5/","content":"\n将宕机的 master 下线，找到一个 slave 作为 master，通知所有 slave 连接新的 master，启动新的 master 与 slave，全量复制 xN+部分复制 xN\n#配置文件名称 sentinel.conf\n\n#启动哨兵进程端口\nport 26379\n#哨兵进程服务临时文件夹，默认为/tmp，要保证有可写入的权限\ndir /tmp\n\n# 禁止保护模式\nprotected-mode no\n# 配置监听的主服务器，这里sentinel monitor代表监控，mymaster代表服务器的名称，可以自定义，192.168.11.128代表监控的主服务器，6379代表端口，2代表只有两个或两个以 上 的哨兵认为主服务器不可用的时候，才会进行failover操作。\nsentinel monitor mymaster 192.168.11.128 6379 2\n\n#指定哨兵在监控Redis服务时，当Redis服务在一个默认毫秒数内都无法回答时，单个哨兵认为的主观下线时间，默认为30000（30秒）\nsentinel down-after-milliseconds 30000\n\n#指定可以有多少个Redis服务同步新的主机，一般而言，这个数字越小同步时间越长，而越大，则对网络资源要求越高\nsentinel parallel-syncs myaster 1\n\n#指定故障切换允许的毫秒数，超过这个时间，就认为故障切换失败，默认为3分钟\nsentinel failover-timeout 180000\n\n# sentinel author-pass定义服务的密码，mymaster是服务名称，123456是Redis服务器密码\n# sentinel auth-pass &lt;master-name&gt; &lt;password&gt;\nsentinel auth-pass mymaster 123456\n\n\n启动哨兵\nredis-sentinel sentinel-端口号.conf\n\n\n\n","categories":["Redis"],"tags":["Redis"]},{"title":"Redis集群","url":"/2020/09/15/Redis%E9%9B%86%E7%BE%A4/","content":"Cluster 配置\n设置加入 cluster，成为其中的节点\ncluster-enabled yes|no\n\n\ncluster 配置文件名，该文件属于自动生成，仅用于快速查找文件并查询文件内容\ncluster-config-file &lt;filename&gt;\n\n\n节点服务响应超时时间，用于判定该节点是否下线或切换为从节点\ncluster-node-timeout &lt;milliseconds&gt;\n\n\nmaster 连接的 slave 最小数量\ncluster-migration-barrier &lt;count&gt;\n\n\n\nCluster 节点操作命令\n查看集群节点信息\ncluster nodes\n\n\n进入一个从节点 redis，切换其主节点\ncluster replicate &lt;master-id&gt;\n\n\n发现一个新节点，新增主节点\ncluster meet ip:port\n\n\n忽略一个没有 solt 的节点\ncluster forget &lt;id&gt;\n\n\n手动故障转移\ncluster failover\n\n\n\n","categories":["Redis"],"tags":["Redis"]},{"title":"Redis高级数据类型","url":"/2020/09/15/Redis%E9%AB%98%E7%BA%A7%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/","content":"Bitmaps\n获取指定 key 对应偏移量上的 bit 值\ngetbit key offset\n\n\n设置指定 key 对应偏移量上的 bit 值，value 只能说 0 或 1\nsetbit ket offset value\n\n\n对指定 key 按位进行交、并、非、异或操作，并将结果保存到 destKet 中\nbitop op destKet key1 [key2...]\n\n\nand:交\n\nor:并\n\nnot:非\n\nxor:异或\n\n\n\n统计指定 ket 中 1 的数量\nbitcount key [start end]\n\n\n\nHyperLogLog用于进行基数统计，不是集合，不保存数据，只记录数量而不是具体数据\n核心是基数估计算法，最终数据存在一定误差\n误差范围:基数估计的结果是一个带有 0.81 标准错误的近似值\n耗空间小，美国 hyperloglog 占用 12K 的内存用于标记基数\npfadd 命令不是一次性分配 12K 内存使用，会随着基数的增加内存逐渐增大\npfmerge 命令合并后占用储存空间为 12K，无论合并之前数据量是多少\n\n添加数据\npfadd ket  element [element...]\n\n\n统计数据\npfcount ket [key...]\n\n\n合并数据\npfmerge destkey sourcekey [sourcekey...]\n\n\n\nGEO\n添加坐标点\ngeoadd key longitude latitude member [longitude latitude member ...]\n\n\n获取坐标点\ngeopos key member [member ...]\n\n\n计算坐标点距离\ngeodist key member1 member2 [unit]\n\n\n根据坐标求范围内的数据\ngeoradius ket longitude latitude radius m|km|ft|mi [withdist] [withhash] [withhash] [count count]\n\n\n根据点求范围内的数据\ngeoradiusbymember key member radius m|km|ft|mi [withdist] [withhash] [withhash] [count count]\n\n\n获取指定点对应的坐标 hash 值\ngeohash key member [member ...]\n\n\n\n","categories":["Redis"],"tags":["Redis"]},{"title":"Redis Config配置","url":"/2020/09/15/Redis%20Config%E9%85%8D%E7%BD%AE/","content":"\n设置服务器以守护进程的方式允许\ndaemonize yes|no\n\n\n绑定主机地址\nbind 127.0.0.1\n\n\n设置服务器端口号\nport 6379\n\n\n设置数据库数量\ndatabases 16\n\n\n设置服务器以指定日志记录级别\nloglevel debug|verbose|notice|warning\n\n\n日志记录文件名\nlogfile 端口号.log\n\n\n设置同一时间最大客户端连接数，默认无限制。当客户端连接达到上限，Redis 会关闭新的连接\nmaxclients 0\n\n\n客户端闲置等待最大时长，达到最大值后关闭连接。如需关闭该功能，设置为 0\ntimeout 300\n\n\n导入并加载指定配置文件信息，用于快速创建 Redis 公共配置较多的 Redis 实例配置文件，便于维护\ninclude /path/server-端口号.conf\n\n\n\n","categories":["Redis"],"tags":["Redis"]}]