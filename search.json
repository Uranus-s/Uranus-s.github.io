[{"title":"注解和反射","url":"/2021/07/13/%E6%B3%A8%E8%A7%A3%E5%92%8C%E5%8F%8D%E5%B0%84/","content":"注解什么是注解注解就是对程序做出解释,与我们在方法、类上的注释没什么区别,但是注解可以被其他程序所读取,进行信息处理,否则与注释没有太大区别.\n内置注解内置注解就是JDK所带的一些注解.常用的三个注解:\n\n@Override\n\n修辞方法,表示打算重写超类中的方法声明.\n\n\n@Deprecated\n\n表示废弃,这个注解可以修饰方法、属性、类表示不鼓励程序员使用这样的元素,通常是因为他们危险或有更好的选择.\n\n\n@SuperWarnings\n\n抑制警告信息,我们写程序的时候,可能会报很多黄线的警告,但是不影响允许,我们就可以用这个注解来抑制隐藏他们.\n与前两个注解不同的是,我们必须给注解参数才可以使用它.\n\n\n\n\n\n\n参数\n说明\n\n\n\ndeprecation\n使用了过时的类或方法的警告\n\n\nunchecked\n执行了未检查的转换时的警告 如:使用集合时未指定泛型\n\n\nfallthrough\n当在switch语句使用时发生case穿透\n\n\npath\n在类路径、源文件路径中有不存在路径的警告\n\n\nserial\n当在序列化的类上缺少serialVersionUID定义时的警告\n\n\nfinally\n任何finally子句不能完成时的警告\n\n\nall\n关于以上所有的警告\n\n\n自定义注解public @interface 注解名 &#123; 定义体 &#125;\n\n@interface MyAnnotation&#123;\n    //注解的参数名称: 参数类型 + 参数名 ();\n    String name() default \"\";\n    int age() default 0;\n    int id() default -1;//如果为-1,代表不存在\n\n    String[] schools();\n&#125;\n\n需要注意:\n\n使用@interface自定义注解时,自动继承了java.lang.annotation.Annotation接口\n每个方法实际上是声明了一个配置参数\n方法的名称就是参数的名称\n返回值类型就是参数的类型(返回值类型只能是基本类型、Class、String、enum)\n可以通过default来声明参数的默认值\n如果只有一个参数成员,一般参数名为value\n使用注解元素时必须要有值,可以定义默认值,空字符串,0或者-1\n\n元注解在自定义注解时,需要使用Java提供的元注解,就是复制注解的其他注解.Java定义了四个标准的meta-annotation类型,它们被用来提供对其他注解类型的声明.\n\n@Target\n\n用来描述注解的使用范围,就是注解可以被应用在哪个地方.\n\n\n\n\n\n\n所修饰范围\n取值ElementType\n\n\n\npackage包\nPACKAGE\n\n\n类、接口、枚举、Annotation类型\nTYPE\n\n\n类型成员(方法、构造方法、成员变量、枚举值)\nCONSTRUCTOR：用于描述构造器。FIELD：用于描述域。METHOD：用于描述方法\n\n\n方法参数和本地变量\nLOCAL_VARIABLE:用于描述局部变量。PARAMETER：用于描述参数\n\n\n\nRetention\n\n告诉编译器需要在什么级别保存该注解信息,用于描述注解的生命周期\n\n\n\n\n\n\n取值RetentionPolicy\n作用\n\n\n\nSOURCE\n在源文件中有效(即源文件保留)\n\n\nCLASS\n在Class文件中有效(即Class保留)\n\n\nRUNTIME\n在运行时有效(即运行时保留)注:为RUNTIME时可以被反射机制所获取\n\n\n一般情况下,我们使用RUNTIME即可.这样程序运行时我们也可以通过反射机制来读取到该注解.\n\n@Document\n@Inherited\n\n反射什么是反射反射是Java迈向动态语言的一步,让Java成为了一个伪动态语言,反射机制允许程序在执行期间借助ReflecctionAPI取得类的任何信息,并能直接操作对象的内部属性及方法.\n加载完类之后,方法区会存放类的信息,包含类的完整结构信息,我们可以通过它看到类的结构,所以我们称之为反射.\n\nClass类使用反射,离不开java.lang.Class这个类.\n如何获取Class\n\n通过Class.forName()获取(最常用)\npublic class TestReflect &#123;\n    public static void main(String[] args) &#123;\n        try &#123;\n            //获取User的Class对象，参数为需要获取类对象的全类名\n           Class aClass = Class.forName(\"sml.reflect.User\");\n        //因为是动态编译，所有我们需要抛出类未找到的异常   \n        &#125; catch (ClassNotFoundException e) &#123;\n            e.printStackTrace();\n        &#125;\n    &#125;\n&#125;\n通过getClass()获取\npublic class TestReflect &#123;\n    public static void main(String[] args) &#123;\n        //new一个user对象\n        User user = new User();\n        //通过user对象来获取User类对象\n        Class aClass = user.getClass();\n    &#125;\n&#125;\n通过.class获取\npublic class TestReflect &#123;\n    public static void main(String[] args) &#123;\n        //通过导包获取类名点class来获取类对象\n        Class aClass = User.class;\n    &#125;\n&#125;\n\n反射的基本操作获取到Class对象之后,可以获取类的信息,这里列举常用的:\n\n获取类名\nClass aClass = Class.forName(\"sml.reflect.User\");\n //获取全类名\nString name = aClass.getName();\n //获取简单的类名\nString simpleName = aClass.getSimpleName();\n\n\n\n获取类的字段、某些变量\nClass aClass = Class.forName(\"sml.reflect.User\");\n\n//获取该类的所有public字段，包括父类的\nField[] fields = aClass.getFields();\n//根据字段名获取该类的public字段\nField field = aClass.getField(\"age\");\n\n//获取该类的所有字段，不包括父类（仅自定义）\nField[] fields1 = aClass.getDeclaredFields();\n//根据字段名获取该类的字段\nField field1 = aClass.getDeclaredField(\"name\");\n\n注意：我们仔细看注释，不带Declared的方法职能获取到public字段，且包括父类的，带Declared的方法可以获取到所有的自定义的字段！\n\n获取类的方法\n\n\n","categories":["Java"],"tags":["Java"]},{"title":"JUC并发编程","url":"/2021/06/22/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/","content":"什么是JUC其实就是java.util.concurrent包的简称,最开始出现在JDK1.5中.\n线程和进程进程一个运行中的程序集合,一个进程往往包含多个线程,至少包含1个线程,\nJava中默认有2个线程,一个Mian线程,一个GC线程\n线程线程是操作系统弄够运算调度的最小单位,\n对Java而言创建thread: 继承自thread,实现runnable接口,实现callable接口\nJava真的可以开启线程吗? 开不了的,底层是用native关键词修饰.调用本地实现\n并发和并行并发(多线程操作同一个资源,交替执行)\n\nCPU一核, 模拟出来多条线程,天下武功,唯快不破,快速交替\n\n并行(多个人一起行走, 同时进行)\n\nCPU多核,多个线程同时进行 ; 使用线程池操作\n\n并发编程的本质:充分利用CPU的资源\nWait/Sleep的区别\n来自不同的类\n wait来自object类, sleep来自线程类\n\n关于锁的释放\n wait会释放锁, sleep不会释放锁\n\n使用的范围不同\n wait必须在同步代码块中\nsleep可以在任何地方睡\n\n是否需要捕获异常\n wait不需要捕获异常\n sleep需要捕获异常\n\n\nLock锁Lock是一个接口,其基本功能和Synchronized 大差不差,两者对比如下:\n\n\n\nSynchronized\nLock\n\n\n\nJava内置关键字\nJava的一个接口\n\n\n无法判断获取锁的状态\n可以判断是否获取到锁\n\n\n自动释放锁\n必须手动释放\n\n\n线程 1（获得锁，阻塞）、线程2（等待，傻傻的等）\nLock锁就不一定会等待下去\n\n\n可重入锁,不可以中断,非公平\n可重入锁,可以判断锁,非公平(可设置)\n\n\n适合少量代码\n适合大量代码\n\n\nLock有三个实现类:\n\nReentrantLock 可重入锁(常用)\nReadLock 读锁\nWriteLock 写锁\n\n公平锁/非公平锁公平锁: 十分公平: 可以先来后到,一定要排队\n非公平锁: 十分不公平,可以插队(默认)\npublic static void main(String[] args) &#123;\n    Ticket ticket = new Ticket();\n    new Thread(() -&gt; &#123;\n        for (int i = 0; i &lt; 40; i++) ticket.sale();\n    &#125;, &quot;a&quot;).start();\n    new Thread(() -&gt; &#123;\n        for (int i = 0; i &lt; 40; i++) ticket.sale();\n    &#125;, &quot;b&quot;).start();\n    new Thread(() -&gt; &#123;\n        for (int i = 0; i &lt; 40; i++) ticket.sale();\n    &#125;, &quot;c&quot;).start();\n&#125;\n\nstatic class Ticket &#123;\n    private int ticketNum = 30;\n    private Lock lock = new ReentrantLock(true);\n    public void sale() &#123;\n        lock.lock();\n        try &#123;\n            if (this.ticketNum &gt; 0) &#123;\n                System.out.println(Thread.currentThread().getName() + &quot;购得第&quot; + ticketNum-- + &quot;张票, 剩余&quot; + ticketNum + &quot;张票&quot;);\n            &#125;\n            //增加错误的发生几率\n            Thread.sleep(10);\n        &#125; catch (Exception e) &#123;\n            e.printStackTrace();\n        &#125; finally &#123;\n            lock.unlock();\n        &#125;\n    &#125;\n&#125;\n\n参考文章1: https://blog.csdn.net/qq_22155255/article/details/109749311\n","categories":[],"tags":[]},{"title":"八大排序","url":"/2021/06/22/%E5%85%AB%E5%A4%A7%E6%8E%92%E5%BA%8F/","content":"插入排序基本思想:每一步将一个待排序的数据插入到前面已经排好序的有序序列中，直到插完所有元素为止.\n先确定第一个元素暂时为有序元素,声明应该变量tmp存放第二个元素这个\n创建一个循环 i,从第二个元素开始向右循环(++),在循环 i 中嵌套一个循环 j 为i-1向左循环(–),假设 i 左边的元素为有序元素, 则循环 j 需要用有序元素与右边的无序元素进行比较.\n假设一个数组包含{4, 6, 8, 5, 9}, i 从第二个元素6开始,向右循环,每次循环将对应的值赋予tmp,到8为止,都不需要进行排序操作,当 i 指向5时,8&gt;5,进入循环 j,将8赋值给5所在的下标区域,循环 j 继续循环,走到6时发现6&gt;tmp=5,所以将6给它右边的第一个值(j+1的位置),继续执行 j 循环,直到 j = 0,4&lt;5时,则 j+1的位置为5,跳出循环 j,接着执行循环 i,最后完成排序.\n算法适用于少量数据的排序，时间复杂度为O(n^2)。是稳定的排序方法。\n时间复杂度为O(n^2),\n\n代码实现:\nint[] array = new int[]&#123;4, 6, 8, 5, 9&#125;;\nint i;\nint j;\n//从第二个元素开始循环数组\nfor (i = 1; i &lt; array.length; i++) &#123;\n    int tmp = array[i];//将元素赋予tmp\n\n    //从i-1个元素开始循环 判断array[j]是否大于tmp 如果大于则进入循环 开始交换\n    for (j = i - 1; j > 0 &amp;&amp; array[j] > tmp; j--) &#123;\n        //向右移动 腾出左边的空间\n        array[j + 1] = array[j];\n    &#125;\n    //将tmp的数插入到合适的位置\n    array[j + 1] = tmp;\n&#125;\n\n冒泡排序基本思想:冒泡排序,类似于水中冒泡,较大的数沉下去,较小的数慢慢冒出,假设从小到大,则大的往上浮,小的往下沉.说白了,就是每遍历一趟,将最大的数移动至末尾.\n比较相邻两个元素,如果前一个比后一个大,则交换.\n第一趟比较,第一个和第二个比较交换,然后第二个和第三个比较交换,这样下来,最大的会到最后面,接着是下一趟.\n冒泡排序最好的时间复杂度为O(n)。冒泡排序的最坏时间复杂度为O(n^2)。因此冒泡排序总的平均时间复杂度为O(n^2)。\n\n代码实现:\nint[] array = new int[]&#123;4, 6, 8, 5, 9&#125;;\nfor (int i = 0; i &lt; array.length; i++) &#123;\n    for (int j = i; j &lt; array.length; j++) &#123;\n        if (array[i] > array[j]) &#123;\n            //交换\n            int tmp = array[j];\n            array[j] = array[i];\n            array[i] = tmp;\n        &#125;\n    &#125;\n&#125;\n\n选择排序基本思想:每次排序中选择最大或最小的一个元素,存放在序列的初始位置,直到全部元素完成排序.\n选择排序是不稳定的排序方法。时间复杂度 O(n^2)。\n\n代码实现:\nint[] arr = &#123;2, 5, 4, 3, 8, 6, 4&#125;;\nint sub = 0;\nfor (int i = 0; i &lt; arr.length; i++) &#123;\n    sub = i;\n    for (int j = i + 1; j &lt; arr.length; j++) &#123;\n        if(arr[sub] &lt; arr[j])&#123;\n            sub = j;\n        &#125;\n    &#125;\n\n    if(sub != i)&#123;\n        int temp = arr[sub];\n        arr[sub] = arr[i];\n        arr[i] = temp;\n    &#125;\n&#125;\n\n希尔排序基本思想:先取一个小于n的整数d1作为第一个增量，把文件的全部记录分组。所有距离为d1的倍数的记录放在同一个组中。先在各组内进行直接插入排序；然后，取第二个增量d2&lt;d1重复上述的分组和排序，直至所取的增量dt=1(dt&lt;dt-1…&lt;d2&lt;d1)，即所有记录放在同一组中进行直接插入排序为止。\n希尔排序不稳定，时间复杂度 平均时间 O(nlogn) 最差时间O(n^2)\nint[] arr = &#123;3, -1, 45, 98, 1, 34, 56, 0, -2, -89, 2&#125;;\n\n//控制希尔变量\nfor (int gap = arr.length / 2; gap > 0; gap /= 2) &#123;\n    for (int i = gap; i &lt; arr.length; i++) &#123;\n        for (int j = i - gap; j >= 0; j -= gap) &#123;\n            if (arr[j] > arr[j + gap]) &#123;\n                int temp = arr[j];\n                arr[j] = arr[j + gap];\n                arr[j + gap] = temp;\n            &#125;\n        &#125;\n    &#125;\n&#125;\n\n参考视频:希尔排序动画演示\n堆排序参考插入排序/希尔排序:https://blog.csdn.net/qq_33289077/article/details/90370899\n选择排序:https://www.jianshu.com/p/51100da14cc2\n","categories":["排序"],"tags":["排序"]},{"title":"Java-集合","url":"/2021/06/18/Java-%E9%9B%86%E5%90%88/","content":"Java集合Java集合是学习Java中必须掌握的,面试也会经常问道.\nJava集合框架图\n\n从上面可以看出,集合主要分两大类,一种是Collection,存储的是元素集合,另一种是Map,存储Key/Value,其中Collection又分为List、Set和Queue在下面也是一些抽象类,最后是具体实现类,常用的有 ArrayList、LinkedList、HashSet、LinkedHashSet、HashMap、LinkedHashMap等等.\n集合接口\n\n\n接口\n接口描述\n\n\n\nCollection\nCollection是最基本的集合接口,一个Collection代表一组Object,即Collection的元素,Java不提供直接继承Collection的类,只提供继承于的子接口(如List和Set).Collection接口存储一组不唯一,无序的对象.\n\n\nList\nList是有序的Collection,能精确的控制每一个元素的插入位置,能通过索引访问List中的元素,允许有相同的元素.List接口存储一组不唯一,有序的对象.\n\n\nSet\n具有和Collection完全一样的接口,Set不保存重复的元素,Set接口存储一组唯一,无需的对象.\n\n\nSortedSet\n继承于Set保存有序的集合\n\n\nMap\n存储键值对的对象\n\n\nMap.Entry\n描述Map中的一个元素,是Map的内部接口\n\n\nSortedMap\n继承于Map,使Key保存在升序排序\n\n\nEnumeration\n这是一个传统的接口和定义的方法，通过它可以枚举（一次获得一个）对象集合中的元素。这个传统接口已被迭代器取代。\n\n\nSet和List的区别\nSet接口保存实例存储的是无序的,不重复的,List接口则是有序的,可以重复的元素\nSet检索效率低下,删除和插入如效率高,插入和删除不会引起元素位置的改变 &lt;实现类有HashSet,TreeSet&gt;\nList和数组类似,可以动态增长,根据实际存储的数据的长度自动增长List的长度,查找元素效率高,插入和删除效率低,因为会引起其他元素位置改变**&lt;实现类有ArrayList,LinkedList,Vector&gt;** \n\n常用集合ArrayListArrayList是可以动态修改的数组,于普通数组的区别就是没有固定的大小限制,我们可以添加或删除数据\nArrayList继承了AbstractList并实现了List接口\n\nArrayList常用方法\n\n\n\n方法\n描述\n\n\n\nadd()\n将元素插入到指定位置的 arraylist 中\n\n\naddAll()\n添加集合中的所有元素到 arraylist 中\n\n\nclear()\n删除 arraylist 中的所有元素\n\n\nclone()\n复制一份 arraylist\n\n\ncontains()\n判断元素是否在 arraylist\n\n\nget()\n通过索引值获取 arraylist 中的元素\n\n\nindexOf()\n返回 arraylist 中元素的索引值\n\n\nremoveAll()\n删除存在于指定集合中的 arraylist 里的所有元素\n\n\nremove()\n删除 arraylist 里的单个元素\n\n\nsize()\n返回 arraylist 里元素数量\n\n\nisEmpty()\n判断 arraylist 是否为空\n\n\nsubList()\n截取部分 arraylist 的元素\n\n\nset()\n替换 arraylist 中指定索引的元素\n\n\nsort()\n对 arraylist 元素进行排序\n\n\ntoArray()\n将 arraylist 转换为数组\n\n\ntoString()\n将 arraylist 转换为字符串\n\n\nensureCapacity()\n设置指定容量大小的 arraylist\n\n\nlastIndexOf()\n返回指定元素在 arraylist 中最后一次出现的位置\n\n\nretainAll()\n保留 arraylist 中在指定集合中也存在的那些元素\n\n\ncontainsAll()\n查看 arraylist 是否包含指定集合中的所有元素\n\n\ntrimToSize()\n将 arraylist 中的容量调整为数组中的元素个数\n\n\nremoveRange()\n删除 arraylist 中指定索引之间存在的元素\n\n\nreplaceAll()\n将给定的操作内容替换掉数组中每一个元素\n\n\nremoveIf()\n删除所有满足特定条件的 arraylist 元素\n\n\nforEach()\n遍历 arraylist 中每一个元素并执行特定操作\n\n\n排序\nCollections.sort(YourList);\nLinkedList链表是一种常见的基本数据结构,是一种线性表,但并不会按线性顺序存储数据,而是在每一个节点里存到下一个节点的地址.\n链表有单向和双向链表之分.\n单向链表包含两个值:当前节点的值和指向下一个节点的链接\n\n双向链表有三个数值:向前的节点链接,数值,向后的节点链接\n\n于ArrayList相比,LinkedList的增加和删除效率更高,而查找和修改的操作效率低\n以下情况使用ArrayList\n\n频繁访问列表的某一个元素\n只需要在列表末尾添加或删除操作\n\n以下情况使用LinkedList\n\n需要通过循环迭代来访问列表中的某些元素\n需要频繁的在列表开头,中间,末尾等位置进行添加和删除元素操作\n\nLinkedList 继承了 AbstractSequentialList 类。\nLinkedList 实现了 Queue 接口，可作为队列使用。\nLinkedList 实现了 List 接口，可进行列表的相关操作。\nLinkedList 实现了 Deque 接口，可作为队列使用。\nLinkedList 实现了 Cloneable 接口，可实现克隆。\nLinkedList 实现了 java.io.Serializable 接口，即可支持序列化，能通过序列化去传输。\n\n常用方法\n\n\n\n方法\n描述\n\n\n\npublic boolean add(E e)\n链表末尾添加元素，返回是否成功，成功为 true，失败为 false。\n\n\npublic void add(int index, E element)\n向指定位置插入元素。\n\n\npublic boolean addAll(Collection c)\n将一个集合的所有元素添加到链表后面，返回是否成功，成功为 true，失败为 false。\n\n\npublic boolean addAll(int index, Collection c)\n将一个集合的所有元素添加到链表的指定位置后面，返回是否成功，成功为 true，失败为 false。\n\n\npublic void addFirst(E e)\n元素添加到头部。\n\n\npublic void addLast(E e)\n元素添加到尾部。\n\n\npublic boolean offer(E e)\n向链表末尾添加元素，返回是否成功，成功为 true，失败为 false。\n\n\npublic boolean offerFirst(E e)\n头部插入元素，返回是否成功，成功为 true，失败为 false。\n\n\npublic boolean offerLast(E e)\n尾部插入元素，返回是否成功，成功为 true，失败为 false。\n\n\npublic void clear()\n清空链表。\n\n\npublic E removeFirst()\n删除并返回第一个元素。\n\n\npublic E removeLast()\n删除并返回最后一个元素。\n\n\npublic boolean remove(Object o)\n删除某一元素，返回是否成功，成功为 true，失败为 false。\n\n\npublic E remove(int index)\n删除指定位置的元素。\n\n\npublic E poll()\n删除并返回第一个元素。\n\n\npublic E remove()\n删除并返回第一个元素。\n\n\npublic boolean contains(Object o)\n判断是否含有某一元素。\n\n\npublic E get(int index)\n返回指定位置的元素。\n\n\npublic E getFirst()\n返回第一个元素。\n\n\npublic E getLast()\n返回最后一个元素。\n\n\npublic int indexOf(Object o)\n查找指定元素从前往后第一次出现的索引。\n\n\npublic int lastIndexOf(Object o)\n查找指定元素最后一次出现的索引。\n\n\npublic E peek()\n返回第一个元素。\n\n\npublic E element()\n返回第一个元素。\n\n\npublic E peekFirst()\n返回头部元素。\n\n\npublic E peekLast()\n返回尾部元素。\n\n\npublic E set(int index, E element)\n设置指定位置的元素。\n\n\npublic Object clone()\n克隆该列表。\n\n\npublic Iterator descendingIterator()\n返回倒序迭代器。\n\n\npublic int size()\n返回链表元素个数。\n\n\npublic ListIterator listIterator(int index)\n返回从指定位置开始到末尾的迭代器。\n\n\npublic Object[] toArray()\n返回一个由链表元素组成的数组。\n\n\npublic T[] toArray(T[] a)\n返回一个由链表元素转换类型而成的数组。\n\n\nHashMapHashMap是一个散列表,存储键值对,实现了Mao接口,根据键的HashCode值存储数据,具有很快的访问速度,最多允许一条记录的键为null,不支持线程同步.\nHashMap是无序的,HashMap 继承于AbstractMap，实现了 Map、Cloneable、java.io.Serializable 接口。\n\nHashMap的key和Value可以相同也可以不相同\n常用方法\n\n\n\n方法\n描述\n\n\n\nclear()\n删除 hashMap 中的所有键/值对\n\n\nclone()\n复制一份 hashMap\n\n\nisEmpty()\n判断 hashMap 是否为空\n\n\nsize()\n计算 hashMap 中键/值对的数量\n\n\nput()\n将键/值对添加到 hashMap 中\n\n\nputAll()\n将所有键/值对添加到 hashMap 中\n\n\nputIfAbsent()\n如果 hashMap 中不存在指定的键，则将指定的键/值对插入到 hashMap 中。\n\n\nremove()\n删除 hashMap 中指定键 key 的映射关系\n\n\ncontainsKey()\n检查 hashMap 中是否存在指定的 key 对应的映射关系。\n\n\ncontainsValue()\n检查 hashMap 中是否存在指定的 value 对应的映射关系。\n\n\nreplace()\n替换 hashMap 中是指定的 key 对应的 value。\n\n\nreplaceAll()\n将 hashMap 中的所有映射关系替换成给定的函数所执行的结果。\n\n\nget()\n获取指定 key 对应对 value\n\n\ngetOrDefault()\n获取指定 key 对应对 value，如果找不到 key ，则返回设置的默认值\n\n\nforEach()\n对 hashMap 中的每个映射执行指定的操作。\n\n\nentrySet()\n返回 hashMap 中所有映射项的集合集合视图。\n\n\nkeySet()\n返回 hashMap 中所有 key 组成的集合视图。\n\n\nvalues()\n返回 hashMap 中存在的所有 value 值。\n\n\nmerge()\n添加键值对到 hashMap 中\n\n\ncompute()\n对 hashMap 中指定 key 的值进行重新计算\n\n\ncomputeIfAbsent()\n对 hashMap 中指定 key 的值进行重新计算，如果不存在这个 key，则添加到 hasMap 中\n\n\ncomputeIfPresent()\n对 hashMap 中指定 key 的值进行重新计算，前提是该 key 存在于 hashMap 中。\n\n\nHashSetHashSet基于HashMap来实现,是一个不允许有重复元素的集合.\nHashSet允许有空值.是无序的,不是线程安全的.\nHashSet实现了Set接口\n\n","categories":["Java"],"tags":["Java","集合"]},{"title":"SpringBoot-Shiro","url":"/2021/05/21/SpringBoot-Shiro/","content":"Shiro介绍跟SpringSecurity一样，它也是一个鉴权授权项目，属于Apache开源的一个轻量级框架，没用SpringSecurity复杂。\nShiro架构图：\n\n\nSubject：与应用交互的主体，例如用户，第三方应用等。\n\nSecurityManager：shiro的核心，负责整合所有的组件，使他们能够方便快捷完成某项功能。例如：身份验证，权限验证等。\n\nAuthenticator：认证器，负责主体认证的，这是一个扩展点，如果用户觉得Shiro默认的不好，可以自定义实现；其需要认证策略（Authentication Strategy），即什么情况下算用户认证通过了。\n\nAuthorizer：决定主体是否有权限进行相应的操作；即控制着用户能访问应用中的哪些功能。\n\nSessionManager：会话管理。\n\nSessionDAO：数据访问对象，对session进行CRUD。\n\nCacheManager：缓存管理器。创建和管理缓存，为 authentication, authorization 和 session management 提供缓存数据，避免直接访问数据库，提高效率。\n\nCryptography；密码模块，提供加密组件。\n\nRealms：可以有1个或多个Realm，可以认为是安全实体数据源，即用于获取安全实体的；可以是JDBC实现，也可以是LDAP实现，或者内存实现等等；由用户提 供；注意：Shiro不知道你的用户/权限存储在哪及以何种格式存储；所以我们一般在应用中都需要实现自己的Realm。\n\n\nSpringBoot整合Shiro1.导入Shiro有两种方式\n其一：使用普通Shiro包\n&lt;dependency&gt;\n    &lt;groupId&gt;org.apache.shiro&lt;/groupId&gt;\n    &lt;artifactId&gt;shiro-spring-boot-web-starter&lt;/artifactId&gt;\n    &lt;version&gt;1.7.1&lt;/version&gt;\n&lt;/dependency&gt;\n\n其二：使用Starter包导入（本文使用），两者相比较，无法就是简化了一些代码，使用差别基本没用\n&lt;dependency&gt;\n    &lt;groupId&gt;org.apache.shiro&lt;/groupId&gt;\n    &lt;artifactId&gt;shiro-spring-boot-web-starter&lt;/artifactId&gt;\n    &lt;version&gt;1.7.1&lt;/version&gt;\n&lt;/dependency&gt;\n\n2.自定义Realm//自定义的Realm需要继承AuthorizingRealm\npublic class CustomRealm extends AuthorizingRealm &#123;\n\n    @Autowired\n    private UserService userService;\n\n    //告诉shiro如何根据获取到的用户信息中的密码和盐值来校验密码\n    //说白了，就是Shiro会加密用户登录的密码然后和数据库的密码进行比较\n    //这个有很多实现类，这里只演示这种\n    &#123;\n        //设置用于匹配密码的CredentialsMatcher\n        HashedCredentialsMatcher hashMatcher = new HashedCredentialsMatcher();\n        hashMatcher.setHashAlgorithmName(&quot;MD5&quot;);\n        hashMatcher.setHashIterations(1024);\n        this.setCredentialsMatcher(hashMatcher);//将CredentialsMatcher添加进Realm\n    &#125;\n\n    //定义如何获取用户的角色和权限的逻辑，给shiro做权限判断\n    @Override\n    protected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principals) &#123;\n        System.out.println(&quot;执行了授权操作&quot;);\n        if (principals == null) &#123;\n            throw new AuthorizationException(&quot;PrincipalCollection 方法参数不能为 null。&quot;);\n        &#125;\n\n        User user = (User) getAvailablePrincipal(principals);\n        //或(User) SecurityUtils.getSubject().getPrincipal()//这个可以在很多地方用不局限于这里\n\n        SimpleAuthorizationInfo info = new SimpleAuthorizationInfo();\n        \n        //https://shiro.apache.org/java-authorization-guide.html\n        //Shiro中权限分为Role和perms\n        info.addStringPermission(user.getPerms());//写入用户权限，这里权限直接写在了User表中\n\n        return info;\n    &#125;\n\n    //定义如何获取用户信息的业务逻辑，给shiro做登录\n    @Override\n    protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken token) throws AuthenticationException &#123;\n        System.out.println(&quot;执行了认证操作&quot;);\n        UsernamePasswordToken upToken = (UsernamePasswordToken) token;\n        String username = upToken.getUsername();\n\n        // 空用户名无效\n        if (username == null) &#123;\n            throw new AccountException(&quot;不允许空用户名。&quot;);\n        &#125;\n\n        //在数据库中根据username获取用户\n        User userDB = userService.findUserByName(username);\n\n\n        if (userDB == null) &#123;\n            throw new UnknownAccountException(&quot;找不到帐户[&quot; + username + &quot;]&quot;);\n        &#125;\n\n        //将用户写入 由Shiro进行比对 这里的密码是加密后的\n        SimpleAuthenticationInfo info = new SimpleAuthenticationInfo(userDB, userDB.getPassword(), ByteSource.Util.bytes(userDB.getSalt()), getName());\n        return info;\n    &#125;\n\n&#125;\n\n3.配置Shiro@Configuration\npublic class ShiroConfig &#123;\n    \n    //将自己自定义的Realm写入容器\n    @Bean\n    CustomRealm customRealm() &#123;\n        return new CustomRealm();\n    &#125;\n\n    //安全管理器\n    @Bean\n    DefaultWebSecurityManager securityManager() &#123;\n        DefaultWebSecurityManager manager = new DefaultWebSecurityManager();\n        manager.setRealm(customRealm());\n        return manager;\n    &#125;\n\n    //这里就是配置路径访问权限的，也可以通过注解\n    @Bean\n    public ShiroFilterChainDefinition shiroFilterChainDefinition() &#123;\n        DefaultShiroFilterChainDefinition chainDefinition = new DefaultShiroFilterChainDefinition();\n\n        // 具有user:admin权限登录\n        chainDefinition.addPathDefinition(&quot;/admin/**&quot;, &quot;authc, perms[user:admin]&quot;);//roles[admin]\n\n        // 所有人皆可以访问\n        chainDefinition.addPathDefinition(&quot;/**&quot;, &quot;anon&quot;);\n        return chainDefinition;\n    &#125;\n&#125;\n\n注解做控制：\n\n|          注解           |                 功能                 |\n| :---------------------: | :----------------------------------: |\n|     @RequiresGuest      |           只有游客可以访问           |\n| @RequiresAuthentication |           需要登录才能访问           |\n|      @RequiresUser      |  已登录的用户或“记住我”的用户能访问  |\n|     @RequiresRoles      | 已登录的用户需具有指定的角色才能访问 |\n|  @RequiresPermissions   | 已登录的用户需具有指定的权限才能访问 |\n\n只用url配置控制鉴权授权：\n\n| 配置缩写          | 对应的过滤器                   | 功能                                                         |\n| ----------------- | ------------------------------ | ------------------------------------------------------------ |\n| anon              | AnonymousFilter                | 指定url可以匿名访问                                          |\n| authc             | FormAuthenticationFilter       | 指定url需要form表单登录，默认会从请求中获取`username`、`password`,`rememberMe`等参数并尝试登录，如果登录不了就会跳转到loginUrl配置的路径。我们也可以用这个过滤器做默认的登录逻辑，但是一般都是我们自己在控制器写登录逻辑的，自己写的话出错返回的信息都可以定制嘛。 |\n| authcBasic        | BasicHttpAuthenticationFilter  | 指定url需要basic登录                                         |\n| logout            | LogoutFilter                   | 登出过滤器，配置指定url就可以实现退出功能，非常方便          |\n| noSessionCreation | NoSessionCreationFilter        | 禁止创建会话                                                 |\n| perms             | PermissionsAuthorizationFilter | 需要指定权限才能访问                                         |\n| port              | PortFilter                     | 需要指定端口才能访问                                         |\n| rest              | HttpMethodPermissionFilter     | 将http请求方法转化成相应的动词来构造一个权限字符串，这个感觉意义不大，有兴趣自己看源码的注释 |\n| roles             | RolesAuthorizationFilter       | 需要指定角色才能访问                                         |\n| ssl               | SslFilter                      | 需要https请求才能访问                                        |\n| user              | UserFilter                     | 需要已登录或“记住我”的用户才能访问                           |\n\n使用两者结合是最好的。\n\n### 4.YML配置\n\n```yaml\nshiro:\n  unauthorizedUrl: /403\n  successUrl: /index\n  loginUrl: /login\n\n参考官网：https://shiro.apache.org/spring-boot.html#web-applications\n文章1：https://programmer.ink/think/simple-authentication-example-with-spring-boot-2-shiro.html\n文章2：https://segmentfault.com/a/1190000014479154\n文章3：https://blog.csdn.net/u014553029/article/details/106579537/\n文章5：https://blog.csdn.net/pengjunlee/article/details/95600843\n文章6：https://blog.csdn.net/u011478348/article/details/104123407\n","categories":["SpringBoot"],"tags":["Spring","SpringBoot","Shiro"]},{"title":"SpringBoot-SpringSecurity","url":"/2021/05/18/SpringBoot-SpringSecurity/","content":"SpringSecurity简介SpringSecurity是Spring安全框架中的一员，在SpringBoot出现之前，SpringSecurity已经发展了许久了，但使用并不多，这个领域一直都是Shiro的天下。\n相对于Shiro，在SSM/SSH中整合SpringSecurity都是比较麻烦的，所以即使SpringSecurity功能比Shiro强大，但使用反而没Shiro多（虽然Shiro功能没用SpringSecurity多，但绝大部分项目而言，已经够用了）。\nSpringBoot出来以后，对SpringSecurity提供了自动化配置方案，可以零配置使用SpringSecurity。\n所以常见的技术栈组合是如下：\n\nSSM + Shiro\nSpringBoot + SpringSecurity\n\n回到SpringSecurity，它的核心实现就是维护了一组过滤器链。\n基本使用创建项目，引入依赖\n&lt;dependency&gt;\n    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n    &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt;\n&lt;/dependency&gt;\n&lt;!--可选--&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n    &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt;\n&lt;/dependency&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;org.springframework.security&lt;/groupId&gt;\n    &lt;artifactId&gt;spring-security-test&lt;/artifactId&gt;\n    &lt;scope&gt;test&lt;/scope&gt;\n&lt;/dependency&gt;\n\n随意编写Controller\n@Controller\npublic class RouterController &#123;\n    @GetMapping(&#123;&quot;/&quot;,&quot;/index&quot;&#125;)\n    public String index()&#123;\n        return &quot;index&quot;;\n    &#125;\n\n    @GetMapping(&quot;/tologin&quot;)\n    public String tologin()&#123;\n        return &quot;views/login&quot;;\n    &#125;\n\n    @GetMapping(&quot;/level1/&#123;id&#125;&quot;)\n    public String level1(@PathVariable(&quot;id&quot;) int id)&#123;\n        return &quot;views/level1/&quot;+id;\n    &#125;\n\n    @GetMapping(&quot;/level2/&#123;id&#125;&quot;)\n    public String level2(@PathVariable(&quot;id&quot;) int id)&#123;\n        return &quot;views/level2/&quot;+id;\n    &#125;\n\n    @GetMapping(&quot;/level3/&#123;id&#125;&quot;)\n    public String level3(@PathVariable(&quot;id&quot;) int id)&#123;\n        return &quot;views/level3/&quot;+id;\n    &#125;\n&#125;\n\n默认情况下，引入了SpringSecurity，所有的页面都需要进行认证\n编写配置类，修改默认配置\n//@Configuration\n@EnableWebSecurity\npublic class SecurityConfig extends WebSecurityConfigurerAdapter  &#123;\n\n    //这里可以配置一些忽略拦截项 当然也可以下面走匿名访问 不建议\n    @Override\n    public void configure(WebSecurity web) throws Exception &#123;\n        //静态资源过滤\n        web.ignoring().antMatchers(&quot;/resources/**&quot;);\n        //过滤某个路由\n        web.ignoring().antMatchers(&quot;/vercode&quot;);\n    &#125;\n\n    @Override\n    protected void configure(HttpSecurity http) throws Exception &#123;\n        http.authorizeRequests()\n                //为不同的访问路径配置不同的权限\n                .antMatchers(&quot;/level1/**&quot;).hasAnyRole(&quot;vip1&quot;,&quot;vip2&quot;,&quot;vip3&quot;)\n                .antMatchers(&quot;/level2/**&quot;).hasAnyRole(&quot;vip2&quot;,&quot;vip3&quot;)\n                .antMatchers(&quot;/level3/**&quot;).hasAnyRole(&quot;vip3&quot;)\n                //剩下的路径设置为所有人皆可访问\n                .anyRequest().permitAll();\n        \n        //配置登录相关\n        http.formLogin()\n            //登录页所在路由 默认/login\n            .loginPage(&quot;/tologin&quot;)\n            //登录表单发送目标的地址 如果不配置 默认是你的登录页所在路由\n            .loginProcessingUrl(&quot;/login&quot;)\n            //表单中参数的名称 默认username password\n            .usernameParameter(&quot;name&quot;)\n            .passwordParameter(&quot;pwd&quot;)\n            .successHandler(new AuthenticationSuccessHandler() &#123;\n                    @Override\n                    public void onAuthenticationSuccess(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Authentication authentication) throws IOException, ServletException &#123;\n                        //判断请求是异步(返回JSON)还是同步(返回页面)\n                        String xRequestedWith = request.getHeader(&quot;x-requested-with&quot;);//通过请求头判断\n                        if(&quot;XMLHttpRequest&quot;.equals(xRequestedWith))&#123;//异步返回\n                            response.setContentType(&quot;application/plain;charset=utf-8&quot;);\n                            PrintWriter writer = response.getWriter();\n                            writer.write(CommunityUtil.getJSONString(403,&quot;你还没有登录&quot;));\n                        &#125;else &#123;//同步返回\n                            response.sendRedirect(request.getContextPath()+&quot;/login&quot;);\n                        &#125;\n                    &#125;\n                &#125;)\n            .failureHandler(new AuthenticationFailureHandler() &#123;\n                    @Override\n                    public void onAuthenticationFailure(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, AuthenticationException e) throws IOException, ServletException &#123;\n                        //同上\n                    &#125;\n                &#125;)\n        \n        //退出登录相关配置 差不多和上面一样 源码中有简易的教学Demo\n        http.logout();\n        \n        //记住我功能，如果你使用的是自定义登录页面，需要自己写选择框\n        http.rememberMe()\n            //表单中参数的名称\n            .rememberMeParameter(&quot;remember&quot;);\n    &#125;\n\n    @Override\n    protected void configure(AuthenticationManagerBuilder auth) throws Exception &#123;\n        //添加账户，向内存中，一般用来测试用的，实际开发一般不这么玩\n        //BCryptPasswordEncoder是SpringSecurity提供的密码编码工具，可以非常方便的时间密码的加密和加盐，相同明文加密的密码完全不同\n        auth.inMemoryAuthentication().passwordEncoder(new BCryptPasswordEncoder())\n                .withUser(&quot;saber&quot;).password(new BCryptPasswordEncoder().encode(&quot;123&quot;)).roles(&quot;vip1&quot;)\n                .and()\n                .withUser(&quot;root&quot;).password(new BCryptPasswordEncoder().encode(&quot;123&quot;)).roles(&quot;vip1&quot;,&quot;vip2&quot;,&quot;vip3&quot;);\n    &#125;\n    //也可以通过配置文件配置\n    //spring.security.user.name=javaboy\n    //spring.security.user.password=123\n&#125;\n\n到此为止，一个大体的使用框架就搭建完成了，可以进行测试了\n更多使用登录成功和失败处理        http.formLogin()\n                .loginPage(&quot;/tologin&quot;)\n                .loginProcessingUrl(&quot;/login&quot;)\n                .usernameParameter(&quot;name&quot;)\n                .passwordParameter(&quot;pwd&quot;)\n                //登录成功于失败的跳转路由\n                .successForwardUrl(&quot;/success&quot;)\n                .failureForwardUrl(&quot;/failure&quot;);\n\n一般上面这种做法无法满足我们的需求，而且查看源码可知，底层就是一个forward跳转，我们知道forward跳转是无法跳到应用之外的页面的，由于这些功能往往会有比较复杂的逻辑，所以SpringSecurity给我们提供了.successHandler()方法去自己实现一个成功跳转逻辑，需要给他一个实现了AuthenticationSuccessHandler接口的类，它会去执行里面的onAuthenticationSuccess()方法\n        http.formLogin()\n                .loginPage(&quot;/tologin&quot;)\n                .loginProcessingUrl(&quot;/login&quot;)\n                .usernameParameter(&quot;name&quot;)\n                .passwordParameter(&quot;pwd&quot;)\n                //也可以使用简单的路径跳转，看需求 .successForwardUrl()\n                .successHandler(new AuthenticationSuccessHandler() &#123;\n                    //这里直接在这里实例化一个接口，也可以先创建一个类继承接口在实现，然后通过new的形式或注入的形式在这里使用\n                    @Override\n                    public void onAuthenticationSuccess(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Authentication authentication) throws IOException, ServletException &#123;\n                        //判断请求是异步(返回JSON)还是同步(返回页面)\n                        String xRequestedWith = httpServletRequest.getHeader(&quot;x-requested-with&quot;);//通过请求头判断\n                        if(&quot;XMLHttpRequest&quot;.equals(xRequestedWith))&#123;//异步返回\n                            httpServletResponse.setContentType(&quot;application/plain;charset=utf-8&quot;);\n                            PrintWriter writer = httpServletResponse.getWriter();\n                            writer.write(CommunityUtil.getJSONString(403,&quot;你还没有登录&quot;));\n                        &#125;else &#123;//同步返回\n                            httpServletResponse.sendRedirect(httpServletRequest.getContextPath()+&quot;/login&quot;);\n                        &#125;\n                    &#125;\n                &#125;)\n                .failureHandler(new AuthenticationFailureHandler() &#123;\n                    @Override\n                    public void onAuthenticationFailure(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, AuthenticationException e) throws IOException, ServletException &#123;\n                        \n                    &#125;\n                &#125;);\n\n上面采用了最简单的写法，可读性差，建议还是自己去继承并实现，然后通过new的方式或注入的方式提供给.successHandler()\n权限不足处理         //权限不够时\n        http.exceptionHandling()\n                .authenticationEntryPoint(new AuthenticationEntryPoint() &#123;\n                    //没有登录时处理\n                    @Override\n                    public void commence(HttpServletRequest request, HttpServletResponse response, AuthenticationException e) throws IOException, ServletException &#123;\n                        //判断请求是异步(返回JSON)还是同步(返回页面)\n                        String xRequestedWith = request.getHeader(&quot;x-requested-with&quot;);//通过请求头判断\n                        if(&quot;XMLHttpRequest&quot;.equals(xRequestedWith))&#123;//异步返回\n                            response.setContentType(&quot;application/plain;charset=utf-8&quot;);\n                            PrintWriter writer = response.getWriter();\n                            writer.write(CommunityUtil.getJSONString(403,&quot;你还没有登录&quot;));\n                        &#125;else &#123;//同步返回\n                            response.sendRedirect(request.getContextPath()+&quot;/login&quot;);\n                        &#125;\n                    &#125;\n                &#125;)\n                .accessDeniedHandler(new AccessDeniedHandler() &#123;\n                    //权限不足时处理\n                    @Override\n                    public void handle(HttpServletRequest request, HttpServletResponse response, AccessDeniedException e) throws IOException, ServletException &#123;\n                        //判断请求是异步(返回JSON)还是同步(返回页面)\n                        String xRequestedWith = request.getHeader(&quot;x-requested-with&quot;);//通过请求头判断\n                        if(&quot;XMLHttpRequest&quot;.equals(xRequestedWith))&#123;//异步返回\n                            response.setContentType(&quot;application/plain;charset=utf-8&quot;);\n                            PrintWriter writer = response.getWriter();\n                            writer.write(CommunityUtil.getJSONString(403,&quot;权限不足&quot;));\n                        &#125;else &#123;//同步返回\n                            response.sendRedirect(request.getContextPath()+&quot;/denied&quot;);\n                        &#125;\n                    &#125;\n                &#125;);\n\n自定义登录逻辑自定义登录逻辑需要创建一个实现UserDetailsService接口的类，并把它注入到IOC容器中\n@Service\npublic class UserDetailsServiceImpl implements UserDetailsService &#123;\n\n    @Autowired\n    private PasswordEncoder passwordEncoder;\n\n    @Autowired\n    private UserMapper userMapper;\n\n    @Autowired\n    private RoleMapper roleMapper;\n\n    @Bean\n    private BCryptPasswordEncoder passwordEncoder() &#123;\n        return new BCryptPasswordEncoder();\n    &#125;\n\n    @Override\n    public UserDetails loadUserByUsername(String s) throws UsernameNotFoundException &#123;\n\n        com.example.security.entity.User u = userMapper.findUserByName(s);\n        System.out.println(u.toString());\n        if (u == null) &#123;\n            throw new UsernameNotFoundException(&quot;用户名不存在！&quot;);\n        &#125;\n        //比较密码，匹配成功会返回UserDetails，实际上也会去数据库查\n        String password = passwordEncoder.encode(u.getPassword());\n\n        //用于添加用户的权限。只要把用户权限添加到authorities。\n        List&lt;GrantedAuthority&gt; authorities = new ArrayList&lt;&gt;();\n        Role role = roleMapper.findRoleById((int) u.getRoleId());\n        if (role != null) &#123;\n            //使用Role和Authority都是这一套代码\n            //这里有给大坑 如果你使用Role进行授权的话，一定要如下加上 ROLE_\n            authorities.add(new SimpleGrantedAuthority(&quot;ROLE_&quot; + role.getRoleName()));\n        &#125;\n\n        User user = new User(u.getUsername(), password, authorities);\n        return user;\n    &#125;\n&#125;\n\n然后在配置类中添加如下(不是必须的，建议写上):\n@Autowired\nUserDetailsService userDetailsService;\n\n@Override\nprotected void configure(AuthenticationManagerBuilder auth) throws Exception &#123;\n    auth.userDetailsService(userDetailsService);\n&#125;\n\n认证授权注解在使用注解前需要在配置类或启动类上添加@EnableGlobalMethodSecurity表示开启注解认证授权\n@Secured需要在上面添加的注解中添加一个参数@EnableGlobalMethodSecurity(securedEnabled = true),开启这个注解的使用\n用户具有某个Role可以访问，在Controller中使用\n@GetMapping(&quot;/level1&quot;)\n@Secured(&#123;&quot;ROLE_vip1&quot;,&quot;ROLE_vip2&quot;,&quot;ROLE_vip3&quot;&#125;)\npublic String level1() &#123;\n    return &quot;level1&quot;;\n&#125;\n\n@GetMapping(&quot;/level2&quot;)\n@Secured(&#123;&quot;ROLE_vip2&quot;,&quot;ROLE_vip3&quot;&#125;)\npublic String level2() &#123;\n    return &quot;level2&quot;;\n&#125;\n\n@GetMapping(&quot;/level3&quot;)\n@Secured(&#123;&quot;ROLE_vip3&quot;&#125;)\npublic String level3() &#123;\n    return &quot;level3&quot;;\n&#125;\n\n@PreAuthorize需要在上面添加的注解中添加一个参数@EnableGlobalMethodSecurity(prePostEnabled = true),开启这个注解的使用\n进入方法执行之前进行验证\n@GetMapping(&quot;/level3&quot;)\n//@PreAuthorize(&quot;hasRole(&#39;ROLE_xxx&#39;)&quot;) 这里直接使用上面介绍过的方法名称 就根调用方法一样\n    @PreAuthorize(&quot;hasAnyAuthority(&#39;admin3&#39;)&quot;)\npublic String level3() &#123;\n    return &quot;level3&quot;;\n&#125;\n\n@PostAuthorize需要在上面添加的注解中添加一个参数@EnableGlobalMethodSecurity(prePostEnabled = true),开启这个注解的使用\n在方法执行之后判断是否有权限\n@GetMapping(&quot;/level3&quot;)\n@PostAuthorize(&quot;hasAnyAuthority(&#39;admin3&#39;)&quot;)\npublic String level3() &#123;\n    System.out.println(&quot;fwcg&quot;);\n    return &quot;level3&quot;;\n&#125;\n\n@PreFilter / @PostFilter对传入 / 传出的数据进行过滤 Spring Security将移除使对应表达式的结果为false的元素。\n@PostFilter(&quot;filterObject.id%2==0&quot;)\n@GetMapping(&quot;/getuser&quot;)\npublic List&lt;User&gt; findAll() &#123;\n    List&lt;User&gt; userList = new ArrayList&lt;User&gt;();\n    User user;\n    for (int i = 0; i &lt; 10; i++)&#123;\n        user = new User();\n        user.setId(i);\n        userList.add(user);\n    &#125;\n    System.out.println(userList);\n    return userList;\n&#125;\n\n上述代码表示将对返回结果中id不为偶数的user进行移除。filterObject是使用@PreFilter和@PostFilter时的一个内置表达式，表示集合中的当前对象\n当@PreFilter标注的方法拥有多个集合类型的参数时，需要通过@PreFilter的filterTarget属性指定当前@PreFilter是针对哪个参数进行过滤的。\n@PreFilter(filterTarget=&quot;ids&quot;, value=&quot;filterObject%2==0&quot;)\npublic void delete(List&lt;Integer&gt; ids, List&lt;String&gt; usernames) &#123;\n    ...\n&#125;\n\n记住我最简单的实现方式是储存在内存中，在配置类中添加如下代码即可\nhttp.rememberMe();//实现记住我自动登录，核心的代码只有这这一行\n\n如果你使用默认登录页，什么也不用做，但如果你是自定义的，请在页面中添加复选框，\n&lt;label&gt; &lt;input type=&quot;checkbox&quot; name=&quot;remember-me&quot; /&gt;记住我&lt;/label&gt;\n\n前端传值时SpringSecurity将读取键： remember-me，只能叫这个名，Ajax传递参数也必须为 remember-me，但后端可以通过.rememberMeParameter(&quot;xxx&quot;) 修改参数名称，还可以通过.rememberMeCookieName()修改Cookie中Key的名称\n.tokenValiditySeconds(60*2)这个可以修改有效时长默认2周，单位秒\nhttp.rememberMe()\n    .rememberMeParameter(&quot;rm&quot;)\n    .rememberMeCookieName(&quot;rm-cookie&quot;)\n    .tokenValiditySeconds(60*2);\n\n基于数据库的实现\n全部操作在配置类中\n先注入数据源\n@Autowired\nprivate DataSource dataSource;\n\n注入TokenRepostory组件\n@Bean\npublic PersistentTokenRepository persistentTokenRepository() &#123;\n    JdbcTokenRepositoryImpl jdbcTokenRepository = new JdbcTokenRepositoryImpl();\n    jdbcTokenRepository.setDataSource(dataSource);//使用数据源\n    jdbcTokenRepository.setCreateTableOnStartup(true);//创建数据表，第一次运行的时候使用，以后注释吊，不然报错\n    return jdbcTokenRepository;\n&#125;\n\n配置\nhttp.rememberMe()\n    .rememberMeParameter(&quot;rm&quot;)\n    .rememberMeCookieName(&quot;rm-cookie&quot;)\n    .tokenRepository(persistentTokenRepository())\n    .tokenValiditySeconds(60*2);\n    //.userDetailsService(userDetailsService);//如果上面自定义登录中直接指示了auth.userDetailsService(userDetailsService);这里可以不写\n\n这样即可\n整合JWT导入依赖&lt;dependency&gt;\n    &lt;groupId&gt;io.jsonwebtoken&lt;/groupId&gt;\n    &lt;artifactId&gt;jjwt&lt;/artifactId&gt;\n    &lt;version&gt;0.9.1&lt;/version&gt;\n&lt;/dependency&gt;\n\n创建JWT工具类管理Token相关的操作\n/**\n * jwt 工具类 主要是生成token 检查token等相关方法\n */\npublic class JwtUtils &#123;\n\n    public static final String TOKEN_HEADER = &quot;Authorization&quot;;\n\n    public static final String TOKEN_PREFIX = &quot;Bearer &quot;;\n\n    // TOKEN 过期时间\n    public static final long EXPIRATION = 1000 * 60 * 30; // 三十分钟\n\n    public static final String APP_SECRET_KEY = &quot;secret&quot;;\n\n    private static final String ROLE_CLAIMS = &quot;rol&quot;;\n\n    /**\n     * 生成token\n     *\n     * @param username\n     * @param roles\n     * @return\n     */\n    public static String createToken(String username, List&lt;String&gt; roles) &#123;\n\n        Map&lt;String, Object&gt; map = new HashMap&lt;&gt;();\n        map.put(ROLE_CLAIMS, roles);\n\n        String token = Jwts\n                .builder()\n                .setSubject(username)\n                .setClaims(map)\n                .claim(&quot;username&quot;, username)\n                .setIssuedAt(new Date())\n                .setExpiration(new Date(System.currentTimeMillis() + EXPIRATION))\n                .signWith(SignatureAlgorithm.HS256, APP_SECRET_KEY).compact();\n        return token;\n    &#125;\n\n    /**\n     * 获取当前登录用户用户名\n     *\n     * @param token\n     * @return\n     */\n    public static String getUsername(String token) &#123;\n        Claims claims = Jwts.parser().setSigningKey(APP_SECRET_KEY).parseClaimsJws(token).getBody();\n        return claims.get(&quot;username&quot;).toString();\n    &#125;\n\n    /**\n     * 获取当前登录用户角色\n     *\n     * @param token\n     * @return\n     */\n    public static ArrayList&lt;String&gt; getUserRole(String token) &#123;\n        Claims claims = Jwts.parser().setSigningKey(APP_SECRET_KEY).parseClaimsJws(token).getBody();\n        ArrayList&lt;String&gt; rols = claims.get(&quot;rol&quot;, ArrayList.class);\n        return rols;\n    &#125;\n\n    /**\n     * 获解析token中的信息\n     *\n     * @param token\n     * @return\n     */\n    public static Claims checkJWT(String token) &#123;\n        try &#123;\n            final Claims claims = Jwts.parser().setSigningKey(APP_SECRET_KEY).parseClaimsJws(token).getBody();\n            return claims;\n        &#125; catch (Exception e) &#123;\n            e.printStackTrace();\n            return null;\n        &#125;\n    &#125;\n\n    /**\n     * 检查token是否过期\n     *\n     * @param token\n     * @return\n     */\n    public static boolean isExpiration(String token) &#123;\n        Claims claims = Jwts.parser().setSigningKey(APP_SECRET_KEY).parseClaimsJws(token).getBody();\n        return claims.getExpiration().before(new Date());\n    &#125;\n&#125;\n\n创建JwtUser类主要用于封装登录用户相关信息，例如用户名，密码，权限集合等，必须实现UserDetails接口\nimport org.springframework.security.core.GrantedAuthority;\nimport org.springframework.security.core.authority.SimpleGrantedAuthority;\nimport org.springframework.security.core.userdetails.UserDetails;\n\nimport java.util.Collection;\nimport java.util.Collections;\n\npublic class JwtUser implements UserDetails &#123;\n\n    private Integer id;\n    private String username;\n    private String password;\n    private Collection&lt;? extends GrantedAuthority&gt; authorities;\n\n    public JwtUser() &#123;\n    &#125;\n\n    // 写一个能直接使用user创建jwtUser的构造器\n    public JwtUser(User user, Collection&lt;? extends GrantedAuthority&gt; authorities) &#123;\n        id = Math.toIntExact(user.getId());\n        username = user.getUsername();\n        password = user.getPassword();\n        this.authorities = authorities;\n    &#125;\n\n    public Collection&lt;? extends GrantedAuthority&gt; getAuthorities() &#123;\n        return authorities;\n    &#125;\n\n    public String getPassword() &#123;\n        return password;\n    &#125;\n\n    public String getUsername() &#123;\n        return username;\n    &#125;\n\n    public boolean isAccountNonExpired() &#123;\n        return true;\n    &#125;\n\n    public boolean isAccountNonLocked() &#123;\n        return true;\n    &#125;\n\n    public boolean isCredentialsNonExpired() &#123;\n        return true;\n    &#125;\n\n    public boolean isEnabled() &#123;\n        return true;\n    &#125;\n&#125;\n\n创建JwtUserService类似于自定义登录逻辑，必须实现UserDetailsService\n@Service\npublic class JwtUserService implements UserDetailsService &#123;\n\n    @Autowired\n    private PasswordEncoder passwordEncoder;\n\n    @Autowired\n    private UserMapper userMapper;\n\n    @Autowired\n    private RoleMapper roleMapper;\n\n    @Bean\n    private BCryptPasswordEncoder passwordEncoder() &#123;\n        return new BCryptPasswordEncoder();\n    &#125;\n\n    /**\n     * 根据前端传入的用户信息 去数据库查询是否存在该用户\n     *\n     * @param s\n     * @return\n     * @throws UsernameNotFoundException\n     */\n    @Override\n    public UserDetails loadUserByUsername(String s) throws UsernameNotFoundException &#123;\n        User user = this.userMapper.findUserByName(s);\n\n        user.setPassword(passwordEncoder.encode(user.getPassword()));\n\n        //用于添加用户的权限。只要把用户权限添加到authorities。\n        List&lt;GrantedAuthority&gt; authorities = new ArrayList&lt;&gt;();\n        Role role = roleMapper.findRoleById((int) user.getRoleId());\n        if (role != null) &#123;\n            authorities.add(new SimpleGrantedAuthority(&quot;ROLE_&quot; + role.getRoleName()));\n        &#125;\n\n        if (user != null) &#123;\n            JwtUser jwtUser = new JwtUser(user, authorities);\n            return jwtUser;\n        &#125; else &#123;\n            try &#123;\n                throw new ValidationException(&quot;该用户不存在&quot;);\n            &#125; catch (ValidationException e) &#123;\n                e.printStackTrace();\n            &#125;\n        &#125;\n        return null;\n    &#125;\n&#125;\n\n自定义用户登录拦截器/**\n * 验证用户名密码正确后，生成一个token，并将token返回给客户端\n * 该类继承自UsernamePasswordAuthenticationFilter，重写了其中的2个方法 ,\n * attemptAuthentication：接收并解析用户凭证。\n * successfulAuthentication：用户成功登录后，这个方法会被调用，我们在这个方法里生成token并返回。\n */\npublic class JWTAuthenticationFilter extends UsernamePasswordAuthenticationFilter &#123;\n\n    private AuthenticationManager authenticationManager;\n\n    /**\n     * security拦截默认是以POST形式走/login请求，我们这边设置为走/token请求\n     *\n     * @param authenticationManager\n     */\n    public JWTAuthenticationFilter(AuthenticationManager authenticationManager) &#123;\n        this.authenticationManager = authenticationManager;\n        super.setFilterProcessesUrl(&quot;/token&quot;);\n    &#125;\n\n    /**\n     * 接收并解析用户凭证\n     *\n     * @param request\n     * @param response\n     * @return\n     * @throws AuthenticationException\n     */\n    @Override\n    public Authentication attemptAuthentication(HttpServletRequest request,\n                                                HttpServletResponse response) throws AuthenticationException &#123;\n        // 从输入流中获取到登录的信息\n        try &#123;\n            User loginUser = new ObjectMapper().readValue(request.getInputStream(), User.class);\n            return authenticationManager.authenticate(\n                    new UsernamePasswordAuthenticationToken(loginUser.getUsername(), loginUser.getPassword())\n            );\n        &#125; catch (IOException e) &#123;\n            e.printStackTrace();\n            return null;\n        &#125;\n    &#125;\n\n    // 成功验证后调用的方法\n    // 如果验证成功，就生成token并返回\n    @Override\n    protected void successfulAuthentication(HttpServletRequest request,\n                                            HttpServletResponse response,\n                                            FilterChain chain,\n                                            Authentication authResult) throws IOException, ServletException &#123;\n\n        JwtUser jwtUser = (JwtUser) authResult.getPrincipal();\n        System.out.println(&quot;jwtUser:&quot; + jwtUser.toString());\n\n        List&lt;String&gt; roles = new ArrayList&lt;&gt;();\n        Collection&lt;? extends GrantedAuthority&gt; authorities = jwtUser.getAuthorities();\n        for (GrantedAuthority authority : authorities) &#123;\n            roles.add(authority.getAuthority());\n        &#125;\n\n        String token = JwtUtils.createToken(jwtUser.getUsername(), roles);\n        // 返回创建成功的token  但是这里创建的token只是单纯的token\n        // 按照jwt的规定，最后请求的时候应该是 `Bearer token`\n        response.setCharacterEncoding(&quot;UTF-8&quot;);\n        response.setContentType(&quot;application/json; charset=utf-8&quot;);\n        String tokenStr = JwtUtils.TOKEN_PREFIX + token;\n        response.setHeader(&quot;token&quot;, tokenStr);\n    &#125;\n\n    // 失败 返回错误就行\n    @Override\n    protected void unsuccessfulAuthentication(HttpServletRequest request, HttpServletResponse response, AuthenticationException failed) throws IOException, ServletException &#123;\n        response.getWriter().write(&quot;authentication failed, reason: &quot; + failed.getMessage());\n    &#125;\n&#125;\n\n自定义权限拦截器假如admin登录成功后，携带token去请求其他接口时，该拦截器会判断权限是否正确\n/**\n * 登录成功之后走此类进行  鉴定 权限\n */\npublic class JWTAuthorizationFilter extends BasicAuthenticationFilter &#123;\n\n\n    public JWTAuthorizationFilter(AuthenticationManager authenticationManager) &#123;\n        super(authenticationManager);\n    &#125;\n\n    @Override\n    protected void doFilterInternal(HttpServletRequest request,\n                                    HttpServletResponse response,\n                                    FilterChain chain) throws IOException, ServletException &#123;\n\n        String tokenHeader = request.getHeader(JwtUtils.TOKEN_HEADER);\n        // 如果请求头中没有Authorization信息则直接放行了\n        if (tokenHeader == null || !tokenHeader.startsWith(JwtUtils.TOKEN_PREFIX)) &#123;\n            chain.doFilter(request, response);\n            return;\n        &#125;\n        // 如果请求头中有token，则进行解析，并且设置认证信息\n        try &#123;\n            SecurityContextHolder.getContext().setAuthentication(getAuthentication(tokenHeader));\n        &#125; catch (Exception e) &#123;\n            e.printStackTrace();\n        &#125;\n        super.doFilterInternal(request, response, chain);\n    &#125;\n\n    // 这里从token中获取用户信息并新建一个token 就是上面说的设置认证信息\n    private UsernamePasswordAuthenticationToken getAuthentication(String tokenHeader) throws Exception &#123;\n\n        String token = tokenHeader.replace(JwtUtils.TOKEN_PREFIX, &quot;&quot;);\n\n        // 检测token是否过期 如果过期会自动抛出错误\n        JwtUtils.isExpiration(token);\n        String username = JwtUtils.getUsername(token);\n        ArrayList&lt;String&gt; roles = JwtUtils.getUserRole(token);\n        List&lt;SimpleGrantedAuthority&gt; authorities = new ArrayList&lt;&gt;();\n        if (roles != null) &#123;\n            for (String role : roles) &#123;\n                authorities.add(new SimpleGrantedAuthority(role));\n            &#125;\n        &#125;\n        if (username != null) &#123;\n            return new UsernamePasswordAuthenticationToken(username, null, authorities);\n        &#125;\n        return null;\n    &#125;\n&#125;\n\nSpringSecurity配置@EnableWebSecurity\npublic class SecurityConfig extends WebSecurityConfigurerAdapter &#123;\n    @Autowired\n    JwtUserService jwtUserService;\n\n    @Autowired\n    private DataSource dataSource;\n\n    @Bean\n    public PersistentTokenRepository persistentTokenRepository() &#123;\n        JdbcTokenRepositoryImpl jdbcTokenRepository = new JdbcTokenRepositoryImpl();\n        jdbcTokenRepository.setDataSource(dataSource);\n//        jdbcTokenRepository.setCreateTableOnStartup(true);\n        return jdbcTokenRepository;\n    &#125;\n\n\n    @Override\n    public void configure(WebSecurity web) throws Exception &#123;\n        web.ignoring().antMatchers(&quot;/resources/**&quot;);\n    &#125;\n\n    @Override\n    protected void configure(HttpSecurity http) throws Exception &#123;\n        http.authorizeRequests()\n                .antMatchers(&quot;/level1/**&quot;).authenticated()//.hasAnyRole(&quot;vip1&quot;,&quot;vip2&quot;,&quot;vip3&quot;)\n                .antMatchers(&quot;/level2/**&quot;).authenticated()//.hasAnyRole(&quot;vip2&quot;,&quot;vip3&quot;)\n                .antMatchers(&quot;/level3/**&quot;).authenticated()//.hasAnyRole(&quot;vip3&quot;)\n                .anyRequest().permitAll();\n\n        http.addFilter(new JWTAuthenticationFilter(authenticationManager())) // 用户登录拦截\n            .addFilter(new JWTAuthorizationFilter(authenticationManager())) // 权限拦截\n            // 不需要session\n            .sessionManagement()\n            .sessionCreationPolicy(SessionCreationPolicy.STATELESS)\n            .and()\n            .exceptionHandling();\n\n        http.formLogin();\n\n        http.csrf().disable();\n\n        http.logout().logoutUrl(&quot;/logout&quot;).logoutSuccessUrl(&quot;/getuser&quot;);\n\n        http.rememberMe()\n                .rememberMeParameter(&quot;rm&quot;)\n                .rememberMeCookieName(&quot;rm-cookie&quot;)\n                .tokenRepository(persistentTokenRepository())\n                .tokenValiditySeconds(60*2);\n    &#125;\n\n    @Override\n    protected void configure(AuthenticationManagerBuilder auth) throws Exception &#123;\n        auth.userDetailsService(jwtUserService);\n    &#125;\n&#125;\n\n参考：官网：https://docs.spring.io/spring-security/site/docs/5.3.9.RELEASE/reference/html5/#servlet-applications\n视频：https://www.bilibili.com/video/BV15a411A7kP\n参考文章1：https://www.cnblogs.com/lenve/p/11242055.html\n参考文章2：https://www.jianshu.com/p/7817e372c1db\n参考文章3：https://blog.csdn.net/qq_42640067/article/details/113062222\n参考文章4：https://blog.csdn.net/qq_22172133/article/details/86503223\nJWT参考：https://blog.csdn.net/weixin_45452416/article/details/109528425\n","categories":["SpringBoot"],"tags":["Spring","SpringBoot","SpringSecurity"]},{"title":"SpringBoot-Elasticsearch","url":"/2021/05/07/SpringBoot-Elasticsearch/","content":"ElasticsearchElasticsearch 简介\n一个分布式的、Restful 风格的搜索引擎\n支持对各种类型的数据的检索\n搜索速度快，可以提供实时的搜索服务\n便于水平扩展，每秒可以处理 PB 级海量数据\n\nElasticsearch 术语\n索引、类型、文档、字段\n集群、节点、分片、副本\n\n索引可以理解为一个数据库\n类型为一张表\n文档为一条数据，通常为 JSON 结果\n字段为表中的列\n在 ES6 以后，逐渐废弃上面的类型，ES7(本文使用)彻底废除，由索引逐渐代替其功能\nElasticsearch 和 SpringBoot 是有版本对应的，点击查看\n下载Elasticsearch，在使用 ES 之前，还需要装一个ik 分词器，下载好之后，将其解压至 ES 的 plugins 文件夹中的 ik 文件夹(无则创建)\n在使用 ES 之前，我们最好简单更改一下其配置，在 config 目录下，找到 elasticsearch.yml，进行如下更改\n# 集群的名字 随意\ncluster.name: nowcoder\n# ES数据存储路径\npath.data: /home/gas/桌面/elasticsearch-7.12.0/data\n# 日志\npath.logs: /home/gas/桌面/elasticsearch-7.12.0/logs\n\n然后执行 bin 目录下的 elasticsearch 文件即可\nSpringBoot 使用 Elasticsearch1. Maven 引入&lt;!-- elasticsearch --&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n    &lt;artifactId&gt;spring-boot-starter-data-elasticsearch&lt;/artifactId&gt;\n&lt;/dependency&gt;\n\n2. yml 配置spring:\n  elasticsearch:\n    rest:\n      username: nowcoder #   填写上面自己配置的\n      uris: 127.0.0.1:9200 #   es的ip:port\n\n3. 配置 ES 实体类直接用现有的实体类就好，并不冲突\n//indexName：索引的名称\n//shards：分片\n//replicas：副本\n//type：7.x不用写\n@Document(indexName = &quot;discusspost&quot;, shards = 6, replicas = 3)\npublic class DiscussPost &#123;\n\n    //声明ID\n    @Id\n    private int id;\n\n    //声明类型\n    @Field(type = FieldType.Integer)\n    private int userId;\n\n    //后面两个是使用的分词器的名字，没什么必要无须更改，前面是存储数据时使用的解析器(存储时尽可能拆分出更多的词语进行存储)，后面是搜索时使用的解析器(搜索时无须过分分词)\n    @Field(type = FieldType.Text, analyzer = &quot;ik_max_word&quot;, searchAnalyzer = &quot;ik_smart&quot;)\n    private String title;\n\n    @Field(type = FieldType.Text, analyzer = &quot;ik_max_word&quot;, searchAnalyzer = &quot;ik_smart&quot;)\n    private String content;\n\n    //name：字段在es中的名称\n    @Field(name = &quot;type&quot;,type = FieldType.Integer)\n    private int type;\n    @Field(type = FieldType.Integer)\n    private int status;\n    @Field(name = &quot;createTime&quot;,type = FieldType.Date)\n    private Date createTime;\n    @Field(type = FieldType.Integer)\n    private int commentCount;\n    @Field(name = &quot;score&quot;,positiveScoreImpact = false,type = FieldType.Double)\n    private double score;\n&#125;\n\n4. 创建一个操作 ES 的类@Repository                                                         //&lt;处理的对象，对象的主键类型&gt;\npublic interface DiscussPostRepository extends ElasticsearchRepository&lt;DiscussPost,Integer&gt; &#123;\n    //高亮\n    @Highlight(\n            fields = &#123;\n                    @HighlightField(name = &quot;title&quot;),\n                    @HighlightField(name = &quot;content&quot;)\n            &#125;,parameters = @HighlightParameters(\n                    preTags = &quot;&lt;em&gt;&quot;,\n                    postTags = &quot;&lt;/em&gt;&quot;\n    ))\n    //Pageable包含了排序功能，如果你只需要排序，则替换成Sort sort即可，注意：Pageable和Sort不能同时存在\n    List&lt;SearchHit&lt;DiscussPost&gt;&gt; findDiscussPostByTitleLikeOrContentLike(String title,String content,Pageable pageable);\n    //注意，方法的名称findDiscussPostByTitleLikeOrContentLike可不是乱写的，是用含义的，底层会根据方法名称去构建搜索语句\n    //当然，也可以用@Query注解自定义搜索语句，下面是官方文档的声明\n    //https://docs.spring.io/spring-data/elasticsearch/docs/4.1.8/reference/html/#elasticsearch.query-methods\n&#125;\n\n5. 实际操作演示@Autowired\nprivate DiscussPostRepository discussPostRepository;\n\n//保存数据，这里是从数据库中读取了一条DiscussPost类型的数据存入es中\ndiscussPostRepository.save(discussPostMapper.selectDiscussPostById(230));\n//批量存储\ndiscussPostRepository.saveAll(discussPostMapper.selectDiscussPosts(101, 0, 100,0));\n//更新数据\nDiscussPost discussPost = discussPostMapper.selectDiscussPostById(231);\ndiscussPost.setContent(&quot;我是新人，使劲灌水&quot;);\ndiscussPostRepository.save(discussPost);\n//根据ID删除\ndiscussPostRepository.deleteById(231);\n//删除所有\ndiscussPostRepository.deleteAll();\n\n//搜索\npublic void Select()&#123;\n    Sort sort = Sort.by(&quot;score&quot;).descending()\n        .and(Sort.by(&quot;type&quot;).descending())\n        .and(Sort.by(&quot;createTime&quot;).descending());\n\n    List&lt;SearchHit&lt;DiscussPost&gt;&gt; post = discussPostRepository\n                                                                //分页数据第1页，10条数据，排序\n        .findDiscussPostByTitleLikeOrContentLike(&quot;压力数据&quot;, &quot;压力&quot;,PageRequest.of(1,10,sort));\n\n    post.forEach(res-&gt; &#123;\n        System.out.println(&quot;查询结果：&quot; + res);\n    &#125;);\n&#125;\n\n参考：\n官方文档：https://docs.spring.io/spring-data/elasticsearch/docs/4.1.8/reference/html/#repositories\n文章：https://zhuanlan.zhihu.com/p/321248369\n","categories":["SpringBoot"],"tags":["Spring","SpringBoot","Elasticsearch"]},{"title":"SpringBoot-Kafka","url":"/2021/05/02/SpringBoot-Kafka/","content":"什么是 KafkaKafka 最初由 Linkedin 公司开发，是一个分布式的、_分区的_、_多副本的_、_多订阅者_，基于 zookeeper 协调的分布式日志系统（也可以当做 MQ 系统），常用于 web/nginx 日志、访问日志、消息服务等等，Linkedin 于 2010 年贡献给了 Apache 基金会并成为顶级开源项目。\n\n高吞吐量、低延迟：kafka 每秒可以处理几十万条消息，它的延迟最低只有几毫秒；\n可扩展性：kafka 集群支持热扩展；\n持久性、可靠性：消息被持久化到本地磁盘，并且支持数据备份防止丢失；\n容错性：允许集群中的节点失败(若分区副本数量为 n,则允许 n-1 个节点失败)；\n高并发：单机可支持数千个客户端同时读写；\n\n下载地址\n下载完成之后，打开config文件夹，简单更改一下配置文件。\n\n找到zookeeper.properties进行修改\n#zookeeper运行时产生的文件存放路径，win可能需要注意\ndataDir=/tmp/zookeeper\n\n\n找到server.properties进行修改\n#kafka运行时日志文件存放路径\nlog.dirs=/tmp/kafka-logs\n#kafka组id\ngroup.id=test-consumer-group\n\n\n\n完成后，以正确的顺序启动所有服务：\n# Start the ZooKeeper service\n# Note: Soon, ZooKeeper will no longer be required by Apache Kafka.\n$ bin/zookeeper-server-start.sh config/zookeeper.properties\n\n打开另一个终端：\n# Start the Kafka broker service\n$ bin/kafka-server-start.sh config/server.properties\n\n成功启动所有服务后，您将运行并可以使用基本的 Kafka 环境。\nSpringBoot 中使用 Kafka1. 添加所需要的依赖&lt;dependency&gt;\n  &lt;groupId&gt;org.springframework.kafka&lt;/groupId&gt;\n  &lt;artifactId&gt;spring-kafka&lt;/artifactId&gt;\n&lt;/dependency&gt;\n\n2. Kafka 的部分配置###########【Kafka集群】###########\nspring.kafka.bootstrap-servers=112.126.74.249:9092,112.126.74.249:9093\n###########【初始化生产者配置】###########\n# 重试次数\nspring.kafka.producer.retries=0\n# 应答级别:多少个分区副本备份完成时向生产者发送ack确认(可选0、1、all/-1)\nspring.kafka.producer.acks=1\n# 批量大小\nspring.kafka.producer.batch-size=16384\n# 提交延时\nspring.kafka.producer.properties.linger.ms=0\n# 当生产端积累的消息达到batch-size或接收到消息linger.ms后,生产者就会将消息提交给kafka\n# linger.ms为0表示每接收到一条消息就提交给kafka,这时候batch-size其实就没用了\n# 生产端缓冲区大小\nspring.kafka.producer.buffer-memory = 33554432\n# Kafka提供的序列化和反序列化类\nspring.kafka.producer.key-serializer=org.apache.kafka.common.serialization.StringSerializer\nspring.kafka.producer.value-serializer=org.apache.kafka.common.serialization.StringSerializer\n# 自定义分区器\n# spring.kafka.producer.properties.partitioner.class=com.felix.kafka.producer.CustomizePartitioner\n# 事务初始化 设置为一个非空的字符串即可开启事务功能\nspring.kafka.producer.transaction-id-prefix=transaction\n###########【初始化消费者配置】###########\n# 默认的消费组ID\nspring.kafka.consumer.properties.group.id=defaultConsumerGroup\n# 是否自动提交offset\nspring.kafka.consumer.enable-auto-commit=true\n# 提交offset延时(接收到消息后多久提交offset)\nspring.kafka.consumer.auto.commit.interval.ms=1000\n# 当kafka中没有初始offset或offset超出范围时将自动重置offset\n# earliest:重置为分区中最小的offset;\n# latest:重置为分区中最新的offset(消费分区中新产生的数据);\n# none:只要有一个分区不存在已提交的offset,就抛出异常;\nspring.kafka.consumer.auto-offset-reset=latest\n# 消费会话超时时间(超过这个时间consumer没有发送心跳,就会触发rebalance操作)\nspring.kafka.consumer.properties.session.timeout.ms=120000\n# 消费请求超时时间\nspring.kafka.consumer.properties.request.timeout.ms=180000\n# Kafka提供的序列化和反序列化类\nspring.kafka.consumer.key-deserializer=org.apache.kafka.common.serialization.StringDeserializer\nspring.kafka.consumer.value-deserializer=org.apache.kafka.common.serialization.StringDeserializer\n# 消费端监听的topic不存在时，项目启动会报错(关掉)\nspring.kafka.listener.missing-topics-fatal=false\n# 设置批量消费\n# spring.kafka.listener.type=batch\n# 批量消费每次最多消费多少条消息\n# spring.kafka.consumer.max-poll-records=50\n\n#==================================================\n#一般来说 配置一下就行\nspring:\n  kafka:\n      bootstrap-servers: localhost:9092\n      consumer:\n        group-id: test-consumer-group\n        enable-auto-commit: true\n        auto-commit-interval: 3000\n\n3. 生产者//生产者\n@Component\npublic class EventProducet &#123;\n\n    @Autowired\n    private KafkaTemplate kafkaTemplate;//也可以通过&lt;T, T&gt;的方式来指定类型，默认都是String\n\n    //发送事件\n    public void fireEvent(Event event)&#123;\n        //将事件发布到指定主题          这里是封装了一个事件类，发布事件时将事件类转换成JSON\n        kafkaTemplate.send(&quot;topic1&quot;, JSONObject.toJSONString(event));\n    &#125;\n&#125;\n\n//生产者\n@Component\nclass KafkaProducer&#123;\n    @Autowired\n    private KafkaTemplate kafkaTemplate;\n\n    public void sendMessage(String topic,String content)&#123;\n        kafkaTemplate.send(topic,content);\n    &#125;\n&#125;\n\n4. 消费者@Component\npublic class KafkaConsumer &#123;\n    // 消费监听\n    @KafkaListener(topics = &#123;&quot;topic1&quot;&#125;)\n    public void onMessage1(ConsumerRecord&lt;?, ?&gt; record)&#123;\n        // 消费的哪个topic、partition的消息,打印出消息内容\n        System.out.println(&quot;============&quot;+record.topic()+&quot;-&gt;&quot;+record.partition()+&quot;-&gt;&quot;+record.value()+&quot;============&quot;);\n    &#125;\n&#125;\n\n上面的实例创建了一个生产者，发送消息到topic1，然后又一个消费者监听topic1，监听用 @KafkaListener注解，topic 表示要监听的 topic，支持同时监听多个，有逗号分隔\n创建一个测试类进行测试\n@SpringBootTest\npublic class KafkaTest &#123;\n    @Autowired\n    KafkaProducer kafkaProducer;\n    @Test\n    public void testKafka() throws InterruptedException &#123;\n         kafkaProducer.sendMessage(&quot;topic1&quot;, &quot;Hello&quot;);\n         kafkaProducer.sendMessage(&quot;topic1&quot;, &quot;World&quot;);\n         Thread.sleep(1000*10);\n    &#125;\n&#125;\n\n\n可以看到成功运行\n最简单的应用便到此结束\n生产者的更多使用方法1. 待回调的生产者Kafka 提供了一个回调方法 addCallback，我们可以在回调方法中监控信息是否发送成功或失败做补偿处理，有两种写法\n\n@Component\nclass KafkaProducer &#123;\n    @Autowired\n    private KafkaTemplate kafkaTemplate;\n\n    public void sendMessage(String topic, String content) &#123;\n        kafkaTemplate.send(topic, content).addCallback(new ListenableFutureCallback&lt;SendResult&lt;String, String&gt;&gt;() &#123;\n            @Override\n            public void onFailure(Throwable throwable) &#123;\n                System.out.println(&quot;发送消息失败：&quot; + throwable.getMessage());\n            &#125;\n\n            @Override\n            public void onSuccess(SendResult&lt;String, String&gt; result) &#123;\n                System.out.println(&quot;发送消息成功：&quot; + result.getRecordMetadata().topic() + &quot;-&quot;\n                        + result.getRecordMetadata().partition() + &quot;-&quot; + result.getRecordMetadata().offset() + &quot;-&quot; + result.getProducerRecord().value());\n            &#125;\n        &#125;);\n    &#125;\n&#125;\n\n@Component\nclass KafkaProducer &#123;\n    @Autowired\n    private KafkaTemplate kafkaTemplate;\n\n    public void sendMessage(String topic, String content) &#123;\n        ListenableFuture&lt;SendResult&lt;String,String&gt;&gt; future = kafkaTemplate.send(topic, content);\n        future.addCallback((result)-&gt; &#123;\n            // 消息发送到的topic\n            String tp = result.getRecordMetadata().topic();\n            // 消息发送到的分区\n            int partition = result.getRecordMetadata().partition();\n            // 消息在分区内的offset\n            long offset = result.getRecordMetadata().offset();\n            System.out.println(&quot;发送消息成功:&quot; + tp + &quot;-&quot; + partition + &quot;-&quot; + offset);\n        &#125;, (KafkaFailureCallback&lt;Integer, String&gt;) ex -&gt; &#123;\n            ProducerRecord&lt;Integer, String&gt; failed = ex.getFailedProducerRecord();\n        &#125;);\n    &#125;\n&#125;\n\n2. 自定义分区kafka 中每个 topic 划分了多个分区，那么生产者将消息发送到 topic 时，具体追加到那个分区呢？这就是所谓的分区策略，kafka 为我们提供了默认的分区策略，同时它也支持自定义分区策略，其路由机制为：\n\n 若发送消息时指定了分区（即自定义分区策略），则直接将消息 append 到指定分区。\n 若发送消息时未指定 partition，但指定了 key（kafka 允许为每条消息设置一个 key），则对 key 值进行 hash 计算，根据计算结构路由到指定分区，这种情况下可以保证同一个 key 的所有消息都进入相同的分区。\n\npartition 和 key 都未指定，则使用 kafka 默认的分区策略，轮询出一个 partition\n自定义一个分区策略，将消息发送到我们指定的 partition，首先建立一个分区器类实现 Partitioner 接口，重写方法，其中 partition 方法的返回值表示将消息发送到几号分区。\npublic class CustomizePartitioner implements Partitioner &#123;\n    @Override\n    public int partition(String s, Object o, byte[] bytes, Object o1, byte[] bytes1, Cluster cluster) &#123;\n        // 自定义分区规则(这里假设全部发到0号分区)\n        // ......\n        return 0;\n    &#125;\n\n    @Override\n    public void close() &#123;\n\n    &#125;\n\n    @Override\n    public void configure(Map&lt;String, ?&gt; map) &#123;\n\n    &#125;\n&#125;\n\n3. kafka 事务提交如果发送消息时需要创建事务，可以使用 kafkaTemplate 的 executeInTransaction 方法来声明事务。\n需要先进行配置 yml\nspring.kafka.producer.transaction-id-prefix=transaction\n\n@Component\nclass KafkaProducer &#123;\n    @Autowired\n    private KafkaTemplate kafkaTemplate;\n\n    public void sendMessage(String topic, String content) &#123;\n        kafkaTemplate.executeInTransaction(new KafkaOperations.OperationsCallback() &#123;\n            @Override\n            public Object doInOperations(KafkaOperations kafkaOperations) &#123;\n                kafkaOperations.send(topic, content);\n                throw new RuntimeException(&quot;fail&quot;);\n//                return true;\n            &#125;\n        &#125;);\n    &#125;\n&#125;\n\n消费者的更多使用方法1. 指定 topic、partition、offset 消费前面我们只监听了 topic1，监听的是所有在 topic1 上的消息，我们还可以指定 topic、partition、offset，在@KafkaListener注解上全部为我们提供了\n/**\n * @Title 指定topic、partition、offset消费\n * @Description 同时监听topic1和topic2，监听topic1的0号分区、topic2的 &quot;0号和1号&quot; 分区，指向1号分区的offset初始值为8\n **/\n@Component\nclass KafkaConsumer&#123;\n    @KafkaListener(id = &quot;consumer1&quot;,groupId = &quot;felix-group&quot;,topicPartitions = &#123;\n            @TopicPartition(topic = &quot;topic1&quot;,partitions = &#123;&quot;0&quot;&#125;),\n            @TopicPartition(topic = &quot;topic2&quot;,partitions = &quot;0&quot;,partitionOffsets = @PartitionOffset(partition = &quot;1&quot;,initialOffset = &quot;8&quot;))\n    &#125;)\n    public void handleMessage(ConsumerRecord record)&#123;\n        System.out.println(&quot;============&quot;+record.topic()+&quot;-&gt;&quot;+record.partition()+&quot;-&gt;&quot;+record.value()+&quot;============&quot;);\n    &#125;\n&#125;\n\n\nid：消费者 ID\ngroupid：消费组 ID\ntopics：监听的 topic，可以监听多个\ntopicPartitions：可以配置更加详细的监听信息，可以指定 topic、parition、offset 监听\n\n上面 handleMessage 监听的含义：监听 topic1 的 0 号分区，同时监听 topic2 的 0 号分区和 topic2 的 1 号分区里面 offset 从 8 开始的消息。\n注意：topics 和 topicPartitions 不能同时使用；\n2. 批量消费修改配置文件，开启批量消费\n# 设置批量消费\nspring.kafka.listener.type=batch\n# 批量消费每次最多消费多少条消息\nspring.kafka.consumer.max-poll-records=50\n\n接收消息时使用 List 来接收，监听代码如下\n@KafkaListener(topics = &quot;topic1&quot;)\n//也可以使用List&lt;ConsumerRecord&lt;?, ?&gt;&gt;\npublic void onMessage3(ConsumerRecords&lt;?, ?&gt; records) &#123;\n    System.out.println(&quot;&gt;&gt;&gt;批量消费一次，records.size()=&quot;+records.count());\n    for (ConsumerRecord&lt;?, ?&gt; record : records) &#123;\n        System.out.println(record.value());\n    &#125;\n&#125;\n\n3. 异常处理器通过异常处理，我们可以处理 consumer 在消费时发生的异常。\n创建一个 ConsumerAwareListenerErrorHandler 类型的异常处理方法，使用@Bean 注入，然后将这个异常处理的 BeanName 放到@KafkaListener 注解的 errorHandler 属性里面，当监听抛出异常的时候，则会自动调用异常处理器\n@Bean\npublic ConsumerAwareListenerErrorHandler consumerAwareErrorHandler() &#123;\n    return (message, exception, consumer) -&gt; &#123;\n        System.out.println(&quot;消费异常：&quot;+message.getPayload());\n        return null;\n    &#125;;\n&#125;\n\n@KafkaListener(topics = &#123;&quot;topic1&quot;&#125;,errorHandler = &quot;consumerAwareErrorHandler&quot;)\n\n4. 消息过滤器// 监听器工厂\n@Autowired\nprivate ConsumerFactory consumerFactory;\n\n// 配置一个消息过滤策略\n@Bean\npublic ConcurrentKafkaListenerContainerFactory myFilterContainerFactory() &#123;\n    ConcurrentKafkaListenerContainerFactory factory =\n        new ConcurrentKafkaListenerContainerFactory();\n    factory.setConsumerFactory(consumerFactory);\n    // 被过滤的消息将被丢弃\n    factory.setAckDiscarded(true);\n    // 消息过滤策略（将消息转换为int类型，判断是奇数还是偶数，把所有奇数过滤，监听器只接收偶数）\n    factory.setRecordFilterStrategy(consumerRecord -&gt; &#123;\n        if (Integer.parseInt(consumerRecord.value().toString()) % 2 == 0) &#123;\n            return false;\n        &#125;\n        //返回true消息则被过滤\n        return true;\n    &#125;);\n    return factory;\n&#125;\n\n@KafkaListener(topics = &quot;topic1&quot;,containerFactory = &quot;myFilterContainerFactory&quot;)\n\n上面实现了一个”过滤奇数、接收偶数”的过滤策略，我们向 topic1 发送 0-99 总共 100 条消息，看一下监听器的消费情况，可以看到监听器只消费了偶数\n5. 消息转发在实际开发中，我们可能有这样的需求，应用 A 从 TopicA 获取到消息，经过处理后转发到 TopicB，再由应用 B 监听处理消息，即一个应用处理完成后将该消息转发至其他应用，完成消息的转发。\n在 SpringBoot 集成 Kafka 实现消息的转发也很简单，只需要通过一个@SendTo 注解，被注解方法的 return 值即转发的消息内容，如下：\n@Component\nclass KafkaConsumer &#123;\n    @KafkaListener(topics = &quot;topic1&quot;)\n    @SendTo(&quot;topic2&quot;)//使用前需要配置KafkaTemplate,有点麻烦,实在需要的话照着官方文档复制粘贴就好了\n    public String handleMessage(ConsumerRecord&lt;?, ?&gt; record) &#123;\n//        System.out.println(record.value()+&quot;-&gt;topic1&quot;);\n        return record.value()+&quot;-forward message&quot;;\n    &#125;\n\n    @KafkaListener(topics = &quot;topic2&quot;)\n    public void handleMessage2(ConsumerRecord&lt;?, ?&gt; record) &#123;\n        System.out.println(record.value()+&quot;-&gt;topic2&quot;);\n    &#125;\n&#125;\n\n6. 定时启动、停止监听器默认情况下，当消费者项目启动的时候，监听器就开始工作，监听消费发送到指定 topic 的消息，那如果我们不想让监听器立即工作，想让它在我们指定的时间点开始工作，或者在我们指定的时间点停止工作，该怎么处理呢——使用 KafkaListenerEndpointRegistry，下面我们就来实现：\n\n 禁止监听器自启动；\n\n 创建两个定时任务，一个用来在指定时间点启动定时器，另一个在指定时间点停止定时器；\n\n\n新建一个定时任务类，用注解@EnableScheduling 声明，KafkaListenerEndpointRegistry 在 SpringIO 中已经被注册为 Bean，直接注入，设置禁止 KafkaListener 自启动，\n@EnableScheduling\n@Component\npublic class CronTimer &#123;\n\n    /**\n     * @KafkaListener注解所标注的方法并不会在IOC容器中被注册为Bean，\n     * 而是会被注册在KafkaListenerEndpointRegistry中，\n     * 而KafkaListenerEndpointRegistry在SpringIOC中已经被注册为Bean\n     **/\n    @Autowired\n    private KafkaListenerEndpointRegistry registry;\n\n    @Autowired\n    private ConsumerFactory consumerFactory;\n\n    // 监听器容器工厂(设置禁止KafkaListener自启动)\n    @Bean\n    public ConcurrentKafkaListenerContainerFactory delayContainerFactory() &#123;\n        ConcurrentKafkaListenerContainerFactory container = new ConcurrentKafkaListenerContainerFactory();\n        container.setConsumerFactory(consumerFactory);\n        //禁止KafkaListener自启动\n        container.setAutoStartup(false);\n        return container;\n    &#125;\n\n    // 监听器\n    @KafkaListener(id=&quot;timingConsumer&quot;,topics = &quot;topic1&quot;,containerFactory = &quot;delayContainerFactory&quot;)\n    public void onMessage1(ConsumerRecord&lt;?, ?&gt; record)&#123;\n        System.out.println(&quot;消费成功：&quot;+record.topic()+&quot;-&quot;+record.partition()+&quot;-&quot;+record.value());\n    &#125;\n\n    // 定时启动监听器\n    @Scheduled(cron = &quot;0 42 11 * * ? &quot;)\n    public void startListener() &#123;\n        System.out.println(&quot;启动监听器...&quot;);\n        // &quot;timingConsumer&quot;是@KafkaListener注解后面设置的监听器ID,标识这个监听器\n        if (!registry.getListenerContainer(&quot;timingConsumer&quot;).isRunning()) &#123;\n            registry.getListenerContainer(&quot;timingConsumer&quot;).start();\n        &#125;\n        //registry.getListenerContainer(&quot;timingConsumer&quot;).resume();\n    &#125;\n\n    // 定时停止监听器\n    @Scheduled(cron = &quot;0 45 11 * * ? &quot;)\n    public void shutDownListener() &#123;\n        System.out.println(&quot;关闭监听器...&quot;);\n        registry.getListenerContainer(&quot;timingConsumer&quot;).pause();\n    &#125;\n&#125;\n\n参考文章：\nKafka：http://kafka.apache.org/\nKafka 原理架构：点击链接\n文章：https://blog.csdn.net/yuanlong122716/article/details/105160545/\nSpringBootKafka：https://docs.spring.io/spring-kafka/docs/current/reference/html/#preface\n","categories":["SpringBoot"],"tags":["Spring","SpringBoot","Kafka"]},{"title":"SpringBoot Quartz","url":"/2021/04/27/SpringBoot-Quartz/","content":"什么是QuartzQuartz是OpenSymphony开源组织在Job scheduling领域又一个开源项目，完全由Java开发，可以用来执行定时任务，类似于java.util.Timer。但是相较于Timer， Quartz增加了很多功能：\n\n持久性作业 - 就是保持调度定时的状态;\n作业管理 - 对调度作业进行有效的管理;\n\n在实际项目开发中，随着业务的增大，需要操作Job的也就越多，肯定不能是人工操作，我们需要应该自动调度的任务框架去解决，功能的具体实现如下：\n\n首先我们需要定义实现一个定时功能的接口，我们可以称之为Task或者Job（Quartz中称之为Job），如定时发送邮件Job，优惠卷到期通知Job，实现如下：\n\n有了Job之后，我们需要一个能触发Job并执行的触发器（Trigger），Trigger最基本的功能是指定Job的执行时间，执行间隔，运行次数等。\n\n有了Job和Trigger后，需要一个Schedule，来指定Trigger去执行指定的Job。\n\n\n上面三个部分就是Quartz的基本组成部分：\n\n调度器：Scheduler\n任务：JobDetail\n触发器：Trigger，包括SimpleTrigger和CronTrigger\n\nQuartz在SpringBoot的应用\n使用Maven添加依赖\n&lt;!-- SpringBoot 整合 Quartz 定时任务 --&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n    &lt;artifactId&gt;spring-boot-starter-quartz&lt;/artifactId&gt;\n    &lt;version&gt;2.3.5.RELEASE&lt;/version&gt;\n&lt;/dependency&gt;\n\n\n配置yml\nspring:\n  quartz:\n    scheduler-name: communityScheduler//scheduler名称\n    job-store-type: jdbc//持久化方法\n\n\n实现Job接口，实现定时任务逻辑\npublic class AlphaJob implements Job &#123;\n    //实现Job接口\n    @Override\n    public void execute(JobExecutionContext jobExecutionContext) throws JobExecutionException &#123;\n        System.out.println(Thread.currentThread().getName()+&quot;: execute a quartz job.&quot;);\n    &#125;\n&#125;\n\n\n配值定时任务，创建一个Config类，设置\n//配置-》数据库-》调用\n//Quartz 定时任务配置类\n@Configuration\npublic class QuartzConfig &#123;\n    //FactoryBean可简化Bean的实例化过程：\n    //1.通过FactoryBean封装Bean的实例化过程\n    //2.将FactoryBean封装到Spring容器中\n    //3.将FactoryBean注入给其他的Bean\n    //4.该Bean得到的是FactoryBean所管理的对象实例\n\n    // 配置JobDetail\n    @Bean\n    public JobDetailFactoryBean alphaJobDetail()&#123;\n        JobDetailFactoryBean factoryBean = new JobDetailFactoryBean();\n        factoryBean.setJobClass(AlphaJob.class);\n        factoryBean.setName(&quot;alphaJob&quot;);//设置名称\n        factoryBean.setGroup(&quot;alphaJobGroup&quot;);//设置分组\n        factoryBean.setDurability(true);//是否持久(数据库中是否删除)\n        factoryBean.setRequestsRecovery(true);//是否可恢复\n        return factoryBean;\n    &#125;\n\n    // 配置Trigger(SimpleTriggerFactoryBean(简单任务用，按指定的时间间隔执行多少次任务的情况),CronTriggerFactoryBean(复杂任务用，通过Cron表达式来控制任务的执行时间))\n    @Bean\n    public SimpleTriggerFactoryBean alphaTrigger(JobDetail alphaJobDetail)&#123;\n        SimpleTriggerFactoryBean factoryBean = new SimpleTriggerFactoryBean();\n        factoryBean.setJobDetail(alphaJobDetail);//关联上述JobDetail\n        factoryBean.setName(&quot;alphaTrigger&quot;);//设置名称\n        factoryBean.setGroup(&quot;alphaTriggerGroup&quot;);//设置分组\n        factoryBean.setRepeatInterval(3000);//设置执行的时间间隔\n        factoryBean.setJobDataMap(new JobDataMap());\n        return factoryBean;\n    &#125;\n&#125;\n\nJobDetail绑定指定的Job，每次调用时，首先会拿到对应的JobDetail，然后创建Job实例，在去执行Job中execute()中的内容，任务结束后，关联的Job对象实例会被释放，且会被JVM GC清除。\n为什么设计成JobDetail+Job，不直接使用Job\n\nJobDetail定义的是任务数据，而真正执行逻辑在Job中\n如果直接使用Job，就会存在对同一个Job实例并发访问的问题，而JobDetail + Job方式，每次执行时，都会根据JobDetail创建一个新Job实例，这样可以避免并发问题\n\n\n\n到此为止，Scheduler会在底层自动调用我们上面定义的定时任务。\n参考：\n官网：http://www.quartz-scheduler.org/\nCron表达式：https://cron.qqe2.com/\n文章：https://blog.csdn.net/noaman_wgs/article/details/80984873\n文章：https://www.jianshu.com/p/06c4307214b7\n","categories":["SpringBoot"],"tags":["Spring","SpringBoot","Quartz"]},{"title":"OData在DotNetCore中的应用","url":"/2021/04/08/OData%E5%9C%A8DotNetCore%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8/","content":"什么是OData开放数据协议（Open Data Protocol，简称OData）是一种描述如何创建和访问Restful服务的OASIS标准。该标准由微软发起 [1] ，前三个版本1.0、2.0、3.0都是微软开放标准，遵循微软开放规范承诺书（Microsoft Open Specification Promise）。第四个版本4.0于2014年3月17日在OASIS投票通过成为开放工业标准\n上面是百度的答案，我们可以很清楚的知道这是一个协议\n使用OData开发以.NetCoreAPI为例，创建一个API项目\n添加ASP.NET Core OData和Microsoft.EntityFrameworkCore.InMemoryNuget程序包\n&lt;Project Sdk=&quot;Microsoft.NET.Sdk.Web&quot;&gt;\n\n  &lt;PropertyGroup&gt;\n    &lt;TargetFramework&gt;net5.0&lt;/TargetFramework&gt;\n    &lt;UserSecretsId&gt;0d1b65c3-336b-4511-be78-68c012362630&lt;/UserSecretsId&gt;\n    &lt;DockerDefaultTargetOS&gt;Linux&lt;/DockerDefaultTargetOS&gt;\n  &lt;/PropertyGroup&gt;\n\n  &lt;ItemGroup&gt;\n    &lt;PackageReference Include=&quot;Microsoft.AspNetCore.OData&quot; Version=&quot;7.4.1&quot; /&gt;\n    &lt;PackageReference Include=&quot;Microsoft.EntityFrameworkCore.InMemory&quot; Version=&quot;5.0.5&quot; /&gt;\n    &lt;PackageReference Include=&quot;Microsoft.VisualStudio.Azure.Containers.Tools.Targets&quot; Version=&quot;1.10.9&quot; /&gt;\n    &lt;PackageReference Include=&quot;Swashbuckle.AspNetCore&quot; Version=&quot;5.6.3&quot; /&gt;\n  &lt;/ItemGroup&gt;\n\n&lt;/Project&gt;\n\nASP.NET Core OData程序包是为了更方便的去开发而引入的\nMicrosoft.EntityFrameworkCore.InMemory则方便数据引入\n添加Model类// Book\npublic class Book\n&#123;\n  public int Id &#123; get; set; &#125;\n  public string ISBN &#123; get; set; &#125;\n  public string Title &#123; get; set; &#125;\n  public string Author &#123; get; set; &#125;\n  public decimal Price &#123; get; set; &#125;\n  public Address Location &#123; get; set; &#125;\n  public Press Press &#123; get; set; &#125;\n&#125;\n\n// Press\npublic class Press\n&#123;\n  public int Id &#123; get; set; &#125;\n  public string Name &#123; get; set; &#125;\n  public string Email &#123; get; set; &#125;\n  public Category Category &#123; get; set; &#125;\n&#125;\n\n// Category\npublic enum Category\n&#123;\n  Book,\n  Magazine,\n  EBook\n&#125;\n\n// Address\npublic class Address\n&#123;\n  public string City &#123; get; set; &#125;\n  public string Street &#123; get; set; &#125;\n&#125;\n\n在这里:\n\nBook，Press将作为实体类型\nAddress将用作“复杂”类型。\nCategory将用作枚举类型。\n\n建立EDM(Entity Data Model)模型OData基于实体数据模型(EDM)来描述数据结构，在ASP.Net Core OData中，可以轻松的基于上述模型建立，在Startup类末尾加一个私有方法\n        private static IEdmModel GetEdmModel()\n        &#123;\n            ODataConventionModelBuilder builder = new ODataConventionModelBuilder();\n            builder.EntitySet&lt;Book&gt;(&quot;Books&quot;);\n            builder.EntitySet&lt;Press&gt;(&quot;Presses&quot;);\n            return builder.GetEdmModel();\n        &#125;\n\n在这里我们定义了两个名为Books和Presses 的实体集\n通过依赖注入注册服务ASP.NET Core OData需要预先注册一些服务才能提供其功能，该库提供了一个名为AddOData()的扩展方法，以通过内置的依赖项注入来注册所需要的OData服务，因此，修改如下代码到ConfigureServices中\n    public class Startup\n    &#123;\n          // ...\n\n          public void ConfigureServices(IServiceCollection services)\n          &#123;\n                services.AddOData();\n                services.AddControllers();\n                services.AddSwaggerGen(c =&gt;\n                &#123;\n                    c.SwaggerDoc(&quot;v1&quot;, new OpenApiInfo &#123; Title = &quot;WebApplication1&quot;, Version = &quot;v1&quot; &#125;);\n                &#125;);\n          &#125;\n    &#125;\n\n注册OData端点我们需要添加OData路由来注册OData端点，并调用GetEdmModel()绑定EDM模型到端点\n    public class Startup\n    &#123;\n          // ...\n\n        public void Configure(IApplicationBuilder app, IWebHostEnvironment env)\n        &#123;\n            if (env.IsDevelopment())\n            &#123;\n                app.UseDeveloperExceptionPage();\n                app.UseSwagger();\n                app.UseSwaggerUI(c =&gt; c.SwaggerEndpoint(&quot;/swagger/v1/swagger.json&quot;, &quot;WebApplication1 v1&quot;));\n            &#125;\n\n            app.UseEndpoints(endpoints =&gt;\n            &#123;\n                endpoints.MapODataRoute(&quot;odata&quot;, &quot;odata&quot;, GetEdmModel());\n            &#125;);\n        &#125;\n    &#125;\n\n8.0版本无需在Configure中注册:\npublic class Startup\n&#123;\n    public void ConfigureServices(IServiceCollection services)\n    &#123;\n        services.AddDbContext&lt;BookStoreContext&gt;(opt =&gt; opt.UseInMemoryDatabase(&quot;BookLists&quot;));\n        services.AddControllers();\n        services.AddOData(opt =&gt; opt.AddModel(&quot;odata&quot;, GetEdmModel()));\n    &#125;\n\n    public void Configure(IApplicationBuilder app, IWebHostEnvironment env)\n    &#123;\n        app.UseRouting();\n        app.UseEndpoints(endpoints =&gt;\n        &#123;\n            endpoints.MapControllers();\n        &#125;);\n    &#125;\n\n    private static IEdmModel GetEdmModel()\n    &#123;\n        // …\n    &#125;\n&#125;\n\n查询元数据OData服务已经准备就绪，可以运行，并且提供基本的功能，例如查询元数据(EDM的XML表示)，构建并允许项目，我们任何客户端工具发出请求：\nGET http://localhost:5000/odata/$metadata\n然后，可以获取如下xml所示的元数据\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;\n&lt;edmx:Edmx Version=&quot;4.0&quot; xmlns:edmx=&quot;http://docs.oasis-open.org/odata/ns/edmx&quot;&gt;\n    &lt;edmx:DataServices&gt;\n        &lt;Schema Namespace=&quot;BookStore.Models&quot; xmlns=&quot;http://docs.oasis-open.org/odata/ns/edm&quot;&gt;\n            &lt;EntityType Name=&quot;Book&quot;&gt;\n                &lt;Key&gt;\n                    &lt;PropertyRef Name=&quot;Id&quot; /&gt;\n                &lt;/Key&gt;\n                &lt;Property Name=&quot;Id&quot; Type=&quot;Edm.Int32&quot; Nullable=&quot;false&quot; /&gt;\n                &lt;Property Name=&quot;ISBN&quot; Type=&quot;Edm.String&quot; /&gt;\n                &lt;Property Name=&quot;Title&quot; Type=&quot;Edm.String&quot; /&gt;\n                &lt;Property Name=&quot;Author&quot; Type=&quot;Edm.String&quot; /&gt;\n                &lt;Property Name=&quot;Price&quot; Type=&quot;Edm.Decimal&quot; Nullable=&quot;false&quot; /&gt;\n                &lt;Property Name=&quot;Location&quot; Type=&quot;BookStore.Models.Address&quot; /&gt;\n                &lt;NavigationProperty Name=&quot;Press&quot; Type=&quot;BookStore.Models.Press&quot; /&gt;\n            &lt;/EntityType&gt;\n            &lt;EntityType Name=&quot;Press&quot;&gt;\n                &lt;Key&gt;\n                    &lt;PropertyRef Name=&quot;Id&quot; /&gt;\n                &lt;/Key&gt;\n                &lt;Property Name=&quot;Id&quot; Type=&quot;Edm.Int32&quot; Nullable=&quot;false&quot; /&gt;\n                &lt;Property Name=&quot;Name&quot; Type=&quot;Edm.String&quot; /&gt;\n                &lt;Property Name=&quot;Email&quot; Type=&quot;Edm.String&quot; /&gt;\n                &lt;Property Name=&quot;Category&quot; Type=&quot;BookStore.Models.Category&quot; Nullable=&quot;false&quot; /&gt;\n            &lt;/EntityType&gt;\n            &lt;ComplexType Name=&quot;Address&quot;&gt;\n                &lt;Property Name=&quot;City&quot; Type=&quot;Edm.String&quot; /&gt;\n                &lt;Property Name=&quot;Street&quot; Type=&quot;Edm.String&quot; /&gt;\n            &lt;/ComplexType&gt;\n            &lt;EnumType Name=&quot;Category&quot;&gt;\n                &lt;Member Name=&quot;Book&quot; Value=&quot;0&quot; /&gt;\n                &lt;Member Name=&quot;Magazine&quot; Value=&quot;1&quot; /&gt;\n                &lt;Member Name=&quot;EBook&quot; Value=&quot;2&quot; /&gt;\n            &lt;/EnumType&gt;\n        &lt;/Schema&gt;\n        &lt;Schema Namespace=&quot;Default&quot; xmlns=&quot;http://docs.oasis-open.org/odata/ns/edm&quot;&gt;\n            &lt;EntityContainer Name=&quot;Container&quot;&gt;\n                &lt;EntitySet Name=&quot;Books&quot; EntityType=&quot;BookStore.Models.Book&quot;&gt;\n                    &lt;NavigationPropertyBinding Path=&quot;Press&quot; Target=&quot;Presses&quot; /&gt;\n                &lt;/EntitySet&gt;\n                &lt;EntitySet Name=&quot;Presses&quot; EntityType=&quot;BookStore.Models.Press&quot; /&gt;\n            &lt;/EntityContainer&gt;\n        &lt;/Schema&gt;\n    &lt;/edmx:DataServices&gt;\n&lt;/edmx:Edmx&gt;\n\n创建数据库上下文现在，可以添加更多实际的功能，首先将数据库上下文引入Web程序，在Models文件夹中创建BookStoreContext类\n    public class BookStoreContext : DbContext\n    &#123;\n        public BookStoreContext(DbContextOptions&lt;BookStoreContext&gt; options)\n          : base(options)\n        &#123;\n        &#125;\n\n        public DbSet&lt;Book&gt; Books &#123; get; set; &#125;\n        public DbSet&lt;Press&gt; Presses &#123; get; set; &#125;\n\n        protected override void OnModelCreating(ModelBuilder modelBuilder)\n        &#123;\n            modelBuilder.Entity&lt;Book&gt;().OwnsOne(c =&gt; c.Location);\n        &#125;\n    &#125;\n\nOnModelCreating中的代码将Address映射为复杂类型\n注册数据库上下文通过依赖注入在服务中注册数据库上下文，求改Startup类中的ConfigureServices方法\n    public class Startup\n    &#123;\n          // ...\n\n          public void ConfigureServices(IServiceCollection services)\n          &#123;\n                services.AddDbContext&lt;BookStoreContext&gt;(opt =&gt; opt.UseInMemoryDatabase(&quot;BookLists&quot;));\n                services.AddOData();\n                services.AddControllers();\n                services.AddSwaggerGen(c =&gt;\n                &#123;\n                    c.SwaggerDoc(&quot;v1&quot;, new OpenApiInfo &#123; Title = &quot;WebApplication1&quot;, Version = &quot;v1&quot; &#125;);\n                &#125;);\n          &#125;\n    &#125;\n\n模型数据为了简单起见，我们简单生成一些内容\n    public static class DataSource\n    &#123;\n        private static IList&lt;Book&gt; _books &#123; get; set; &#125;\n\n        public static IList&lt;Book&gt; GetBooks()\n        &#123;\n            if (_books != null)\n            &#123;\n                return _books;\n            &#125;\n\n            _books = new List&lt;Book&gt;();\n\n            // book #1\n            Book book = new Book\n            &#123;\n                Id = 1,\n                ISBN = &quot;978-0-321-87758-1&quot;,\n                Title = &quot;Essential C#5.0&quot;,\n                Author = &quot;Mark Michaelis&quot;,\n                Price = 59.99m,\n                Location = new Address &#123; City = &quot;Redmond&quot;, Street = &quot;156TH AVE NE&quot; &#125;,\n                Press = new Press\n                &#123;\n                    Id = 1,\n                    Name = &quot;Addison-Wesley&quot;,\n                    Category = Category.Book\n                &#125;\n            &#125;;\n            _books.Add(book);\n\n            // book #2\n            book = new Book\n            &#123;\n                Id = 2,\n                ISBN = &quot;063-6-920-02371-5&quot;,\n                Title = &quot;Enterprise Games&quot;,\n                Author = &quot;Michael Hugos&quot;,\n                Price = 49.99m,\n                Location = new Address &#123; City = &quot;Bellevue&quot;, Street = &quot;Main ST&quot; &#125;,\n                Press = new Press\n                &#123;\n                    Id = 2,\n                    Name = &quot;O&#39;Reilly&quot;,\n                    Category = Category.EBook,\n                &#125;\n            &#125;;\n            _books.Add(book);\n\n            return _books;\n        &#125;\n    &#125;\n\n操作资源构建Controller创建一个Controller命名为BooksController\n    [ApiController]\n    [Route(&quot;[controller]&quot;)]\n    public class BooksController : ODataController\n    &#123;\n        private BookStoreContext _db;\n\n        public BooksController(BookStoreContext context)\n        &#123;\n            _db = context;\n            if (context.Books.Count() == 0)\n            &#123;\n                foreach (var b in DataSource.GetBooks())\n                &#123;\n                    context.Books.Add(b);\n                    context.Presses.Add(b.Press);\n                &#125;\n                context.SaveChanges();\n            &#125;\n        &#125;\n\n        [EnableQuery]\n        public IActionResult Get()\n        &#123;\n            return Ok(_db.Books);\n        &#125;\n\n        [EnableQuery]\n        public IActionResult Get([FromODataUri] int key)\n        &#123;\n            return Ok(_db.Books.FirstOrDefault(c =&gt; c.Id == key));\n        &#125;\n    &#125;\n\n在上面定义的两个Action中：\n\nGet()返回所有内容\nGet(int Key)返回指定ID内容\n\n检索资源我们访问：GET http://localhost:5000/odata/Books 响应结果为：\n&#123;\n    &quot;@odata.context&quot;: &quot;http://localhost:5000/odata/$metadata#Books&quot;,\n    &quot;value&quot;: [\n        &#123;\n            &quot;Id&quot;: 1,\n            &quot;ISBN&quot;: &quot;978-0-321-87758-1&quot;,\n            &quot;Title&quot;: &quot;Essential C#5.0&quot;,\n            &quot;Author&quot;: &quot;Mark Michaelis&quot;,\n            &quot;Price&quot;: 59.99,\n            &quot;Location&quot;: &#123;\n                &quot;City&quot;: &quot;Redmond&quot;,\n                &quot;Street&quot;: &quot;156TH AVE NE&quot;\n            &#125;\n        &#125;,\n        &#123;\n            &quot;Id&quot;: 2,\n            &quot;ISBN&quot;: &quot;063-6-920-02371-5&quot;,\n            &quot;Title&quot;: &quot;Enterprise Games&quot;,\n            &quot;Author&quot;: &quot;Michael Hugos&quot;,\n            &quot;Price&quot;: 49.99,\n            &quot;Location&quot;: &#123;\n                &quot;City&quot;: &quot;Bellevue&quot;,\n                &quot;Street&quot;: &quot;Main ST&quot;\n            &#125;\n        &#125;\n    ]\n&#125;\n\n尝试发出：GET http://localhost:5000/odata/Books(2) 获取ID为2的书籍\n创建资源添加下列代码到Controller中\n[EnableQuery]\npublic IActionResult Post([FromBody] Book book)\n&#123;\n    _db.Books.Add(book);\n    _db.SaveChanges();\n    return Created(book);\n&#125;\n\n发出如下请求创建Book数据\n*POST* http://localhost:5000/odata/Books\nContent-Type: application/json\nContent:\n&#123;\n  &quot;Id&quot;:3,&quot;ISBN&quot;:&quot;82-917-7192-5&quot;,&quot;Title&quot;:&quot;Hary Potter&quot;,&quot;Author&quot;:&quot;J. K. Rowling&quot;,\n  &quot;Price&quot;:199.99,\n  &quot;Location&quot;:&#123;\n     &quot;City&quot;:&quot;Shanghai&quot;,\n     &quot;Street&quot;:&quot;Zhongshan RD&quot;\n   &#125;\n&#125;\n\n查询资源需要在Startup.cs中添加如下代码启用所有OData查询选项，例如$filter，$orderby，$expand等。\n    public class Startup\n    &#123;\n      // ...\n  \n        public void Configure(IApplicationBuilder app, IWebHostEnvironment env)\n        &#123;\n            if (env.IsDevelopment())\n            &#123;\n                app.UseDeveloperExceptionPage();\n                app.UseSwagger();\n                app.UseSwaggerUI(c =&gt; c.SwaggerEndpoint(&quot;/swagger/v1/swagger.json&quot;, &quot;WebApplication1 v1&quot;));\n            &#125;\n            \n            //...\n\n            app.UseEndpoints(endpoints =&gt;\n            &#123;\n                endpoints.Select().Expand().Filter().OrderBy().MaxTop(100).Count();\n                endpoints.MapODataRoute(&quot;odata&quot;, &quot;odata&quot;, GetEdmModel());\n            &#125;);\n        &#125;\n    &#125;\n\n基于$filter的示例:\nGET http://localhost:5000/odata/Books?$filter=Price le 50\n响应内容为:\n&#123;\n    &quot;@odata.context&quot;: &quot;https://localhost:5001/odata/$metadata#Books&quot;,\n    &quot;value&quot;: [\n        &#123;\n            &quot;Id&quot;: 2,\n            &quot;ISBN&quot;: &quot;063-6-920-02371-5&quot;,\n            &quot;Title&quot;: &quot;Enterprise Games&quot;,\n            &quot;Author&quot;: &quot;Michael Hugos&quot;,\n            &quot;Price&quot;: 49.99,\n            &quot;Location&quot;: &#123;\n                &quot;City&quot;: &quot;Bellevue&quot;,\n                &quot;Street&quot;: &quot;Main ST&quot;\n            &#125;\n        &#125;\n    ]\n&#125;\n\n它还支持更为复杂的查询选项，例如：\nGET http://localhost:5000/odata/Books?$filter=Price le 50&amp;$expand=Press($select=Name)&amp;$select=ISBN\n响应结果为:\n&#123;\n    &quot;@odata.context&quot;: &quot;http://localhost:5000/odata/$metadata#Books(ISBN,Press(Name))&quot;,\n    &quot;value&quot;: [\n        &#123;\n            &quot;ISBN&quot;: &quot;063-6-920-02371-5&quot;,\n            &quot;Press&quot;: &#123;\n                &quot;Name&quot;: &quot;O&#39;Reilly&quot;\n            &#125;\n        &#125;\n    ]\n&#125;\n\n更多的查询方式可以在官方网站查看，这些都是基于OData协议进行的\n如果在Swagger中显示OData路由使用NuGet安装OData.Swagger程序包\n打开Startup.cs文件，在ConfigureService方法中添加如下服务\nservices.AddOdataSwaggerSupport();\n\n重新启动程序即可\n如果你的控制器是继承自ODataController，则需要添加[ApiExplorerSettings(IgnoreApi = false)]\n    [ApiController]\n    [ApiExplorerSettings(IgnoreApi = false)]\n    [Route(&quot;[controller]&quot;)]\n    public class BooksController : ODataController\n    &#123;\n        //...\n    &#125;\n\n本文参考：\nOData参考：https://devblogs.microsoft.com/odata/asp-net-core-odata-now-available/\nOData参考：https://devblogs.microsoft.com/odata/asp-net-odata-8-0-preview-for-net-5/\n在Swagger中显示OData参考：https://github.com/KishorNaik/Sol_OData_Swagger_Support\nOData官网：https://www.odata.org/\n","categories":["DotNetCore"],"tags":["OData"]},{"title":"IDEA用Maven创建SpringMVC项目","url":"/2021/04/01/IDEA%E7%94%A8Maven%E5%88%9B%E5%BB%BASpringMVC%E9%A1%B9%E7%9B%AE/","content":"什么是SpringMVC什么是MVC\nMVC是模型，视图，控制器的简写，是一种软件设计规范\n将业务逻辑，数据，显示 分离的方法来组织代码\nMVC主要作用是降低了视图与业务逻辑间的双向耦合\nMVC不是一种设计模式，是一种架构模式，当然不同的MVC存在差异\n\nModel数据模型，提供要显示的数据，因此包含数据和行为，可以认为是领域模型或JavaBean组件（包含数据和行为），不过现在一般都分离开来：Value Object（数据Dao） 和 服务层（行为Service）。也就是模型提供了模型数据查询和模型数据的状态更新等功能，包括数据和业务。\nView负责进行模型的展示，一般就是我们见到的用户界面，客户想看到的东西。\nController接收用户请求，委托给模型进行处理，处理完后返回的模型数据返回给视图，由视图进行展示，也就是说控制器做了调度员的工作。\n最典型的MVC就是JSP + servlet + javabean的模式。\n\nModel-1时代\n在web开发早期，通常采用Model-1\nModel-1中，主要分为两层，视图层和模型层\n\n\nModel-1优点：架构简单，比较适合小型项目开发\nModel-1缺点：JSP职责不单一，职责过重，不便维护\nModel-2时代Model-2把一个项目分成三部分，视图，控制，模型\n\n\n用户发请求\nServlet接收请求数据，并调用对应的业务逻辑方法\n业务处理完毕，返回更新后的数据给servlet\nservlet转向到JSP，由JSP来渲染页面\n响应给前端更新后的页面\n\n职责分析：\nController：控制器\n\n取得表单数据\n调用业务逻辑\n转向指定的页面\n\nModel：模型\n\n业务逻辑\n保存数据的状态\n\nView：视图\n\n显示页面\n\n\nModel2这样不仅提高的代码的复用率与项目的扩展性，且大大降低了项目的维护成本。Model 1模式的实现比较简单，适用于快速开发小规模项目，Model1中JSP页面身兼View和Controller两种角色，将控制逻辑和表现逻辑混杂在一起，从而导致代码的重用性非常低，增加了应用的扩展性和维护的难度。Model2消除了Model1的缺点。\n说完这些，回到正题，SpringMVC是Spring Framework的一部分，是基于Java实现MVC的轻量级Web框架。\n查看官方文档：https://docs.spring.io/spring/docs/5.2.0.RELEASE/spring-framework-reference/web.html#spring-web\nSpring的web框架围绕DispatcherServlet [ 调度Servlet ] 设计。\nDispatcherServlet的作用是将请求分发到不同的处理器。从Spring 2.5开始，使用Java 5或者以上版本的用户可以采用基于注解形式进行开发，十分简洁；\n正因为SpringMVC好 , 简单 , 便捷 , 易学 , 天生和Spring无缝集成(使用SpringIoC和Aop) , 使用约定优于配置 . 能够进行简单的junit测试 . 支持Restful风格 .异常处理 , 本地化 , 国际化 , 数据验证 , 类型转换 , 拦截器 等等……所以我们要学习 .\nSpringMVC执行原理\n简要分析执行流程\n\nDispatcherServlet表示前置控制器，是整个SpringMVC的控制中心。用户发出请求，DispatcherServlet接收请求并拦截请求。\n我们假设请求的url为 : http://localhost:8080/SpringMVC/hello\n如上url拆分成三部分：\nhttp://localhost:8080服务器域名\nSpringMVC部署在服务器上的web站点\nhello表示控制器\n通过分析，如上url表示为：请求位于服务器localhost:8080上的SpringMVC站点的hello控制器。\n\nHandlerMapping为处理器映射。DispatcherServlet调用HandlerMapping,HandlerMapping根据请求url查找Handler。\n\nHandlerExecution表示具体的Handler,其主要作用是根据url查找控制器，如上url被查找控制器为：hello。\n\nHandlerExecution将解析后的信息传递给DispatcherServlet,如解析控制器映射等。\n\nHandlerAdapter表示处理器适配器，其按照特定的规则去执行Handler。\n\nHandler让具体的Controller执行。\n\nController将具体的执行信息返回给HandlerAdapter,如ModelAndView。\n\nHandlerAdapter将视图逻辑名或模型传递给DispatcherServlet。\n\nDispatcherServlet调用视图解析器(ViewResolver)来解析HandlerAdapter传递的逻辑视图名。\n\n视图解析器将解析的逻辑视图名传给DispatcherServlet。\n\nDispatcherServlet根据视图解析器解析的视图结果，调用具体的视图。\n\n最终视图呈现给用户。\n\n\n创建一个非注解SpringMVC项目\n\n创建完毕后，右键项目-》Add Framework Suppot勾选WebWebApplication\n\n项目创建完毕，下面配置一些依赖：\nweb.xml配置：\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;\n&lt;web-app xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot;\n         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;\n         xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot;\n         version=&quot;4.0&quot;&gt;\n    &lt;!--配置DispatcherServlet：这是SpringMVC的核心：请求分发器，前端控制器--&gt;\n    &lt;servlet&gt;\n        &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt;\n        &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;\n        &lt;!--        配置DispatcherServlet要绑定Spring配置文件--&gt;\n        &lt;init-param&gt;\n            &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;\n            &lt;param-value&gt;classpath:springmvc-servlet.xml&lt;/param-value&gt;\n        &lt;/init-param&gt;\n        &lt;!--启动级别--&gt;\n        &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;\n    &lt;/servlet&gt;\n\n    &lt;!--    springMVC中：--&gt;\n    &lt;!--    / :只匹配所有的请求，不会去匹配jsp页面--&gt;\n    &lt;!--    /* :匹配所有请求，包括jsp页面--&gt;\n    &lt;servlet-mapping&gt;\n        &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt;\n        &lt;url-pattern&gt;/&lt;/url-pattern&gt;\n    &lt;/servlet-mapping&gt;\n\n&lt;/web-app&gt;\n\n在resources文件夹中创建一个springmvc-servlet.xml文件\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;\n&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;\n       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;\n       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;\n       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans\n       http://www.springframework.org/schema/beans/spring-beans.xsd\n       http://www.springframework.org/schema/context\n       http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;\n\n    &lt;!--    处理器映射器--&gt;\n    &lt;bean class=&quot;org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping&quot;/&gt;\n    &lt;!--    处理器适配器--&gt;\n    &lt;bean class=&quot;org.springframework.web.servlet.mvc.SimpleControllerHandlerAdapter&quot;/&gt;\n    &lt;!--    视图解析器--&gt;\n    &lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot; id=&quot;internalResourceViewResolver&quot;&gt;\n        &lt;!--        前缀--&gt;\n        &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/jsp/&quot;/&gt;\n        &lt;!--        后缀--&gt;\n        &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot;/&gt;\n    &lt;/bean&gt;\n\n    &lt;bean id=&quot;/hello&quot; class=&quot;com.kuang.controller.HelloController&quot;/&gt;\n\n&lt;/beans&gt;\n\n注意点：\n\n配置DispatcherServlet\n\n关联SpringMVC配置文件\n\n启动级别为1\n\n映射路径为/【不要用/*】\n\n\n创建一个控制器com.kuang.controller.HelloController\npackage com.kuang.controller;\n\nimport org.springframework.web.servlet.ModelAndView;\nimport org.springframework.web.servlet.mvc.Controller;\n\npublic class HelloController implements Controller &#123;\n    @Override\n    public ModelAndView handleRequest(javax.servlet.http.HttpServletRequest httpServletRequest, javax.servlet.http.HttpServletResponse httpServletResponse) throws Exception &#123;\n        ModelAndView mv = new ModelAndView();\n\n        String res = &quot;Hello&quot;;\n\n        mv.addObject(&quot;msg&quot;, res);\n        mv.setViewName(&quot;test&quot;);//返回test.jsp\n\n        return mv;\n    &#125;\n&#125;\n\n到此，我们的项目就创建完毕了\n如果发现无法允许404错误，请确保lib依赖是否导入：\n点击file-》project Settings-》Artifacts\n\n\n右键WEB-INF添加lib文件夹，右键lib-》add copy of-》library Files将所有依赖添加\n注解开发用注解开发我们只需要更改springmvc-servlet.xml文件\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;\n&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;\n       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;\n       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;\n       xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot;\n       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans\n       http://www.springframework.org/schema/beans/spring-beans.xsd\n       http://www.springframework.org/schema/context\n       http://www.springframework.org/schema/context/spring-context.xsd\n       http://www.springframework.org/schema/mvc\n       http://www.springframework.org/schema/mvc/spring-mvc.xsd&quot;&gt;\n\n    &lt;!--    自动扫描包 让指定包下的注解生效 由IOC容器统一管理--&gt;\n    &lt;context:component-scan base-package=&quot;com.kuang.controller&quot;/&gt;\n    &lt;!--    让SpringMVC不处理静态资源文件--&gt;\n    &lt;mvc:default-servlet-handler/&gt;\n    &lt;!--    支持mvc注解驱动--&gt;\n    &lt;!--    在spring中一般采用@RequestMapping注解完成映射关系--&gt;\n    &lt;!--    要想使@RequestMapping注解生效--&gt;\n    &lt;!--    必须向上下文中注册DefaultAnnotationHandlerMapping--&gt;\n    &lt;!--    和一个AnnotationMethodHandlerAdapter实例--&gt;\n    &lt;!--    而annotation-driven配置帮我们自动完成了上述两个实例的注入--&gt;\n    &lt;mvc:annotation-driven/&gt;\n\n\n    &lt;!--    视图解析器--&gt;\n    &lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot; id=&quot;internalResourceViewResolver&quot;&gt;\n        &lt;!--        前缀--&gt;\n        &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/jsp/&quot;/&gt;\n        &lt;!--        后缀--&gt;\n        &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot;/&gt;\n    &lt;/bean&gt;\n\n&lt;/beans&gt;\n\n@Controller\n@RequestMapping(&quot;hello&quot;)\npublic class HelloController &#123;\n\n    @RequestMapping(&quot;/h1&quot;)\n    public String hello(Model model)&#123;\n        model.addAttribute(&quot;msg&quot;, &quot;hello&quot;);\n        return &quot;test&quot;;\n    &#125;\n\n&#125;\n\n使用springMVC必须配置三大件：\n处理器映射器、处理器适配器、视图解析器\n通常，我们只需要手动配置视图解析器，而处理器映射器和处理器适配器只需要开启注解驱动即可\n参考文章01：https://blog.csdn.net/weixin_44635198/article/details/107444925\n","categories":["Java"],"tags":["SpringMVC","Maven","IDEA"]},{"title":"Spring","url":"/2021/03/28/Spring/","content":"1、Spring1.2、优点\nSpring 是一个开源的免费框架（容器）\nSpring 是一个轻量级的、非入侵式的框架！\n控制反转（IOC），面向切面编程（AOP）\n支持事务的处理，对框架整合的支持\n\n总结一句话：Spring 是一个轻量级的控制反转和面向切面编程的框架\n1.3、组成\n1.4、拓展\nSpringBoot\n一个快速开发的脚手架\n基于 SpringBoot 可以快速的开发单个微服务\n约定大于配置！\n\n\nSpring Cloud\nSpringCloud 是基于 SpringBoot 实现的\n\n\n\n现在大多数公司都在使用 SpringBoot 进行快速开发，学习 SpringBoot 的前提，需要完全掌握 Spring 及 SpringMVC！承上启下\n2、IOC 理论推导\nUserDao 接口\nUserDaoImpl 实现类\nUserService 业务接口\nUserServiceImpl 业务实现类\n\n在我们之前的业务中，用户的需求可能会影响我们原来的代码，我们需要根据用户的需求去修改原代码！如果程序代码量十分大，修改一次的成本代价十分昂贵！\n我们使用一个 Set 接口实现:\nprivate UserDao userDao; //利用set进行动态实现值的注入！\n\npublic void setUserDao(UserDao userDao)\n&#123;\n    this.userDao=userDao;\n&#125;\n\n\n之前，程序是主动创建对象！控制权在程序员手上\n使用 set 之后，程序不在具有主动性，而是被动的接受对象（对扩展开发，对修改关闭）\n\n从本质上解决问题，不需要管理对象的创建，耦合性降低，专注于业务实现，这就是 IOC 的原型。\nIOC 本质IOC 控制反转是一种设计思想，DI(依赖注入) 是实现 IOC 的一种方法。没有 IOC 的程序中，我们使用面向对象编程，对象的创建与对象间的依赖关系完全硬编码在程序中，对象的创建由程序自己控制。控制反转之后将对象的创建转移给第三方，个人理解控制反转就是：获得依赖对象的方式发生转变了。\nIOC 是 Spring 框架的核心内容，使用多种方式完美的实现的 Ioc，可以使用 xml 配置，也可以使用注解，新版本的 Spring 也可以零配置实现 IOC（自动装配）。\n采用 xml 方式配置 Bean 的时候，Bean 的定义信息和实现是分离的，采用注解的方式可以把两者合为一体。Bean 的定义信息直接以注解的形式在定义在实现类中，从而达到零配置的目的。\n控制反转是一种通过描述 xml 或者注解，并通过第三方去生产或获取特定对象的方式。在 Spring 中实现控制反转的是 IOC 容器，其实现方式是依赖注入。\n3、HelloSpringpublic class Hello &#123;\n    private String str;\n\n    @Override\n    public String toString() &#123;\n        return &quot;Hello&#123;&quot; +\n                &quot;str=&#39;&quot; + str + &#39;\\&#39;&#39; +\n                &#39;&#125;&#39;;\n    &#125;\n\n    public String getStr() &#123;\n        return str;\n    &#125;\n\n    public void setStr(String str) &#123;\n        this.str = str;\n    &#125;\n&#125;\n\nhttps://docs.spring.io/spring-framework/docs/current/reference/html/core.html#spring-core\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;\n&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;\n       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;\n       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans\n        https://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;\n\n    &lt;bean id=&quot;hello&quot; class=&quot;com.kuang.pojo.Hello&quot;&gt;\n        &lt;property name=&quot;str&quot; value=&quot;Hello Spring&quot;/&gt;\n        &lt;!--\n            ref：引用Spring容器中创建好的对象\n            value：引用具体的值，基本数据类型\n        --&gt;\n    &lt;/bean&gt;\n&lt;/beans&gt;\n\npublic class MyTest &#123;\n    public static void main(String[] args) &#123;\n        //获取ApplicationContext：拿取Spring的容器\n        ApplicationContext context = new ClassPathXmlApplicationContext(&quot;beans.xml&quot;);\n\n        //需要什么，就get什么\n        Hello hello = (Hello) context.getBean(&quot;hello&quot;);\n\n        System.out.println(hello.toString());\n    &#125;\n&#125;\n\n\nHello 对象是谁创建的？\nhello 对象是由 Spring 创建的\n\n\nHello 对象的属性是怎么设置的\nhello 对象的属性是由 Spring 容器设置的\n\n\n\n上面就用配置文件的形式，实现了控制反转\n控制：谁来控制对象的创建，传统应用程序的对象是有程序本身来控制创建的，使用 Spring 后，对象是由 Spring 来创建\n反转：程序本身不创建对象，而变成被动的接收对象\n依赖注入：利用 set 的方法来进行注入\nIOC 是一种变成思想，由主动的编程变成被动的编程\n所谓 IOC 就是：对象由 Spring 来创建，管理，装配！\n4、IOC 创建对象的方式&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;\n&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;\n       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;\n       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans\n        https://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;\n\n    &lt;!--默认无参构造，有参会报错--&gt;\n    &lt;bean id=&quot;user&quot; class=&quot;com.kuang.pojo.User&quot;&gt;\n        &lt;property name=&quot;name&quot; value=&quot;saber01&quot;/&gt;\n    &lt;/bean&gt;\n\n    &lt;!--第一种：构造函数参数名赋值--&gt;\n    &lt;bean id=&quot;user&quot; class=&quot;com.kuang.pojo.User&quot;&gt;\n        &lt;constructor-arg name=&quot;name&quot; value=&quot;saber02&quot;/&gt;\n    &lt;/bean&gt;\n\n    &lt;!--第二种：构造函数参数索引赋值--&gt;\n    &lt;bean id=&quot;user&quot; class=&quot;com.kuang.pojo.User&quot;&gt;\n        &lt;constructor-arg index=&quot;0&quot; value=&quot;saber02&quot;/&gt;\n    &lt;/bean&gt;\n\n    &lt;!--第三种：构造函数参数类型匹配赋值--&gt;\n    &lt;bean id=&quot;user&quot; class=&quot;com.kuang.pojo.User&quot;&gt;\n        &lt;constructor-arg type=&quot;java.lang.String&quot; value=&quot;saber02&quot;/&gt;\n    &lt;/bean&gt;\n&lt;/beans&gt;\n\n总结：在配置文件加载时，容器中管理的对象就已经被初始化了，且是单例的\n5、Spring 配置5.1、别名&lt;alias name=&quot;user&quot; alias=&quot;userNew&quot;/&gt;\n\nUser user = (User) context.getBean(&quot;userNew&quot;);\n\n添加了别名(alias)，可以用别名获取对象\n5.2、Bean 的配置&lt;!--\n    id：bean的唯一标识，相当于对象名\n    class：bean对象所对应的全限定名：包名+类型\n    name：也是别名，而且name可以同时取多个，可以用各种符号分开\n--&gt;\n&lt;bean id=&quot;hello&quot; class=&quot;com.kuang.pojo.Hello&quot; name=&quot;user2 u2;u3,u4&quot;&gt;\n    &lt;property name=&quot;str&quot; value=&quot;Hello Spring&quot;/&gt;\n&lt;/bean&gt;\n\n5.3、import一般用于团队开发，可以将多个配置文件合并成一个:applicationContext.xml\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;\n&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;\n       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;\n       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;\n\n    &lt;import resource=&quot;beans.xml&quot;/&gt;\n    &lt;import resource=&quot;beans02.xml&quot;/&gt;\n\n&lt;/beans&gt;\n\n更多的信息可以前往\n进行查看\n6、依赖注入6.1、构造器方式注入上面的就是\n6.2、Set 方式注入【重点】\n依赖注入：Set 注入\n依赖：bean 对象的创建依赖于容器\n注入：bean 对象中的所有属性，由容器来注入\n\n\n\n【环境搭建】\n\n复杂类型\npublic class Address &#123;\n    private String address;\n\n    public String getAddress() &#123;\n        return address;\n    &#125;\n\n    public void setAddress(String address) &#123;\n        this.address = address;\n    &#125;\n&#125;\n\n\n真实测试对象\n//get set略\npublic class Student &#123;\n    private String name;\n    private Address address;\n    private String[] books;\n    private List&lt;String&gt; hobbys;\n    private Map&lt;String,String&gt; card;\n    private Set&lt;String&gt; games;\n    private String wife;\n    private Properties info;\n&#125;\n\n\nbeans.xml\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;\n&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;\n       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;\n       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;\n\n    &lt;bean id=&quot;student&quot; class=&quot;com.kuang.pojo.Student&quot;&gt;\n        &lt;property name=&quot;name&quot; value=&quot;saber&quot;/&gt;\n    &lt;/bean&gt;\n\n&lt;/beans&gt;\n\n\n测试类\npublic class MyTest &#123;\n    public static void main(String[] args) &#123;\n        ApplicationContext context = new ClassPathXmlApplicationContext(&quot;beans.xml&quot;);\n\n        Student student = (Student) context.getBean(&quot;student&quot;);\n\n        System.out.println(student.toString());\n    &#125;\n&#125;\n\n\n\n完善注入信息\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;\n&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;\n       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;\n       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;\n\n    &lt;bean id=&quot;address&quot; class=&quot;com.kuang.pojo.Address&quot;&gt;\n        &lt;property name=&quot;address&quot; value=&quot;000000000000000&quot;/&gt;\n    &lt;/bean&gt;\n\n    &lt;bean id=&quot;student&quot; class=&quot;com.kuang.pojo.Student&quot;&gt;\n\n        &lt;property name=&quot;name&quot; value=&quot;saber&quot;/&gt;\n        &lt;property name=&quot;address&quot; ref=&quot;address&quot;/&gt;\n\n        &lt;!--数组--&gt;\n        &lt;property name=&quot;books&quot;&gt;\n            &lt;array&gt;\n                &lt;value&gt;a1&lt;/value&gt;\n                &lt;value&gt;a2&lt;/value&gt;\n                &lt;value&gt;a3&lt;/value&gt;\n                &lt;value&gt;a4&lt;/value&gt;\n            &lt;/array&gt;\n        &lt;/property&gt;\n\n        &lt;!--list--&gt;\n        &lt;property name=&quot;hobbys&quot;&gt;\n            &lt;list&gt;\n                &lt;value&gt;l1&lt;/value&gt;\n                &lt;value&gt;l2&lt;/value&gt;\n                &lt;value&gt;l3&lt;/value&gt;\n                &lt;value&gt;l4&lt;/value&gt;\n            &lt;/list&gt;\n        &lt;/property&gt;\n\n        &lt;!--Map--&gt;\n        &lt;property name=&quot;card&quot;&gt;\n            &lt;map&gt;\n                &lt;entry key=&quot;a&quot; value=&quot;a1&quot;/&gt;\n                &lt;entry key=&quot;b&quot; value=&quot;b2&quot;/&gt;\n                &lt;entry key=&quot;c&quot; value=&quot;c3&quot;/&gt;\n            &lt;/map&gt;\n        &lt;/property&gt;\n\n        &lt;!--Set--&gt;\n        &lt;property name=&quot;games&quot;&gt;\n            &lt;set&gt;\n                &lt;value&gt;s1&lt;/value&gt;\n                &lt;value&gt;s2&lt;/value&gt;\n                &lt;value&gt;s3&lt;/value&gt;\n            &lt;/set&gt;\n        &lt;/property&gt;\n\n        &lt;!--null--&gt;\n        &lt;property name=&quot;wife&quot;&gt;\n            &lt;null&gt;&lt;/null&gt;\n        &lt;/property&gt;\n\n        &lt;!--Properties--&gt;\n        &lt;property name=&quot;info&quot;&gt;\n            &lt;props&gt;\n                &lt;prop key=&quot;Email_1&quot;&gt;1347216032@qq.com&lt;/prop&gt;\n                &lt;prop key=&quot;Email_2&quot;&gt;3081453914@qq.com&lt;/prop&gt;\n            &lt;/props&gt;\n        &lt;/property&gt;\n    &lt;/bean&gt;\n&lt;/beans&gt;\n\n6.3、拓展方式注入C 与 P 命名空间&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;\n&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;\n       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;\n       xmlns:p=&quot;http://www.springframework.org/schema/p&quot;\n       xmlns:c=&quot;http://www.springframework.org/schema/c&quot;\n       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;\n\n    &lt;!--p命名空间注入，可以直接注入属性的值：property--&gt;\n    &lt;bean id=&quot;user&quot; class=&quot;com.kuang.pojo.User&quot; p:name=&quot;saber-u&quot; p:age=&quot;18&quot;&gt;&lt;/bean&gt;\n\n    &lt;!--c命名空间注入，通过构造器注入属性的值：construct-args--&gt;\n    &lt;bean id=&quot;user2&quot; class=&quot;com.kuang.pojo.User&quot; c:name=&quot;saber-u-2&quot; c:age=&quot;20&quot;/&gt;\n\n&lt;/beans&gt;\n\n测试\n@Test\npublic void test2()&#123;\n    ApplicationContext context = new ClassPathXmlApplicationContext(&quot;userbeans.xml&quot;);\n    User user = context.getBean(&quot;user2&quot;, User.class);\n\n    System.out.println(user.toString());\n&#125;\n\n注意：p/c 命名空间不能直接使用，要引入 xml 约束\nxmlns:p=&quot;http://www.springframework.org/schema/p&quot;\nxmlns:c=&quot;http://www.springframew\n\n6.4、bean 的作用域\n\n单例模式（spring 的默认模式）\n&lt;!-- the following is equivalent, though redundant (singleton scope is the default) --&gt;\n&lt;bean id=&quot;accountService&quot; class=&quot;com.something.DefaultAccountService&quot; scope=&quot;singleton&quot;/&gt;\n\n\n\n原型模式：每次从容器 get 的时候，都会产生一个新的对象\n&lt;bean id=&quot;accountService&quot; class=&quot;com.something.DefaultAccountService&quot; scope=&quot;prototype&quot;/&gt;\n\n\n\n其余的request，session，applicatoin这些只能在 web 开发中使用！\n\n\n7、Bean 的自动装配\n自动装配是 Spring 满足 bean 依赖的一种方式\nSpring 会在上下文中自动寻找，并自动给 bean 装配属性\n\n在 Spring 中有三种装配方式\n\n在 xml 中显示的配置\n在 java 中显示配置\n隐式的自动装配 bean\n\n7.1、ByName 自动装配&lt;bean id=&quot;cat&quot; class=&quot;com.kuang.pojo.Cat&quot;&gt;&lt;/bean&gt;\n&lt;bean id=&quot;dog&quot; class=&quot;com.kuang.pojo.Dog&quot;&gt;&lt;/bean&gt;\n\n&lt;!--\n    byName:会自动在容器中上下文查找，和自己对象set方法后面的值对应的beanid\n--&gt;\n&lt;bean id=&quot;perple&quot; class=&quot;com.kuang.pojo.People&quot; autowire=&quot;byName&quot;&gt;\n    &lt;property name=&quot;name&quot; value=&quot;saber&quot;/&gt;\n&lt;/bean&gt;\n\n7.2、ByType 自动装配&lt;bean id=&quot;cat&quot; class=&quot;com.kuang.pojo.Cat&quot;&gt;&lt;/bean&gt;\n&lt;bean id=&quot;dog&quot; class=&quot;com.kuang.pojo.Dog&quot;&gt;&lt;/bean&gt;\n\n&lt;!--\n    byType:会自动在容器中上下文查找，和自己对象属性类型相同的bean，\n--&gt;\n&lt;bean id=&quot;perple&quot; class=&quot;com.kuang.pojo.People&quot; autowire=&quot;byType&quot;&gt;\n    &lt;property name=&quot;name&quot; value=&quot;saber&quot;/&gt;\n&lt;/bean&gt;\n\n小结：\n\nbyname 的时候，需要保证所有 bean 的 id 唯一，并且这个 bean 需要和自动注入的属性的 set 方法的值一致\nbytype 的时候，需要保证所有 bean 的 class 唯一，并且这个 bean 需要和自动注入的属的类型一致\n\n7.3、使用注解实现自动装配jdk1.5 支持的注解，Spring2.5 就支持注解了\nThe introduction of annotation-based configuration raised the question of whether this approach is “better” than XML.\n使用注解须知：\n\n导入约束\n\n配置注解的支持\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;\n&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;\n    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;\n    xmlns:context=&quot;http://www.springframework.org/schema/context&quot;\n    xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans\n        https://www.springframework.org/schema/beans/spring-beans.xsd\n        http://www.springframework.org/schema/context\n        https://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;\n    &lt;context:annotation-config/&gt;\n&lt;/beans&gt;\n\n\n\n@Autowired\n直接在属性上使用即可，也可以在 set 方法使用\n使用 Autowired 我们可以不用编写 Set 方法，前提是你这个自动装配的属性在 IOC（Spring）容器中存在，且符合名字 byname\n@Autowired 默认根据类型进行匹配，若 xml 中同时存在多个相同类型时，则按名称进行匹配，若没用相同名称的配置时，则需要使用@Qualifier(value = “name”)注解进行指定，同时@Autowired 中还存在 required 属性，默认为 true，若为 false 时，说明对象可以为 null，否则不允许为空\n    &lt;bean id=&quot;cat&quot; class=&quot;com.kuang.pojo.Cat&quot;&gt;&lt;/bean&gt;\n&lt;!--    &lt;bean id=&quot;dog&quot; class=&quot;com.kuang.pojo.Dog&quot;&gt;&lt;/bean&gt;--&gt;\n    &lt;bean id=&quot;dog2&quot; class=&quot;com.kuang.pojo.Dog&quot;&gt;&lt;/bean&gt;\n    &lt;bean id=&quot;dog22&quot; class=&quot;com.kuang.pojo.Dog&quot;&gt;&lt;/bean&gt;\n\n    &lt;bean id=&quot;perple&quot; class=&quot;com.kuang.pojo.People&quot;&gt;\n        &lt;property name=&quot;name&quot; value=&quot;saber&quot;/&gt;\n    &lt;/bean&gt;\n\n    @Autowired\n    private Cat cat;\n\n    @Autowired\n    @Qualifier(value = &quot;dog22&quot;)\n    private Dog dog;\n\n    private String name;\n\n@Resource\n    @Resource(name = &quot;cat22&quot;)\n    private Cat cat;\n\n    @Resource\n    private Dog dog;\n\n小结：\n@Resource 和@Autowired 的区别：\n\n都是用于自动装配，都可以放在字段上\n@Autowired 通过 bytype 的方式实现，而且对象必须存在\n@Resource 默认通过 byname 实现，如果找不到名字，则通过 bytyoe 实现，如果两个都找不到，则报错\n\n8、使用注解开发&lt;!--注意：需要引入AOP包--&gt;\n&lt;!--需要扫描的包--&gt;\n&lt;context:component-scan base-package=&quot;com.kuang.pojo&quot;/&gt;\n&lt;context:annotation-config/&gt;\n\n\n@Component 组件\n//等价于&lt;bean id=&quot;user&quot; class=&quot;com.kuang.pojo.User&quot;/&gt; 无须在xml中写\n@Component\npublic class User &#123;\n    public String name=&quot;saber&quot;;\n&#125;\n\n@Value\n@Component\npublic class User &#123;\n    //等价于 &lt;property name=&quot;name&quot; value=&quot;saber&quot;/&gt;\n    @Value(&quot;SABER&quot;)\n    public String name;\n&#125;\n\n@Component 衍生注解，根据不同的层使用不同的注解\n\ndao 层【@Repository】\nservice 层【@Service】\ncontroller 层【@Controller】\n\n这四个注解功能都是一样的，都代表将某个类注册到 Spring 中，装配 Bean\n作用域也可以直接通过@Scope(&quot;&quot;)实现\n小结：\nxml 与注解：\n\nxml 更加万能，适用于各种场合，维护简单\n注解不是自己类使用不了，维护相对复杂\n\nxml 与注解的最佳实践：\n\nxml 来管理 bean\n\n注解只负责完成属性的注入\n\n我们使用中，只需要注意一个问题：必须让注解生效，就需要开启注解的支持\n&lt;!--需要扫描的包--&gt;\n&lt;context:component-scan base-package=&quot;com.kuang&quot;/&gt;\n&lt;context:annotation-config/&gt;\n\n\n\n9、使用 Java 的方式配置 SpringJavaConfig 是 Spring 的一个子项目\n实体类：\npackage com.kuang.pojo;\n\nimport org.springframework.beans.factory.annotation.Value;\nimport org.springframework.stereotype.Component;\n\n//@Component\npublic class User &#123;\n    @Value(&quot;saber&quot;)\n    private String name;\n\n    public String getName() &#123;\n        return name;\n    &#125;\n\n    public void setName(String name) &#123;\n        this.name = name;\n    &#125;\n\n    @Override\n    public String toString() &#123;\n        return &quot;User&#123;&quot; +\n                &quot;name=&#39;&quot; + name + &#39;\\&#39;&#39; +\n                &#39;&#125;&#39;;\n    &#125;\n&#125;\n\n配置文件类：\npackage com.kuang.config;\n\nimport com.kuang.pojo.User;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.ComponentScan;\nimport org.springframework.context.annotation.Configuration;\n\n//这个也会被Spring容器托管，注册到容器中，因为它本身就是一个@Component\n//@Configuration表示这是一个配置类，就是之前的beans.xml\n@Configuration\n//@ComponentScan(&quot;com.kuang.pojo&quot;) //扫描指定包\n@Import(SaberConfig2.class) //相当于Import标签\npublic class SaberConfig &#123;\n\n    //注册一个bean 相当于之前的&lt;bean&gt;标签\n    //方法名相当于bean标签的id\n    //返回值相当于bean标签的class属性\n    @Bean\n    public User getUser()&#123;\n        return new User();//我们要注入到bean的对象\n    &#125;\n&#125;\n//如果你没用扫描指定包@ComponentScan(&quot;com.kuang.pojo&quot;) 则必须使用@Bean主动进行配置，\n//如果使用@ComponentScan(&quot;com.kuang.pojo&quot;)扫描，则扫描对象必须包含@Component\n\n测试方法:\n    public static void main(String[] args) &#123;\n        ApplicationContext ctx = new AnnotationConfigApplicationContext(SaberConfig.class);\n        User user = ctx.getBean(User.class);//也可以用方法名getUser,也可以用@Bean指定的名称\n        System.out.println(user.getName());\n    &#125;\n\n10、代理模式代理模式的分类：\n\n静态代理\n动态代理\n\n\n10.1、静态代理角色分析：\n\n抽象角色：一般会使用接口或抽象类来解决\n真实角色：被代理的角色\n代理角色：代理真实角色，代理真实角色后，我们一般会做一些附属操作\n客户：访问代理对象\n\n代码步骤：\n\n接口\n//租房\npublic interface Rent &#123;\n    public void rent();\n&#125;\n\n\n真实角色\npublic class Host implements Rent&#123;\n    @Override\n    public void rent() &#123;\n        System.out.println(&quot;房东要租房子&quot;);\n    &#125;\n&#125;\n\n\n代理角色\npublic class Proxy implements Rent&#123;\n\n    private Host host;\n\n    public Proxy() &#123;\n    &#125;\n\n    public Proxy(Host host) &#123;\n        this.host = host;\n    &#125;\n\n    @Override\n    public void rent() &#123;\n        seeHouse();\n        host.rent();\n        hetong();\n        fare();\n    &#125;\n\n    public void seeHouse()&#123;\n        System.out.println(&quot;kan fang&quot;);\n    &#125;\n\n    public void hetong()&#123;\n        System.out.println(&quot;qian he tong&quot;);\n    &#125;\n\n    public void fare()&#123;\n        System.out.println(&quot;shou zhong jie fei&quot;);\n    &#125;\n&#125;\n\n\n客户端访问代理角色\n    public static void main(String[] args) &#123;\n        Host host = new Host();\n//        host.rent();\n\n        Proxy proxy = new Proxy(host);\n        proxy.rent();\n    &#125;\n\n\n\n代理模式的好处：\n\n可以使真实角色的操作更加纯粹，不用去关注一些公共服务\n公共服务交给代理角色，实现业务划分\n公共业务发生扩展时，方便集中管理\n\n缺点：\n\n一个真实角色就会产生一个代理角色，代码量翻倍，开发效率变低\n\n10.2、动态代理\n动态代理和静态代理角色一样\n动态代理的代理类是动态生成的，不是写好的\n动态代理分为两大类：基于接口的动态代理，基于类的动态代理\n基于接口：JDK 实现动态代理\n基于类：cglib\njava 字节码实现：javasist\n\n\n\n需要了解两个类：Proxy：代理， InvocationHandler：调用处理程序\n动态代理的好处：\n\n可以使真实角色的操作更加纯粹，不用去关注一些公共服务\n公共服务交给代理角色，实现业务划分\n公共业务发生扩展时，方便集中管理\n一个动态代理类代理的是一个接口，一般是对应的一类业务\n一个动态代理类可以代理多个类，只要实现了同一个接口即可\n\n动态代理的代码实现：\nimport java.lang.reflect.InvocationHandler;\nimport java.lang.reflect.Method;\nimport java.lang.reflect.Proxy;\n\npublic class StarProxy implements InvocationHandler\n&#123;\n    // 目标类，也就是被代理对象\n    private Object target;\n\n    public void setTarget(Object target)\n    &#123;\n        this.target = target;\n    &#125;\n\n    @Override\n    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable\n    &#123;\n        // 这里可以做增强\n        System.out.println(&quot;收钱&quot;);\n\n        Object result = method.invoke(target, args);\n\n        return result;\n    &#125;\n\n    // 生成代理类\n    public Object CreatProxyedObj()\n    &#123;\n        return Proxy.newProxyInstance(target.getClass().getClassLoader(), target.getClass().getInterfaces(), this);\n    &#125;\n\n&#125;\n\n11、AOP11.1、什么是 AOPAOP（Aspect Oriented Programming）称为面向切面编程，在程序开发中主要用来解决一些系统层面上的问题，比如日志，事务，权限等待，AOP 是 OOP 的延续，是软件开发中的热点，是函数是编程的一种衍生范型，利用 AOP 可以对业务逻辑的各部分进行隔离，从而使业务逻辑各部分之间的耦合降低，提高可重用性。\n11.2、AOP 在 Spring 的作用提供声明性事务，允许用户自定义切面\n\n横切关注点：跨越应用程序多个模块的方法或功能，即是，与我们业务逻辑无关，但是我们需要关注的部分，就是横切关注点，如日志，安全，缓存，事务等等….\n切面（ASPECT）：横切关注点 被模块化 的特殊对象。即，它是一个类。\n通知（Advice）：切面必须要完成的工作。即，它是类中的一个方法。\n目标（Target）：被通知的对象。\n代理（Proxy）：向目标对象应用通知之后创建的对象\n切入点（PointCut）：切面通知 执行的“地点”的定义\n连接点（JointPoint）：与切入点匹配的执行点\n\n\nSpringAOP 中，通过 Advice 定义横切逻辑，Spring 中支持 5 种类型的 Advice：\n\n即 AOP 在不改变原有代码的情况下，去增加新的功能\n11.3、使用 Spring 实现 AOP使用 AOP 织入，需要导入一个依赖包\n&lt;dependency&gt;\n    &lt;groupId&gt;org.aspectj&lt;/groupId&gt;\n    &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt;\n    &lt;version&gt;1.9.4&lt;/version&gt;\n&lt;/dependency&gt;\n\n方法一：使用 Spring 接口@Component\npublic class Log implements MethodBeforeAdvice &#123;\n    //method：要执行的目标对象的方法\n    //objects：参数\n    //o：目标对象\n    @Override\n    public void before(Method method, Object[] objects, Object o) throws Throwable &#123;\n        System.out.println(o.getClass().getName() +&quot;的&quot;+method.getName()+&quot;方法被执行&quot;);\n    &#125;\n&#125;\n\n@Component\npublic class AfterLog implements AfterReturningAdvice &#123;\n    //returnValue：返回值\n    @Override\n    public void afterReturning(Object returnValue, Method method, Object[] args, Object target) throws Throwable &#123;\n        System.out.println(&quot;执行了&quot;+method.getName() +&quot;方法,返回结果:&quot;+returnValue);\n    &#125;\n&#125;\n\n上面实现两个测试用的切面方法\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;\n&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;\n       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;\n       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;\n       xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;\n       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans\n        https://www.springframework.org/schema/beans/spring-beans.xsd\n        http://www.springframework.org/schema/context\n        https://www.springframework.org/schema/context/spring-context.xsd\n        http://www.springframework.org/schema/aop\n        https://www.springframework.org/schema/aop/spring-aop.xsd&quot;&gt;\n\n    &lt;context:component-scan base-package=&quot;com.kuang&quot;/&gt;\n    &lt;context:annotation-config/&gt;\n\n    &lt;!--方法一：使用原生SpringAPI接口--&gt;\n    &lt;!--配置aop：需要导入aop约束--&gt;\n    &lt;aop:config&gt;\n        &lt;!--DOTO:切入点：expression：表达式，execution(要执行的位置！)--&gt;\n        &lt;aop:pointcut id=&quot;pointuct&quot; expression=&quot;execution(* com.kuang.service.UserServiceImpl.*(..))&quot;/&gt;\n\n        &lt;!--要执行的环绕增加--&gt;\n        &lt;aop:advisor advice-ref=&quot;afterLog&quot; pointcut-ref=&quot;pointuct&quot;/&gt;\n        &lt;aop:advisor advice-ref=&quot;log&quot; pointcut-ref=&quot;pointuct&quot;/&gt;\n    &lt;/aop:config&gt;\n\n&lt;/beans&gt;\n\npublic class MyTest &#123;\n    public static void main(String[] args) &#123;\n        ApplicationContext context = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);\n        UserService userService = context.getBean(&quot;userServiceImpl&quot;,UserService.class);\n\n        userService.add();\n    &#125;\n&#125;\n\n方法二：自定义类实现 AOP将配置文件修改为：\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;\n&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;\n       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;\n       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;\n       xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;\n       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans\n        https://www.springframework.org/schema/beans/spring-beans.xsd\n        http://www.springframework.org/schema/context\n        https://www.springframework.org/schema/context/spring-context.xsd\n        http://www.springframework.org/schema/aop\n        https://www.springframework.org/schema/aop/spring-aop.xsd&quot;&gt;\n\n    &lt;context:component-scan base-package=&quot;com.kuang&quot;/&gt;\n    &lt;context:annotation-config/&gt;\n\n    &lt;!--方法二：自定义类--&gt;\n    &lt;aop:config&gt;\n        &lt;!--自定义切面，ref要引用的类--&gt;\n        &lt;aop:aspect ref=&quot;diyPintCut&quot;&gt;\n            &lt;!--切入点--&gt;\n            &lt;aop:pointcut id=&quot;point&quot; expression=&quot;execution(* com.kuang.service.UserServiceImpl.*(..))&quot;/&gt;\n\n            &lt;!--通知--&gt;\n            &lt;aop:after method=&quot;after&quot; pointcut-ref=&quot;point&quot;/&gt;\n            &lt;aop:before method=&quot;before&quot; pointcut-ref=&quot;point&quot;/&gt;\n        &lt;/aop:aspect&gt;\n    &lt;/aop:config&gt;\n\n&lt;/beans&gt;\n\n实现的自定义类：\nimport org.springframework.stereotype.Component;\n@Component\npublic class DiyPintCut &#123;\n    public void before()&#123;\n        System.out.println(&quot;=======berfre========&quot;);\n    &#125;\n    public void after()&#123;\n        System.out.println(&quot;=======after========&quot;);\n    &#125;\n&#125;\n\n方式三：使用注解实现import org.aspectj.lang.ProceedingJoinPoint;\nimport org.aspectj.lang.annotation.After;\nimport org.aspectj.lang.annotation.Around;\nimport org.aspectj.lang.annotation.Aspect;\nimport org.aspectj.lang.annotation.Before;\nimport org.springframework.stereotype.Component;\n\n@Aspect //标注这是一个切面\n@Component\npublic class AnnotationPointCut &#123;\n    @Before(&quot;execution(* com.kuang.service.UserServiceImpl.*(..))&quot;)//注意 这是annotation包下的注解\n    public void before() &#123;\n        System.out.println(&quot;=======berfre========&quot;);\n    &#125;\n\n    @After(&quot;execution(* com.kuang.service.UserServiceImpl.*(..))&quot;)\n    public void after() &#123;\n        System.out.println(&quot;=======after========&quot;);\n    &#125;\n\n    //在环绕增强中，我们可以定一个参数，代表我们要获取处理的切入点\n    @Around(&quot;execution(* com.kuang.service.UserServiceImpl.*(..))&quot;)\n    public void around(ProceedingJoinPoint jp) throws Throwable &#123;\n        System.out.println(&quot;before-around&quot;);\n        System.out.println(jp.getSignature());//获取签名\n\n        Object proceed = jp.proceed();//执行方法 proceed：返回值\n\n        System.out.println(&quot;after-around&quot;);\n        System.out.println(proceed);\n    &#125;\n&#125;\n\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;\n&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;\n       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;\n       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;\n       xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;\n       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans\n        https://www.springframework.org/schema/beans/spring-beans.xsd\n        http://www.springframework.org/schema/context\n        https://www.springframework.org/schema/context/spring-context.xsd\n        http://www.springframework.org/schema/aop\n        https://www.springframework.org/schema/aop/spring-aop.xsd&quot;&gt;\n\n    &lt;context:component-scan base-package=&quot;com.kuang&quot;/&gt;\n    &lt;context:annotation-config/&gt;\n    &lt;!--开启注解支持 需要添加这个才能使用注解AOP--&gt;\n    &lt;!--有一个参数 默认为false 则为使用JDK实现动态代理 true则使用cglib   proxy-target-class=&quot;true&quot;--&gt;\n    &lt;aop:aspectj-autoproxy/&gt;\n\n&lt;/beans&gt;\n\n参考：\n文章：https://www.jianshu.com/p/34efe69582c8\n","categories":["Spring"],"tags":["Spring","AOP","IOC"]},{"title":"SpringBoot自定义校验注解","url":"/2021/03/19/SpringBoot%E8%87%AA%E5%AE%9A%E4%B9%89%E6%A0%A1%E9%AA%8C%E6%B3%A8%E8%A7%A3/","content":"引入指定包    &lt;dependency&gt;\n          &lt;groupId&gt;javax.validation&lt;/groupId&gt;\n        &lt;artifactId&gt;validation-api&lt;/artifactId&gt;\n        &lt;version&gt;2.0.1.Final&lt;/version&gt;\n    &lt;/dependency&gt;\n\n创建自定义校验类//必须包含一下注解\n@Documented\n@Constraint(validatedBy = &#123; ListValueConstraintValidator.class &#125;)//具体校验的实现，可以指定多个，适配不同的参数\n@Target(&#123; METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER, TYPE_USE &#125;)//我们的自定义注解可以在哪里使用\n@Retention(RUNTIME)\npublic @interface ListValue &#123;\n    \n    //jsr303规范中 校验注解必须包含下面三个属性\n    String message() default &quot;&#123;com.atguigu.common.valid.ListValue.message&#125;&quot;;//当校验出错时 错误信息去哪里取 和下面配置文件需要匹配\n    Class&lt;?&gt;[] groups() default &#123; &#125;; //必须支持分组校验\n    Class&lt;? extends Payload&gt;[] payload() default &#123; &#125;; //自定义负载信息\n\n    int[] vals() default &#123; &#125;;//校验的具体参数\n&#125;\n\n实体类中使用@ListValue(vals=&#123;0,1&#125;)//可以使用message自定义信息，也可以写在配置文件中\nprivate Integer showStatus;\n\n错误信息配置文件com.atguigu.common.valid.ListValue.message=必须提交指定的值\n\n校验的实现/*\n*    需要实现ConstraintValidator\n*    &lt;ListValue,Integer&gt; 校验注解，校验参数类型\n*/\npublic class ListValueConstraintValidator implements ConstraintValidator&lt;ListValue,Integer&gt; &#123;\n\n    private Set&lt;Integer&gt; set = new HashSet&lt;&gt;();\n    //初始化方法\n    @Override\n    public void initialize(ListValue constraintAnnotation) &#123;\n\n        int[] vals = constraintAnnotation.vals();//获取我们给定的值\n        for (int val : vals) &#123;\n            set.add(val);\n        &#125;\n    &#125;\n\n    //判断是否校验成功\n\n    /**\n     *\n     * @param value 需要校验的值，也就是我们提交的值\n     * @param context\n     * @return\n     */\n    @Override\n    public boolean isValid(Integer value, ConstraintValidatorContext context) &#123;\n\n        return set.contains(value);\n    &#125;\n&#125;\n\n","categories":["SpringBoot"],"tags":["Spring","SpringBoot"]},{"title":"SpringBoot分组校验","url":"/2021/03/19/SpringBoot%E5%88%86%E7%BB%84%E6%A0%A1%E9%AA%8C/","content":"在实际开发中，难免遇到对一个实体类的一些属性，不同的请求会有不同的校验规则的场景，比如：用户注册时，User 类的 id 需校验为空，因为 User 的 id 肯定是由系统生成并维护而不是让用户自己填写的。但是在修改用户密码时，又需要传入 Id 来作为 where 语句的条件去更新，此时分组校验就派上用场了。\n先上代码：\n/*\n*    一个普通的实体类\n*    在我们常用的校验注解中，有一个groups参数，用于标注校验注解属于哪一种情况才进行校验，可以指定多种情况\n*    groups = &#123;AddGroup.class,UpdateGroup.class&#125;\n*/\n@Data\n@TableName(&quot;pms_brand&quot;)\npublic class BrandEntity implements Serializable &#123;\n    private static final long serialVersionUID = 1L;\n\n    /**\n     * 品牌id\n     */\n    @NotNull(message = &quot;修改必须指定品牌id&quot;,groups = &#123;UpdateGroup.class&#125;)\n    @Null(message = &quot;新增不能指定id&quot;,groups = &#123;AddGroup.class&#125;)\n    @TableId\n    private Long brandId;\n    /**\n     * 品牌名\n     */\n    @NotBlank(message = &quot;品牌名必须提交&quot;,groups = &#123;AddGroup.class,UpdateGroup.class&#125;)\n    private String name;\n    /**\n     * 品牌logo地址\n     */\n    @NotBlank(groups = &#123;AddGroup.class&#125;)\n    @URL(message = &quot;logo必须是一个合法的url地址&quot;,groups=&#123;AddGroup.class,UpdateGroup.class&#125;)\n    private String logo;\n    /**\n     * 介绍\n     */\n    private String descript;\n    /**\n     * 显示状态[0-不显示；1-显示]\n     */\n    @NotNull(groups = &#123;AddGroup.class, UpdateStatusGroup.class&#125;)\n      @ListValue(vals=&#123;0,1&#125;,groups = &#123;AddGroup.class, UpdateStatusGroup.class&#125;)\n    private Integer showStatus;\n    /**\n     * 检索首字母\n     */\n    @NotEmpty(groups=&#123;AddGroup.class&#125;)\n    @Pattern(regexp=&quot;^[a-zA-Z]$&quot;,message = &quot;检索首字母必须是一个字母&quot;,groups=&#123;AddGroup.class,UpdateGroup.class&#125;)\n    private String firstLetter;\n    /**\n     * 排序\n     */\n    @NotNull(groups=&#123;AddGroup.class&#125;)\n    @Min(value = 0,message = &quot;排序必须大于等于0&quot;,groups=&#123;AddGroup.class,UpdateGroup.class&#125;)\n    private Integer sort;\n\n&#125;\n\n上面我们定义了AddGroup.class,UpdateGroup.class我们需要创建它们，它们以接口的形式存在，空接口就行了\n/*\n*    格式如下\n*/\npublic interface AddGroup &#123;\n&#125;\n\n具体需要实现分组校验功能，我们需要在controller做些修改\n我们不能使用普通的@Valid注解，它不具备实现分组校验的功能，我们需要换成@Validated注解，它可以指定一个或多个分组\n    /**\n     *    保存\n     *    返回结果R的实现去看我的 SpringBoot全局异常处理 文章\n     */\n    @RequestMapping(&quot;/save&quot;)\n    public R save(@Validated(&#123;AddGroup.class&#125;) @RequestBody BrandEntity brand)&#123;\n\n        brandService.save(brand);\n\n        return R.ok();\n    &#125;\n\n使用注意事项：\n当你启用了分组校验功能时@Validated(&#123;AddGroup.class&#125;)，但你的实体类中某个字段却没用指定分组，这种情况下，是不会对字段进行任何校验的\n相反，当你没用启用分组校验时@Validated，只有没用标注分组校验的字段才会生效\n","categories":["SpringBoot"],"tags":["Spring","SpringBoot"]},{"title":"SpringBoot全局异常处理","url":"/2021/03/19/SpringBoot%E5%85%A8%E5%B1%80%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/","content":"在做Web应用的时候，请求处理过程中发生错误是非常常见的情况，那我们如何才能统一且友好地返回系统异常给前台呢。\n关键在于：注解@ControllerAdvice和@ExceptionHandler\n视频参考：\n开始通过使用@ControllerAdvice修饰一个类，表示该类是Controller的全局配置类。\n在此类中，可以对Controller进行如下三种全局配置：异常处理方案：@ExceptionHandler，数据绑定方案：@ModelAttribute，绑定参数方案:@InitBinder\n本文演示@ExceptionHandler的使用\n定义统一的异常处理类，而不是在每个Controller中逐个定义。@ExceptionHandler用来定义函数针对的异常类型\n创建一个最简单Springboot项目\nController层代码:@RestController\n@RequestMapping(&quot;product/brand&quot;)\npublic class UserController &#123;\n\n    @Autowired\n    private BrandService brandService;\n\n    /**\n     * 保存\n     */\n    @RequestMapping(&quot;/save&quot;)\n    public R save(@Valid @RequestBody BrandEntity brand)&#123;\n        brandService.save(brand);//这只是一个普通的写入操作，随意实现即可\n        return R.ok();\n    &#125;\n&#125;\n\n统一结果返回枚举类/***\n * 错误码和错误信息定义类\n * 1. 错误码定义规则为5为数字\n * 2. 前两位表示业务场景，最后三位表示错误码。例如：100001。10:通用 001:系统未知异常\n * 3. 维护错误码后需要维护错误描述，将他们定义为枚举形式\n * 错误码列表：\n *  10: 通用\n *      001：参数格式校验\n *  11: 商品\n *  12: 订单\n *  13: 购物车\n *  14: 物流\n *    ...\n */\npublic enum BizCodeEnume &#123;\n    UNKNOW_EXCEPTION(10000,&quot;系统未知异常&quot;),\n    VAILD_EXCEPTION(10001,&quot;参数格式校验失败&quot;);\n\n    private int code;\n    private String msg;\n    BizCodeEnume(int code,String msg)&#123;\n        this.code = code;\n        this.msg = msg;\n    &#125;\n\n    public int getCode() &#123;\n        return code;\n    &#125;\n\n    public String getMsg() &#123;\n        return msg;\n    &#125;\n&#125;\n\n统一返回工具类/**\n * Copyright (c) 2016-2019 人人开源 All rights reserved.\n *\n * https://www.renren.io\n *\n * 版权所有，侵权必究！\n */\npublic class R extends HashMap&lt;String, Object&gt; &#123;\n    private static final long serialVersionUID = 1L;\n    \n    public R() &#123;\n        put(&quot;code&quot;, 0);\n        put(&quot;msg&quot;, &quot;success&quot;);\n    &#125;\n    \n    public static R error() &#123;\n        return error(HttpStatus.SC_INTERNAL_SERVER_ERROR, &quot;未知异常，请联系管理员&quot;);\n    &#125;\n    \n    public static R error(String msg) &#123;\n        return error(HttpStatus.SC_INTERNAL_SERVER_ERROR, msg);\n    &#125;\n    \n    public static R error(int code, String msg) &#123;\n        R r = new R();\n        r.put(&quot;code&quot;, code);\n        r.put(&quot;msg&quot;, msg);\n        return r;\n    &#125;\n\n    public static R ok(String msg) &#123;\n        R r = new R();\n        r.put(&quot;msg&quot;, msg);\n        return r;\n    &#125;\n    \n    public static R ok(Map&lt;String, Object&gt; map) &#123;\n        R r = new R();\n        r.putAll(map);\n        return r;\n    &#125;\n    \n    public static R ok() &#123;\n        return new R();\n    &#125;\n\n    public R put(String key, Object value) &#123;\n        super.put(key, value);\n        return this;\n    &#125;\n    public  Integer getCode() &#123;\n\n        return (Integer) this.get(&quot;code&quot;);\n    &#125;\n\n&#125;\n\n集中处理类通过使用@ControllerAdvice定义统一的异常处理类，而不是在每个Controller中逐个定义。@ExceptionHandler用来定义函数针对的异常类型\n/**\n * 集中处理所有异常\n */\n@Slf4j\n//@ResponseBody\n//@ControllerAdvice(basePackages = &quot;com.atguigu.gulimall.product.controller&quot;)\n@RestControllerAdvice(basePackages = &quot;com.atguigu.gulimall.product.controller&quot;)//这是上面两个注解的结合 参数为需要集中处理的包\npublic class GulimallExceptionControllerAdvice &#123;\n    \n    @ExceptionHandler(value= MethodArgumentNotValidException.class)//处理什么类型的异常\n    public R handleVaildException(MethodArgumentNotValidException e)&#123;\n        log.error(&quot;数据校验出现问题&#123;&#125;，异常类型：&#123;&#125;&quot;,e.getMessage(),e.getClass());\n        BindingResult bindingResult = e.getBindingResult();\n\n        Map&lt;String,String&gt; errorMap = new HashMap&lt;&gt;();\n        bindingResult.getFieldErrors().forEach((fieldError)-&gt;&#123;\n            errorMap.put(fieldError.getField(),fieldError.getDefaultMessage());\n        &#125;);\n        return R.error(BizCodeEnume.VAILD_EXCEPTION.getCode(),BizCodeEnume.VAILD_EXCEPTION.getMsg()).put(&quot;data&quot;,errorMap);\n    &#125;\n\n    @ExceptionHandler(value = Throwable.class)\n    public R handleException(Throwable throwable)&#123;\n\n        log.error(&quot;错误：&quot;,throwable);\n        return R.error(BizCodeEnume.UNKNOW_EXCEPTION.getCode(),BizCodeEnume.UNKNOW_EXCEPTION.getMsg());\n    &#125;\n\n\n&#125;\n\n至此，我们的功能就已经实现了，可以运行测试了。\n","categories":["SpringBoot"],"tags":["Spring","SpringBoot"]},{"title":"JAVA多线程基础","url":"/2021/03/18/JAVA%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80/","content":"线程的创建方式继承Thread类public class ThreadCreateDemo1 &#123;\n    public static void main(String[] args) &#123;\n        MyThread thread = new MyThread();\n        thread.start(); //该方法调用多次,出现IllegalThreadStateException\n    &#125;\n&#125;\n\nclass MyThread extends Thread &#123;\n    @Override\n    public void run() &#123;\n        super.run();\n        System.out.println(&quot;hellow_world!&quot;);\n    &#125;\n&#125;\n\n继承Runnable接口public class ThreadCreateDemo2 &#123;\n    public static void main(String[] args) &#123;\n        Runnable runnable = new MyRunnable();\n        new Thread(runnable).start();\n    &#125;\n&#125;\n\nclass MyRunnable implements Runnable &#123;\n    public void run() &#123;\n        System.out.println(&quot;通过Runnable创建的线程!&quot;);\n    &#125;\n&#125;\n\n 上述两种创建方式,工作时性质一样。但是建议使用实现Runable接口方式。解决单继承的局限性\n线程运行结果与执行顺序无关线程的调度是由CPU决定，CPU执行子任务时间具有不确定性。\npublic class ThreadRandomDemo1 &#123;\n    public static void main(String[] args) &#123;\n        Thread[] threads = new Thread[10];\n        for (int i = 0; i &lt; 10; i++) &#123;\n            threads[i] = new RandomThread(&quot;RandomThread:&quot; + i);\n        &#125;\n        for(Thread thread : threads) &#123;\n            thread.start();\n        &#125;\n    &#125;\n&#125;\n\nclass RandomThread extends Thread &#123;\n    \n    public RandomThread(String name) &#123;\n        super(name);\n    &#125;\n    \n    @Override\n    public void run() &#123;\n        try &#123;\n            Thread.sleep(1000);\n            System.out.println(Thread.currentThread().getName());\n        &#125; catch (InterruptedException e) &#123;\n            e.printStackTrace();\n        &#125;\n    &#125;\n&#125;\n\n以上10个线程，代码按照顺序执行，但是结果可以看出没有按照顺序执行，而且多次执行结果基本不同。\n\n线程实例变量与安全问题线程之间变量有共享与不共享之分，共享理解为大家都使用同一份，不共享理解为每个单独持有一份。\n共享数据的情况public class ThreadShareVariableDemo &#123;\n    public static void main(String[] args) &#123;\n        Runnable runnable = new ShareVariableRunnable();\n        Thread[] threads = new Thread[5];\n        for (int i = 0; i &lt; 5; i++) &#123;\n            threads[i] = new Thread(runnable, &quot;thread:&quot; + (i+1));\n        &#125;\n        for (Thread thread : threads) &#123;\n            thread.start();\n        &#125;\n    &#125;\n&#125;\n\nclass ShareVariableRunnable implements Runnable &#123;\n    private int count = 5;\n    \n    public void run() &#123;\n        System.out.println(&quot;&quot; + Thread.currentThread().getName() + &quot;,count:&quot; + count--);\n    &#125;\n&#125;\n\n\n从上图结果可以看出，count变量是共享的，不然都会打印5。但是也发现了一点thread:1 与 thread:2 打印值一样，该现象就是我们通常称为的脏数据【多线程对同一变量进行读写操作不同步产生】。\n解决方案在访问变量方法中增加synchronized关键字：\nclass ShareVariableRunnable implements Runnable &#123;\n    private int count = 5;\n    \n    public synchronized void run() &#123;\n        System.out.println(&quot;&quot; + Thread.currentThread().getName() + &quot;,count:&quot; + count--);\n    &#125;\n&#125;\n\n\n如图每次打印count都是正常递减，这里解释一下synchronized关键字，含有synchronized关键字的这个方法称为“互斥区” 或“临界区”，只有获得这个关键字对应的锁才能执行方法体，方法体执行完自动会释放锁。\n停止线程终止正在运行的线程方法有三种：  1. 使用退出标志,使线程正常的执行完run方法终止  2. 使用interrupt方法,使线程异常，线程进行捕获或抛异常，正常执行完run方法终止       3. 使用stop方法强制退出\n这里主要说明前两种方法；\n\n使用退出标志位\npublic class ThreadVariableStopDemo &#123;\n    public static void main(String[] args) throws InterruptedException &#123;\n        VariableStopThread thread = new VariableStopThread(&quot;thread_1&quot;);\n        thread.start();\n        Thread.sleep(1);\n        thread.Stop();\n    &#125;\n&#125;\n\nclass VariableStopThread extends Thread &#123;\n    private boolean interrupt = true;\n    \n    public VariableStopThread(String name) &#123;\n        super(name);\n    &#125;\n    \n    public void run() &#123;\n        System.out.println(Thread.currentThread().getName() + &quot;:线程开始运行!&quot;);\n        int i = 0;\n        while(interrupt) &#123;\n            System.out.println(&quot;&quot; + (i++));\n        &#125;\n        System.out.println(&quot;我停止了! timer:&quot; + System.currentTimeMillis());\n    &#125;\n    \n    public void Stop() &#123;\n        System.out.println(Thread.currentThread().getName() + &quot;:线程设置了停止! timer:&quot; + System.currentTimeMillis());\n        this.interrupt = false;\n    &#125;\n&#125;\n\n\n\n使用interrupt方法\npublic class ThreadInterruptDemo &#123;\n    public static void main(String[] args) throws InterruptedException &#123;\n        Thread thread = new InterruptThread(&quot;thread_1&quot;);\n        thread.start();\n        Thread.sleep(1);\n        System.out.println(thread.getName() + &quot;线程设置:interrupt&quot;);\n        thread.interrupt();\n    &#125;\n&#125;\n\nclass InterruptThread extends Thread &#123;\n    \n    public InterruptThread(String name) &#123;\n        super(name);\n    &#125;\n    \n    @Override\n    public void run() &#123;\n        System.out.println(Thread.currentThread().getName() + &quot;线程开始!&quot;);\n        for(int i =0; i &lt; 1000; i++) &#123;\n            try &#123;\n                Thread.sleep(0);\n                System.out.println(&quot;&quot; + (i + 1));\n            &#125; catch (InterruptedException e) &#123;\n                System.out.println(Thread.currentThread().getName() + &quot;线程捕获异常,退出循环!&quot;);\n                break;\n            &#125;\n        &#125;\n        System.out.println(Thread.currentThread().getName() + &quot;线程结束!&quot;);\n    &#125;\n&#125;\n\n\n\n\n线程优先级线程优先级范围为1-10，API提供等级分为：低（MIN_PRIORITY = 1)，中（NORM_PRIORITY=5），高（MAX_PRIORITY=10）。 线程优先级有以下特点：\n\n继承特性【线程A中启动线程B，线程B继承了A的优先级】\n\n随机性【线程调度的顺序不一定是根据优先级，具有随机性】\npublic class ThreadPriorityDemo &#123;\n    public static void main(String[] args) &#123;\n        Thread thread = new ThreadPriority(&quot;thread_1&lt;&lt;&lt;&lt;&quot;);\n        Thread thread_1 = new ThreadPriority(&quot;&gt;&gt;&gt;thread_2&quot;);\n        thread_1.setPriority(Thread.MIN_PRIORITY); //&lt;设置线程优先级\n        thread.setPriority(Thread.MAX_PRIORITY);\n        thread_1.start();\n        thread.start();\n    &#125;\n&#125;\n\nclass ThreadPriority extends Thread &#123;\n    public ThreadPriority(String name) &#123;\n        super(name);\n    &#125;\n    \n    @Override\n    public void run() &#123;\n        for (int i = 0; i &lt; 10; i++) &#123;\n            System.out.println(&quot;&quot; + Thread.currentThread().getName() + &quot;,number:&quot; + i + &quot;,Priority:&quot; + Thread.currentThread().getPriority());\n        &#125;\n    &#125;\n&#125;\n\n\n\n\n守护线程守护线程顾名思义是一个线程守护另一个线程【此线程为非守护线程】，故守护的线程称为守护线程，被守护的线程称为非守护线程。作用是为其他线程运行提供便利服务。\npublic class DaemonThreadDemo &#123;\n    public static void main(String[] args) throws InterruptedException &#123;\n        Thread thread = new DaemonThread();\n        thread.setDaemon(true);//设置线程为守护线程\n        thread.start();\n        System.out.println(&quot;&quot; + Thread.currentThread().getName() + &quot;停止运行!&quot; );\n    &#125;\n&#125;\n\nclass DaemonThread extends Thread &#123;\n    @Override\n    public void run() &#123;\n        while (true) &#123;\n            System.out.println(&quot;DaemonThread 正在运行!&quot;);\n        &#125;\n    &#125;\n&#125;\n\n\n从上图可以看出，主线程停止DaemonThread线程也相应的停止了，但不是立即停止。\n线程让步线程让步yield()让当前线程释放CPU资源，让其他线程抢占。\npublic class ThreadYieldDemo &#123;\n    public static void main(String[] args) &#123;\n        Thread thread = new ThreadYield();\n        thread.start();\n    &#125;\n&#125;\nclass ThreadYield extends Thread &#123;\n    @Override\n    public void run() &#123;\n        long time_start = System.currentTimeMillis();\n        for(int i = 0; i &lt; 500000; i++) &#123;\n            Thread.yield();\n        &#125;\n        long time_end = System.currentTimeMillis();\n        System.out.println(&quot;用时：&quot; + (time_end - time_start));\n    &#125;\n&#125;\n\n","categories":["Java"],"tags":[]},{"title":"理解JVM","url":"/2021/03/16/%E7%90%86%E8%A7%A3JVM/","content":"JVM 是 Java Virtual Machine 的缩写，它是一个虚构出来的计算机，类似于小电脑运行在 Windows 或 Linux 这些系统上，它与系统直接交互，但不与硬件直接交互。\n\nJava 文件是如何被运行的一个.java 文件需要被编译成.class 文件，在将其装进一个类加载器中，它就像搬运工，把所有.class 文件搬进 JVM 中，JVM 简易结构如下：\n\n\nJVM模型架构Java编译器输入的指令流基本上是一种基于栈的指令集架构，另外一种指令集架构则是基于寄存器的指令集架构\n基于栈式架构的特点\n\n设计和实现更简单，适用于资源受限的系统\n\n避开了寄存器的分配难题：使用零地址指令方式分配\n\n指令流中的指令大部分是零地址指令，其执行过程依赖于操作栈。指令集更小，编译器容易实现\n\n不需要硬件支持，可移植性更好，更好实现跨平台\n\n\n基于寄存器架构的特点\n\n典型的应用是x86的二进制指令集：比如传统的PC以及Android的Davlik虚拟机\n\n指令集架构则完全依赖硬件，可移植性差\n\n性能优秀和执行更高效\n\n花费更少的指令去完成一项操作\n\n在大部分情况下，基于寄存器架构的指令集往往都以一地址指令、二地址指令和三地址指令为主，而基于栈式架构的指令集却是以零地址指令为主\n\n\n总结由于跨平台性的设计，Java的指令都是根据栈来设计的。不同平台CPU架构不同，所以不能设计为基于寄存器的。优点是跨平台，指令集小，编译器容易实现，缺点是性能下降，实现同样的功能需要更多的指令。\n时至今日，尽管嵌入式平台已经不是Java程序的主流运行平台了（准确来说应该是HotSpotVM的宿主环境已经不局限于嵌入式平台了），那么为什么不将架构更换为基于寄存器的架构呢？答：已经够用了\n栈：跨平台性、指令集小、指令多：执行性能比寄存器差\nJVM生命周期虚拟机的启动\nJava虚拟机的启动是通过引导类加载器（bootstrap class loader）创建一个初始类（initial class）来完成的，这个类是由虚拟机的具体实现指定的。\n虚拟机的执行\n\n一个运行中的Java虚拟机有着一个清晰的任务：执行Java程序。\n\n程序开始执行时他才运行，程序结束时他就停止。\n\n执行一个所谓的Java程序的时候，真真正正在执行的是一个叫做Java虚拟机的进程。\n\n\n虚拟机的退出\n有如下的几种情况：\n\n程序正常执行结束\n\n程序在执行过程中遇到了异常或错误而异常终止\n\n由于操作系统用现错误而导致Java虚拟机进程终止\n\n某线程调用Runtime类或system类的exit方法，或Runtime类的halt方法，并且Java安全管理器也允许这次exit或halt操作。\n\n\n除此之外，JNI（Java Native Interface）规范描述了用JNI Invocation API来加载或卸载 Java虚拟机时，Java虚拟机的退出情况。\n类加载器\n\n类加载器只负责class文件的加载，至于它是否可以运行，则由Execution Engine（执行引擎）决定。\n加载的类信息存放于一块称为方法区的内存空间。除了类的信息外，方法区中还会存放运行时常量池信息，可能还包括字符串字面量和数字常量（这部分常量信息是Class文件中常量池部分的内存映射）\n说白了，类加载器会把类的详细详细加载到JVM中\n类加载的过程加载阶段\n通过一个类的全限定名获取定义此类的二进制字节流\n\n将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构\n\n在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口\n\n\n补充：加载class文件的方式\n\n从本地系统中直接加载\n\n通过网络获取，典型场景：Web Applet\n\n从zip压缩包中读取，成为日后jar、war格式的基础\n\n运行时计算生成，使用最多的是：动态代理技术\n\n由其他文件生成，典型场景：JSP应用\n\n从专有数据库中提取.class文件，比较少见\n\n从加密文件中获取，典型的防Class文件被反编译的保护措施\n\n\n链接阶段\n验证（Verify）\n\n判断Class文件的字节流是否符合当前虚拟机的规范，保证类的正确性\n\n主要有四种方式：文件格式验证、元数据验证、字节码验证、符号引用验证。\n去查看Class文件的二进制字节码时，你会发现开头几个都是CA FE BA BE这就是一个验证\n\n\n\n准备（Prepare）\n\n会为类中的变量分配内存，并设置初始值，即为0\n不包含用final修饰的static变量，因为final在编译时就分配了，准备阶段会显示初始化\n不会为实例变量初始化，因为实例变量是在对象实例化时随着对象一起分配在java堆中的\n\n\n解析（Resolve）\n\n将常量池内的符号引用转换为直接引用的过程。\n\n事实上，解析操作往往会伴随着JVM在执行完初始化之后再执行。\n\n符号引用就是一组符号来描述所引用的目标。符号引用的字面量形式明确定义在《java虚拟机规范》的Class文件格式中。直接引用就是直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄。\n\n解析动作主要针对类或接口、字段、类方法、接口方法、方法类型等。对应常量池中的CONSTANT_Class_info，CONSTANT_Fieldref_info、CONSTANT_Methodref_info等。\n\n\n\n\n初始化阶段\n初始化阶段就是执行类构造器方法()的过程。此方法不需定义，是javac编译器自动收集类中的所有类变量的赋值动作和静态代码块中的语句合并而来，构造器方法中指令按语句在源文件中出现的顺序执行。ps:方法只在拥有静态变量或静态代码块时才有\n\n()不同于类的构造器（构造方法）。（关联：构造器是虚拟机视角下的()）\n\n若该类具有父类，JVM会保证子类的()执行前，父类的()已经执行完毕。\n\n虚拟机必须保证一个类的()方法在多线程下被同步加锁。(说白了，如果在中如果有死循环之类的，会卡住，多个线程new这个对象的话无法正常运行)\n\n\n类加载器的加载顺序 从下往上\nBootStrap ClassLoader（引导类加载器）：rt.jar\nExtention ClassLoader（扩展类加载器）: 加载扩展的 jar 包\nApp ClassLoader（系统类加载器）：指定的 classpath 下面的 jar 包\nCustom ClassLoader：自定义的类加载器\n\n引导类加载器\n这个类加载使用**C/C++**语言实现的，嵌套在JVM内部。\n\n它用来加载Java的核心库（JAVA_HOME/jre/lib/rt.jar、resources.jar或sun.boot.class.path路径下的内容），用于提供JVM自身需要的类\n\n并不继承自ava.lang.ClassLoader，没有父加载器。\n\n加载扩展类和应用程序类加载器，并指定为他们的父类加载器。\n\n出于安全考虑，Bootstrap启动类加载器只加载包名为java、javax、sun等开头的类\n\n\n扩展类加载器\nJava语言编写，由sun.misc.Launcher$ExtClassLoader实现。\n\n派生于ClassLoader类\n\n父类加载器为启动类加载器（这不是继承，是指它由引导类加载器加载）\n\n从java.ext.dirs系统属性所指定的目录中加载类库，或从JDK的安装目录的jre/lib/ext子目录（扩展目录）下加载类库。如果用户创建的JAR放在此目录下，也会自动由扩展类加载器加载。\n\n\n系统类加载器\njava语言编写，由sun.misc.LaunchersAppClassLoader实现\n\n派生于ClassLoader类\n\n父类加载器为扩展类加载器（这不是继承，是指它由引导类加载器加载）\n\n它负责加载环境变量classpath或系统属性java.class.path指定路径下的类库\n\n该类加载是程序中默认的类加载器，一般来说，Java应用的类都是由它来完成加载\n\n通过ClassLoader.getSystemclassLoader() 方法可以获取到该类加载器\n\n\n自定义类加载器在Java的日常应用程序开发中，类的加载几乎是由上述3种类加载器相互配合执行的，在必要时，我们还可以自定义类加载器，来定制类的加载方式。 为什么要自定义类加载器？\n\n隔离加载类\n\n修改类加载的方式\n\n扩展加载源\n\n防止源码泄漏\n\n\n用户自定义类加载器实现步骤：\n\n开发人员可以通过继承抽象类ava.lang.ClassLoader类的方式，实现自己的类加载器，以满足一些特殊的需求\n\n在JDK1.2之前，在自定义类加载器时，总会去继承ClassLoader类并重写loadClass() 方法，从而实现自定义的类加载类，但是在JDK1.2之后已不再建议用户去覆盖loadclass() 方法，而是建议把自定义的类加载逻辑写在findClass()方法中\n\n在编写自定义类加载器时，如果没有太过于复杂的需求，可以直接继承URLClassLoader类，这样就可以避免自己去编写findClass()  方法及其获取字节码流的方式，使自定义类加载器编写更加简洁。\n\n\n一般情况下了解一下就行了\n双亲委派机制Java虚拟机对class文件采用的是按需加载的方式，也就是说当需要使用该类时才会将它的class文件加载到内存生成class对象。而且加载某个类的class文件时，Java虚拟机采用的是双亲委派模式，即把请求交由父类处理，它是一种任务委派模式\n工作原理\n\n如果一个类加载器收到了类加载请求，它并不会自己先去加载，而是把这个请求委托给父类的加载器去执行；\n\n如果父类加载器还存在其父类加载器，则进一步向上委托，依次递归，请求最终将到达顶层的启动类加载器；\n\n如果父类加载器可以完成类加载任务，就成功返回，倘若父类加载器无法完成此加载任务，子加载器才会尝试自己去加载，这就是双亲委派模式。\n\n\n\n优势\n\n避免类的重复加载\n保护程序安全，防止核心API被随意篡改\n自定义类：java.lang.String\n自定义类：java.lang.ShkStart（报错：阻止创建 java.lang开头的类）\n\n\n\n沙箱安全机制自定义String类，但是在加载自定义String类的时候会率先使用引导类加载器加载，而引导类加载器在加载的过程中会先加载jdk自带的文件（rt.jar包中java\\lang\\String.class），报错信息说没有main方法，就是因为加载的是rt.jar包中的string类。这样可以保证对java核心源代码的保护，这就是沙箱安全机制。\nJava 安全模型的核心就是 Java 沙箱，什么是沙箱？沙箱是一个限制程序运行的环境。沙箱机制就是将 Java 代码限定在虚拟机(JVM)特定的运行范围中，并严格限制代码对本地系统资源的访问，通过这样的措施来保证对代码的隔离，防止对本地系统造成破坏。沙箱主要限制系统资源访问，那系统资源包括什么？——CPU、内存、文件系统、网络。不同级别的沙箱对这些资源访问的限制也可以不一样。详情点击\nJVM运行时数据区我们通过磁盘或者网络IO得到的数据，都需要先加载到内存中，然后CPU从内存中获取数据进行读取，也就是说内存充当了CPU和磁盘之间的桥梁\n\n每个线程：独立包括程序计数器、栈、本地方法栈。\n线程间共享（进程）：堆、堆外内存（永久代或元空间、代码缓存）\n\n线程线程是一个程序里的运行单元。JVM允许一个应用有多个线程并行的执行。 在Hotspot JVM里，每个线程都与操作系统的本地线程直接映射。\n当一个Java线程准备好执行以后，此时一个操作系统的本地线程也同时创建。Java线程执行终止后，本地线程也    会回收。\n操作系统负责所有线程的安排调度到任何一个可用的CPU上。一旦本地线程初始化成功，它就会调用Java线程中的run()方法。\n如果你使用console或者是任何一个调试工具，都能看到在后台有许多线程在运行。这些后台线程不包括调用public static void main(String[] args)的main线程以及所有这个main线程自己创建的线程。\n这些主要的后台系统线程在Hotspot JVM里主要是以下几个：\n\n虚拟机线程：这种线程的操作是需要JVM达到安全点才会出现。这些操作必须在不同的线程中发生的原因是他们都需要JVM达到安全点，这样堆才不会变化。这种线程的执行类型包括”stop-the-world”的垃圾收集，线程栈收集，线程挂起以及偏向锁撤销。\n\n周期任务线程：这种线程是时间周期事件的体现（比如中断），他们一般用于周期性操作的调度执行。\n\nGC线程：这种线程对在JVM里不同种类的垃圾收集行为提供了支持。\n\n编译线程：这种线程在运行时会将字节码编译成到本地代码。\n\n信号调度线程：这种线程接收信号并发送给JVM，在它内部通过调用适当的方法进行处理\n\n\n程序计数器程序计数器：Program counter register\n也可以叫PC寄存器\n每个线程都有一个程序计数器，是线程私有的，就是一直指针，指向下一条指令的地址（指令地址/偏移地址），也就是即将执行的指令，在执行引擎读取下一条指令，是一个非常小的内存空间，几乎可以忽略不记。也是运行速度最快的存储区域。\n任何时间一个线程都只有一个方法在执行，也就是所谓的当前方法。程序计数器会存储当前线程正在执行的Java方法的JVM指令地址；或者，如果是在执行native方法，则是未指定值（undefined）。\n它是程序控制流的指示器，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。\n字节码解释器工时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令。\n它是唯一一个在Java虚拟机规范中没有规定任何OutofMemoryError情况的区域。\n常见面试问题使用PC寄存器储存字节码指令地址有什么用？\n为什么使用PC寄存器记录当前线程的执行地址？\n因为CPU需要不停的切换各个线程，这时候切换回来以后，就得知道接着从哪开始继续执行。\nJVM的字节码解释器就需要通过改变PC寄存器的值来明确下一条应该执行什么样的字节码指令。\n\nPC寄存器为什么被设置为线程私有的？\n我们都知道所谓的多线程在一个特定的时间段内只会执行其中某一个线程的方法，CPU会不停地做任务切换，这样必然导致经常中断或恢复，如何保证分毫无差呢？为了能够准确地记录各个线程正在执行的当前字节码指令地址，最好的办法自然是为每一个线程都分配一个PC寄存器，这样一来各个线程之间便可以进行独立计算，从而不会出现相互干扰的情况。\n由于CPU时间片轮限制，众多线程在并发执行过程中，任何一个确定的时刻，一个处理器或者多核处理器中的一个内核，只会执行某个线程中的一条指令。\n这样必然导致经常中断或恢复，如何保证分毫无差呢？每个线程在创建后，都会产生自己的程序计数器和栈帧，程序计数器在各个线程之间互不影响。\nJAVA栈由于跨平台性的设计，Java的指令都是根据栈来设计的，不同平台CPU架构不同，所以不能设计为基于寄存器。\n优点：跨平台、指令集小、编译器容易实现\n缺点：性能下降、实现同样的功能需要更多指令\n栈是运行时的单位，而堆是存储的单位\n\n栈解决程序的运行问题，即程序如何执行，或者说如何处理数据。\n\n堆解决的是数据存储的问题，即数据怎么放，放哪里\n\n\n每个线程都会创建一个Java栈，其内部保存一个个栈帧，对应着一次次Java方法的调用\n线程创建的时候会创建，生命周期和线程生命周期一样，线程结束栈也就释放了，描述的是 Java 方法执行的内存模型：每个方法在执行时都会创建一个栈帧(Stack Frame)用于存储局部变量表、操作数栈、动态链接、方法出口等信息。每一个方法从调用直至执行结束，就对应着一个栈帧从虚拟机栈中入栈到出栈的过程。\n主管Java程序的运行，它保存方法的局部变量、部分结果，并参与方法的调用和返回。\nJVM对Java栈只有进栈和出栈两个操作，不存在垃圾回收\n对于栈来说不存在垃圾回收问题（栈存在溢出的情况）\n栈中可能出现的异常\nJava 虚拟机规范允许Java栈的大小是动态的或者是固定不变的。\n\n如果采用固定大小的Java虚拟机栈，那每一个线程的Java虚拟机栈容量可以在线程创建的时候独立选定。如果线程请求分配的栈容量超过Java虚拟机栈允许的最大容量，Java虚拟机将会抛出一个StackOverflowError 异常。\n\n如果Java虚拟机栈可以动态扩展，并且在尝试扩展的时候无法申请到足够的内存，或者在创建新的线程时没有足够的内存去创建对应的虚拟机栈，那Java虚拟机将会抛出一个 OutOfMemoryError 异常。\n\n\n设置栈内存大小\n我们可以使用参数 -Xss选项来设置线程的最大栈空间，栈的大小直接决定了函数调用的最大可达深度\nJava方法有两种返回函数的方式，一种是正常的函数返回，使用return指令；另外一种是抛出异常。不管使用哪种方式，都会导致栈帧被弹出。\n栈帧的内部结构每个栈帧中存储着：\n\n局部变量表（Local Variables）\n\n操作数栈（operand Stack）（或表达式栈）\n\n动态链接（DynamicLinking）（或指向运行时常量池的方法引用）\n\n方法返回地址（Return Address）（或方法正常退出或者异常退出的定义）\n\n一些附加信息\n\n\n\n\n局部变量表(Local Variables)局部变量表也被称之为局部变量数组或本地变量表\n\n定义为一个数字数组，主要用于存储方法参数和定义在方法体内的局部变量，这些数据类型包括各类基本数据类型、对象引用（reference），以及returnAddress类型。\n\n由于局部变量表是建立在线程的栈上，是线程的私有数据，因此不存在数据安全问题\n\n局部变量表所需的容量大小是在编译期确定下来的，并保存在方法的Code属性的maximum local variables数据项中。在方法运行期间是不会改变局部变量表的大小的。\n\n方法嵌套调用的次数由栈的大小决定。一般来说，栈越大，方法嵌套调用次数越多。对一个函数而言，它的参数和局部变量越多，使得局部变量表膨胀，它的栈帧就越大，以满足方法调用所需传递的信息增大的需求。进而函数调用就会占用更多的栈空间，导致其嵌套调用次数就会减少。\n\n局部变量表中的变量只在当前方法调用中有效。在方法执行时，虚拟机通过使用局部变量表完成参数值到参数变量列表的传递过程。当方法调用结束后，随着方法栈帧的销毁，局部变量表也会随之销毁。\n\n\n关于Solt的理解\n\n在局部变量表中最基本的存储单元是Slot（变量槽）\n\n参数值的存放总是在局部变量数组的index0开始，到数组长度-1的索引结束。\n\n局部变量表中存放编译期可知的各种基本数据类型（8种），引用类型（reference），returnAddress类型的变量。\n\n在局部变量表里，32位以内的类型只占用一个slot（包括returnAddress类型），64位的类型（long和double）占用两个slot。\n\nbyte、short、char 在存储前被转换为int，boolean也被转换为int，0表示false，非0表示true。\nlong和double则占据两个solt\n\n\nJVM会为局部变量表中的每一个Slot都分配一个访问索引，通过这个索引即可成功访问到局部变量表中指定的局部变量值\n\n当一个实例方法被调用的时候，它的方法参数和方法体内部定义的局部变量将会按照顺序被复制到局部变量表中的每一个slot上\n\n如果需要访问局部变量表中一个64bit的局部变量值时，只需要使用前一个索引即可。（比如：访问long或doub1e类型变量）\n\n如果当前帧是由构造方法或者实例方法创建的，那么该对象引用this将会存放在index为0的slot处，其余的参数按照参数表顺序继续排列。\n\n\n\n\n在栈帧中，与性能调优关系最为密切的部分就是前面提到的局部变量表。在方法执行时，虚拟机使用局部变量表完成方法的传递。\n局部变量表中的变量也是重要的垃圾回收根节点，只要被局部变量表中直接或间接引用的对象都不会被回收。\n操作数栈(Operand Stack)每一个独立的栈帧除了包含局部变量表以外，还包含一个后进先出（Last-In-First-Out）的操作数栈，也可以称之为表达式栈（Expression Stack）\n操作数栈，在方法执行过程中，根据字节码指令，往栈中写入数据或提取数据，即入栈（push）和 出栈（pop）\n\n某些字节码指令将值压入操作数栈，其余的字节码指令将操作数取出栈。使用它们后再把结果压入栈\n\n比如：执行复制、交换、求和等操作\n\n\n\n操作数栈，主要用于保存计算过程的中间结果，同时作为计算过程中变量临时的存储空间。\n操作数栈就是JVM执行引擎的一个工作区，当一个方法刚开始执行的时候，一个新的栈帧也会随之被创建出来，这个方法的操作数栈是空的。\n每一操作数栈都会拥有一个明确的栈深度用于存储数值，其所需的最大深度在编译期就定义好了，保存在方法的Code属性中，为max_stack的值。\n栈中的任何一个元素都是可以任意的Java数据类型\n\n32bit的类型占用一个栈单位深度\n\n64bit的类型占用两个栈单位深度\n\n\n操作数栈并非采用访问索引的方式来进行数据访问的(虽然操作数栈是通过数组实现的)，而是只能通过标准的入栈和出栈操作来完成一次数据访问\n如果被调用的方法带有返回值的话，其返回值将会被压入当前栈帧的操作数栈中，并更新PC寄存器中下一条需要执行的字节码指令。\n操作数栈中元素的数据类型必须与字节码指令的序列严格匹配，这由编译器在编译器期间进行验证，同时在类加载过程中的类检验阶段的数据流分析阶段要再次验证。\n另外，我们说Java虚拟机的解释引擎是基于栈的执行引擎，其中的栈指的就是操作数栈。\n详情图文\n动态链接(DynamicLinking)动态链接、方法返回地址、附加信息 ： 有些地方被称为帧数据区\n每一个栈帧内部都包含一个指向运行时常量池中该栈帧所属方法的引用。包含这个引用的目的就是为了支持当前方法的代码能够实现动态链接（Dynamic Linking）。比如：invokedynamic指令\n在Java源文件被编译到字节码文件中时，所有的变量和方法引用都作为符号引用（Symbolic Reference）保存在class文件的常量池里。比如：描述一个方法调用了另外的其他方法时，就是通过常量池中指向方法的符号引用来表示的，那么动态链接的作用就是为了将这些符号引用转换为调用方法的直接引用。\n\n\n为什么需要运行时常量池呢？\n常量池的作用：就是为了提供一些符号和常量，便于指令的识别\n方法返回地址(Return Address)存放调用该方法的pc寄存器的值。一个方法的结束，有两种方式：\n\n正常执行完成\n\n出现未处理的异常，非正常退出\n\n\n无论通过哪种方式退出，在方法退出后都返回到该方法被调用的位置。方法正常退出时，调用者的pc计数器的值作为返回地址，即调用该方法的指令的下一条指令的地址。而通过异常退出的，返回地址是要通过异常表来确定，栈帧中一般不会保存这部分信息。\n当一个方法开始执行后，只有两种方式可以退出这个方法：\n\n执行引擎遇到任意一个方法返回的字节码指令（return），会有返回值传递给上层的方法调用者，简称正常完成出口；\n\n\n\n一个方法在正常调用完成之后，究竟需要使用哪一个返回指令，还需要根据方法返回值的实际数据类型而定。\n\n\n\n在字节码指令中，返回指令包含ireturn（当返回值是boolean，byte，char，short和int类型时使用），lreturn（Long类型），freturn（Float类型），dreturn（Double类型），areturn。另外还有一个return指令声明为void的方法，实例初始化方法，类和接口的初始化方法使用\n\n\n\n\n在方法执行过程中遇到异常（Exception），并且这个异常没有在方法内进行处理，也就是只要在本方法的异常表中没有搜索到匹配的异常处理器，就会导致方法退出，简称异常完成出口。\n\n方法执行过程中，抛出异常时的异常处理，存储在一个异常处理表，方便在发生异常的时候找到处理异常的代码\nException table:\nfrom to target type\n4    16   19   any\n19   21   19   any\n\n本质上，方法的退出就是当前栈帧出栈的过程。此时，需要恢复上层方法的局部变量表、操作数栈、将返回值压入调用者栈帧的操作数栈、设置PC寄存器值等，让调用者方法继续执行下去。\n正常完成出口和异常完成出口的区别在于：通过异常完成出口退出的不会给他的上层调用者产生任何的返回值。\n一些附加信息栈帧中还允许携带与Java虚拟机实现相关的一些附加信息。例如：对程序调试提供支持的信息。\n栈面试题\n举例栈溢出的情况？（StackOverflowError）-&gt;方法调用过多，堆满了栈空间\n\n\n通过 -Xss设置栈的大小\n\n\n调整栈大小，就能保证不出现溢出么？\n\n\n不能保证不溢出\n\n\n分配的栈内存越大越好么？\n\n\n不是，一定时间内降低了OOM概率，但是会挤占其它的线程空间，因为整个空间是有限的。\n\n\n垃圾回收是否涉及到虚拟机栈？\n\n\n不会\n\n\n方法中定义的局部变量是否线程安全？-&gt;看实际情况\n\n\n具体问题具体分析。如果对象是在内部产生，并在内部消亡，没有返回到外部，那么它就是线程安全的，反之则是线程不安全的。\n\n\n\n\n\n\n运行时数据区\n是否存在Error\n是否存在GC\n\n\n\n程序计数器\n否\n否\n\n\n虚拟机栈\n是（SOE）\n否\n\n\n本地方法栈\n是\n否\n\n\n方法区\n是（OOM）\n是\n\n\n堆\n是\n是\n\n\n本地方法接口本地方法本地接口 简称 JNI：Java Native Interface\n简单地讲，一个Native Method是一个Java调用非Java代码的接囗。一个Native Method是这样一个Java方法：该方法的实现由非Java语言实现，比如C。这个特征并非Java所特有，很多其它的编程语言都有这一机制，比如在C中，你可以用extern “c” 告知c编译器去调用一个c的函数。\n\nA native method is a Java method whose implementation is provided by non-java code.\n\n在定义一个native method时，并不提供实现体（有些像定义一个Java interface），因为其实现体是由非java语言在外面实现的。\n本地接口的作用是融合不同的编程语言为Java所用，它的初衷是融合C/C++程序。\n举例\npublic class IHaveNatives&#123;\n    public native void methodNative1(int x);\n    public native static long methodNative2();\n    private native synchronized float methodNative3(Object o);\n    native void methodNative4(int[] ary) throws Exception;\n&#125;\n\n标识符native可以与其它java标识符连用，但是abstract除外\n为什么使用Native Method？\nJava使用起来非常方便，然而有些层次的任务用Java实现起来不容易，或者我们对程序的效率很在意时，问题就来了。\n与Java环境的交互\n有时Java应用需要与Java外面的环境交互，这是本地方法存在的主要原因。你可以想想Java需要与一些底层系统，如操作系统或某些硬件交换信息时的情况。本地方法正是这样一种交流机制：它为我们提供了一个非常简洁的接口，而且我们无需去了解Java应用之外的繁琐的细节。\n与操作系统的交互\nJVM支持着Java语言本身和运行时库，它是Java程序赖以生存的平台，它由一个解释器（解释字节码）和一些连接到本地代码的库组成。然而不管怎样，它毕竟不是一个完整的系统，它经常依赖于一底层系统的支持。这些底层系统常常是强大的操作系统。通过使用本地方法，我们得以用Java实现了jre的与底层系统的交互，甚至JVM的一些部分就是用c写的。还有，如果我们要使用一些Java语言本身没有提供封装的操作系统的特性时，我们也需要使用本地方法。\nSun’s Java\nSun的解释器是用C实现的，这使得它能像一些普通的C一样与外部交互。jre大部分是用Java实现的，它也通过一些本地方法与外界交互。例如：类java.lang.Thread的setPriority()方法是用Java实现的，但是它实现调用的是该类里的本地方法setPriority()。这个本地方法是用C实现的，并被植入JVM内部，在Windows 95的平台上，这个本地方法最终将调用Win32 setPriority() ApI。这是一个本地方法的具体实现由JVM直接提供，更多的情况是本地方法由外部的动态链接库（external dynamic link library）提供，然后被JVw调用。\n现状\n目前该方法使用的越来越少了，除非是与硬件有关的应用，比如通过Java程序驱动打印机或者Java系统管理生产设备，在企业级应用中已经比较少见。因为现在的异构领域间的通信很发达，比如可以使用Socket通信，也可以使用Web Service等等，不多做介绍。\n本地方法栈Java虚拟机栈于管理Java方法的调用，而本地方法栈用于管理本地方法的调用。\n本地方法栈，也是线程私有的。\n允许被实现成固定或者是可动态扩展的内存大小。（在内存溢出方面是相同的）\n\n如果线程请求分配的栈容量超过本地方法栈允许的最大容量，Java虚拟机将会抛出一个StackOverflowError 异常。\n\n如果本地方法栈可以动态扩展，并且在尝试扩展的时候无法申请到足够的内存，或者在创建新的线程时没有足够的内存去创建对应的本地方法栈，那么Java虚拟机将会抛出一个OutOfMemoryError异常。\n\n\n本地方法是使用C语言实现的。\n它的具体做法是Native Method Stack中登记native方法，在Execution Engine 执行时加载本地方法库。\n\n\n当某个线程调用一个本地方法时，它就进入了一个全新的并且不再受虚拟机限制的世界。它和虚拟机拥有同样的权限。\n\n本地方法可以通过本地方法接口来访问虚拟机内部的运行时数据区。\n\n它甚至可以直接使用本地处理器中的寄存器\n\n直接从本地内存的堆中分配任意数量的内存。\n\n\n并不是所有的JVM都支持本地方法。因为Java虚拟机规范并没有明确要求本地方法栈的使用语言、具体实现方式、数据结构等。如果JVM产品不打算支持native方法，也可以无需实现本地方法栈。\n在Hotspot JVM中，直接将本地方法栈和虚拟机栈合二为一。\n堆Heap，一个 JVM 只有一个堆内存，堆内存的大小是可以调节的。\nJava虚拟机用来存储对象实例用的，在我们开发中，只要通过new创建的对象都分配在堆中，注意堆中的对象内存需要等待GC回收，也是Java虚拟机线程共享区域，内部会划分出多个线程私有的分配缓冲区（Thread Local Allocation Buffer，TLAB）。\n类加载器读取了类文件后，一般会把 类、方法、常量、变量、保存我们所有引用类型的真实对象\n堆内存中还要细分为三个区域：\n\n新生区（伊甸园区）\n养老区\n元空间/永久区\n\n\nGC 垃圾回收，主要是在伊甸园和养老区\n假设内存满了，OOM，堆内存不够\nJDK 8 中永久区向元空间的转换的原因：\n\n1、字符串存在永久代中，容易出现性能问题和内存溢出。\n2、类及方法的信息等比较难确定其大小，因此对于永久代的大小指定比较困难，太小容易出现永久代溢出，太大则容易导致老年代溢出。\n3、永久代会为 GC 带来不必要的复杂度，并且回收效率偏低。\n4、Oracle 可能会将 HotSpot 与 JRockit 合二为一。\n\n设置堆空间大小Java堆区用于存储Java对象实例，那么堆的大小在JVM启动时就已经设定好了，大家可以通过选项”-Xmx”和”-Xms”来进行设置。\n\n“-Xms”用于表示堆区的起始内存，等价于-XX:InitialHeapSize\n\n-X 是jvm的运行参数\nms 是memory start\n\n\n“-Xmx”则用于表示堆区的最大内存，等价于-XX:MaxHeapSize\n\n\n一旦堆区中的内存大小超过“-Xmx”所指定的最大内存时，将会抛出OutOfMemoryError异常。\n通常会将-Xms和-Xmx两个参数配置相同的值，其目的是为了能够在ava垃圾回收机制清理完堆区后不需要重新分隔计算堆区的大小，从而提高性能。\n默认情况下\n\n初始内存大小：物理电脑内存大小 / 64\n\n最大内存大小：物理电脑内存大小 / 4\n\n\n\n存储在JVM中的Java对象可以被划分为两类：\n\n一类是生命周期较短的瞬时对象，这类对象的创建和消亡都非常迅速\n\n另外一类对象的生命周期却非常长，在某些极端的情况下还能够与JVM的生命周期保持一致\n\n\nJava堆区进一步细分的话，可以划分为年轻代（YoungGen）和老年代（oldGen）\n其中年轻代又可以划分为Eden空间、Survivor0空间和Survivor1空间（有时也叫做from区、to区）\n\n配置新生代与老年代在堆结构的占比。\n\n默认-XX:NewRatio=2，表示新生代占1，老年代占2，新生代占整个堆的1/3\n\n可以修改-XX:NewRatio=4，表示新生代占1，老年代占4，新生代占整个堆的1/5\n\n\n在HotSpot中，Eden空间和另外两个survivor空间所占的比例是8：1：1\n但是实际情况下，不会严格按照8：1：1进行分配，它会有一个自适应的过程\n当然开发人员可以通过选项-xx:SurvivorRatio调整这个空间比例。比如-xx:SurvivorRatio=8，这样调整的话就会严格执行8：1：1\n几乎所有的Java对象都是在Eden区被new出来的。绝大部分的Java对象的销毁都在新生代进行了。\n\nIBM公司专门研究表明，新生代中80%的对象都是“朝生夕死”的。\n\n可以使用选项-Xmn设置新生代最大内存大小，这个参数一般使用默认值就可以了。\n对象分配过程为新对象分配内存是一件非常严谨和复杂的任务，JVM的设计者们不仅需要考虑内存如何分配、在哪里分配等问题，并且由于内存分配算法与内存回收算法密切相关，所以还需要考虑GC执行完内存回收后是否会在内存空间中产生内存碎片。\n\nnew的对象先放伊甸园区。此区有大小限制。 \n当伊甸园的空间填满时，程序又需要创建对象，JVM的垃圾回收器将对伊甸园区进行垃圾回收（MinorGC），将伊甸园区中的不再被其他对象所引用的对象进行销毁。再加载新的对象放到伊甸园区 \n然后将伊甸园中的剩余对象移动到幸存者0区。 \n如果再次触发垃圾回收，此时上次幸存下来的放到幸存者0区的，如果没有回收，就会放到幸存者1区。 \n如果再次经历垃圾回收，此时会重新放回幸存者0区，接着再去幸存者1区。 \n啥时候能去养老区呢？可以设置次数。默认是15次。 \n可以设置参数：进行设置-Xx:MaxTenuringThreshold= N\n\n\n在养老区，相对悠闲。当养老区内存不足时，再次触发GC：Major GC，进行养老区的内存清理 \n若养老区执行了Major GC之后，发现依然无法进行对象的保存，就会产生OOM异常。  \n\n\n总结：针对幸存者 s0,s1 区：复制之后有交换，谁空谁是 to。\n关于垃圾回收：频繁在新生区收集，很少在养老区收集，几乎不再永久区/元空间收集。\n注意：只有伊甸园满了才会触轻 GC,而幸存者区满了是绝对不会触发轻 GC 的。\nMinor GC,MajorGC,Full GCJVM在进行GC时，并非每次都对上面三个内存区域一起回收的，大部分时候回收的都是指新生代。\n针对Hotspot VM的实现，它里面的GC按照回收区域又分为两大种类型：一种是部分收集（Partial GC），一种是整堆收集（FullGC）\n\n部分收集：不是完整收集整个Java堆的垃圾收集。其中又分为： \n\n新生代收集（Minor GC / Young GC）：只是新生代的垃圾收集\n老年代收集（Major GC / Old GC）：只是老年代的圾收集。 \n目前，只有CMSGC会有单独收集老年代的行为。\n注意，很多时候Major GC会和Full GC混淆使用，需要具体分辨是老年代回收还是整堆回收。\n\n\n混合收集（MixedGC）：收集整个新生代以及部分老年代的垃圾收集。 \n目前，只有G1 GC会有这种行为\n\n\n\n\n整堆收集（Full GC）：收集整个java堆和方法区的垃圾收集。\n\n\n永久区这个区域常驻内存的，用来存放 jdk 自身携带的 Class 对象，interfac 元数据，存储的是 java 运行时的环境，这个区域不存在垃圾回收，关闭 vm 虚拟机的时候会释放这个区域的内存。\n如果一个启动类，加载了大量第三方 jar 包，tomcat 部署了太多的应用，大量动态生成的反射类，不断的被加载，直到内存满，就会出现 OOM\n\njdk1.6 之前：永久代，常量池在方法区\njdk1.7：永久代，但是慢慢退化，去永久代，常量池在堆中\njdk1.8 之后：无永久代，常量池在元空间\n\n元空间在逻辑上存在，物理上不存在（也可以说它存在于本地内存，不占用堆内存）\n总结//vm常用参数 可以调整堆内存 和 打印信息\n-XX:+PrintFlagsInitial 查看所有参数的默认初始值\n-XX:+PrintFlagsFinal 查看所有参数的最终值\n-Xms 设置初始化内存分配大小 默认1/64\n-Xmx 设置最大分配内存 默认1/4\n-Xmn 设置新生代的大小\n-XX:NewRatio 设置新生代和老年代在堆中的结构比例\n-XX:SurvivorRatio 设置新生代中Eden和s0/s1空间比例\n-XX:MaxTenuringThreshold 设置新生代垃圾的最大年龄\n-XX:+PrintGCDetails 打印GC垃圾回收信息\n//打印GC简要信息\n    1. -XX:+PrintGC\n    2. -verbose:gc\n-XX:HandlePromotionFalilure：//是否设置空间分配担保\n-Xms8m -Xmx8m -XX:+PrintGCDetails\n\n空间分配担保策略\n在发生Minor GC之前，虚拟机会检查老年代最大可用的连续空间是否大于新生代所有对象的总空间。\n\n如果大于，则此次Minor GC是安全的\n\n如果小于，则虚拟机会查看-XX:HandlePromotionFailure设置值是否允担保失败。 \n\n如果HandlePromotionFailure=true，那么会继续检查老年代最大可用连续空间是否大于历次晋升到老年代的对象的平均大小。 \n如果大于，则尝试进行一次Minor GC，但这次Minor GC依然是有风险的；\n如果小于，则改为进行一次Full GC。\n\n\n如果HandlePromotionFailure=false，则改为进行一次Full Gc。\n\n\n\n在JDK6 Update24之后，HandlePromotionFailure参数不会再影响到虚拟机的空间分配担保策略，观察openJDK中的源码变化，虽然源码中还定义了HandlePromotionFailure参数，但是在代码中已经不会再使用它。JDK6 Update 24之后的规则变为只要老年代的连续空间大于新生代对象总大小或者历次晋升的平均大小就会进行Minor GC，否则将进行FullGC。\n逃逸分析:代码优化使用逃逸分析，编译器可以对代码做如下优化：\n栈上分配将堆分配转化为栈分配。如果一个对象在子程序中被分配，要使指向该对象的指针永远不会发生逃逸，对象可能是栈上分配的候选，而不是堆上分配\n\nJIT编译器在编译期间根据逃逸分析的结果，发现如果一个对象并没有逃逸出方法的话，就可能被优化成栈上分配。分配完成后，继续在调用栈内执行，最后线程结束，栈空间被回收，局部变量对象也被回收。这样就无须进行垃圾回收了。\n\n\n常见的栈上分配的场景\n\n\n在逃逸分析中，已经说明了。分别是给成员变量赋值、方法返回值、实例引用传递。\n\n同步省略如果一个对象被发现只有一个线程被访问到，那么对于这个对象的操作可以不考虑同步。\n\n线程同步的代价是相当高的，同步的后果是降低并发性和性能。\n\n\n在动态编译同步块的时候，JIT编译器可以借助逃逸分析来判断同步块所使用的锁对象是否只能够被一个线程访问而没有被发布到其他线程。如果没有，那么JIT编译器在编译这个同步块的时候就会取消对这部分代码的同步。这样就能大大提高并发性和性能。这个取消同步的过程就叫同步省略，也叫锁消除。\n\n分离对象/标量替换有的对象可能不需要作为一个连续的内存结构存在也可以被访问到，那么对象的部分（或全部）可以不存储在内存，而是存储在CPU寄存器中。\n\n标量（scalar）是指一个无法再分解成更小的数据的数据。Java中的原始数据类型就是标量。\n\n\n相对的，那些还可以分解的数据叫做聚合量（Aggregate），Java中的对象就是聚合量，因为他可以分解成其他聚合量和标量。\n\n\n在JIT阶段，如果经过逃逸分析，发现一个对象不会被外界访问的话，那么经过JIT优化，就会把这个对象拆解成若干个其中包含的若干个成员变量来代替。这个过程就是标量替换。\n\n举例\npublic static void main(String args[]) &#123;\n    alloc();\n&#125;\nprivate static void alloc() &#123;\n    Point point = new Point(1,2);\n    System.out.println(&quot;point.x&quot; + point.x + &quot;;point.y&quot; + point.y);\n&#125;\nclass Point &#123;\n    private int x;\n    private int y;\n&#125;\n\n以上代码，经过标量替换后，就会变成\nprivate static void alloc() &#123;\n    int x = 1;\n    int y = 2;\n    System.out.println(&quot;point.x = &quot; + x + &quot;; point.y=&quot; + y);\n&#125;\n\n可以看到，Point这个聚合量经过逃逸分析后，发现他并没有逃逸，就被替换成两个标量了。那么标量替换有什么好处呢？就是可以大大减少堆内存的占用。因为一旦不需要创建对象了，那么就不再需要分配堆内存了。 标量替换为栈上分配提供了很好的基础。\n标量替换参数设置\n参数-XX:EliminateAllocations：开启了标量替换（默认打开），允许将对象打散分配到栈上。\n总结关于逃逸分析的论文在1999年就已经发表了，但直到JDK1.6才有实现，而且这项技术到如今也并不是十分成熟。\n其根本原因就是无法保证逃逸分析的性能消耗一定能高于他的消耗。虽然经过逃逸分析可以做标量替换、栈上分配、和锁消除。但是逃逸分析自身也是需要进行一系列复杂的分析的，这其实也是一个相对耗时的过程。 \n一个极端的例子，就是经过逃逸分析之后，发现没有一个对象是不逃逸的。那这个逃逸分析的过程就白白浪费掉了。\n虽然这项技术并不十分成熟，但是它也是即时编译器优化技术中一个十分重要的手段。\n注意到有一些观点，认为通过逃逸分析，JVM会在栈上分配那些不会逃逸的对象，这在理论上是可行的，但是取决于JVM设计者的选择。据我所知，Oracle Hotspot JVM中并未这么做，这一点在逃逸分析相关的文档里已经说明，所以可以明确所有的对象实例都是创建在堆上。\n多书籍还是基于JDK7以前的版本，JDK已经发生了很大变化，intern字符串的缓存和静态变量曾经都被分配在永久代上，而永久代已经被元数据区取代。但是，intern字符串缓存和静态变量并不是被转移到元数据区，而是直接在堆上分配，所以这一点同样符合前面一点的结论：对象实例都是分配在堆上。\n方法区Method area 方法区\n《Java虚拟机规范》中明确说明：“尽管所有的方法区在逻辑上是属于堆的一部分，但一些简单的实现可能不会选择去进行垃圾收集或者进行压缩。”但对于HotSpotJVM而言，方法区还有一个别名叫做Non-Heap（非堆），目的就是要和堆分开。\n所以，方法区看作是一块独立于Java堆的内存空间。\n\n方法区（Method Area）与Java堆一样，是各个线程共享的内存区域。\n\n方法区在JVM启动的时候被创建，并且它的实际的物理内存空间中和Java堆区一样都可以是不连续的。\n\n方法区的大小，跟堆空间一样，可以选择固定大小或者可扩展。\n\n方法区的大小决定了系统可以保存多少个类，如果系统定义了太多的类，导致方法区溢出，虚拟机同样会抛出内存溢出错误：java.lang.OutOfMemoryError: PermGen space 或者java.lang.OutOfMemoryError: Metaspace \n\n加载大量的第三方的jar包；Tomcat部署的工程过多（30~50个）；大量动态的生成反射类\n\n\n关闭JVM就会释放这个区域的内存。\n\n\n在jdk7及以前，习惯上把方法区，称为永久代。到了JDK8，终于完全废弃了永久代的概念，改用与JRockit、J9一样在本地内存中实现的元空间（Metaspace）来代替\n元空间的本质和永久代类似，都是对JVM规范中方法区的实现。不过元空间与永久代最大的区别在于：元空间不在虚拟机设置的内存中，而是使用本地内存\n设置方法区大小方法区的大小不是固定的,jvm可以根据需求动态调整.\njdk7及以前\n\n通过来设置永久代初始分配空间。默认值是20.75M-XX:Permsize\n\n通过来设定永久代最大可分配空间。32位机器默认是64M，64位机器模式是82M-XX:MaxPermsize\n\n当JVM加载的类信息容量超过了这个值，会报异常OutOfMemoryError:PermGen space。\n\n\njdk8以后\n\n元数据区大小可以使用参数 -XX:MetaspaceSize 和 -XX:MaxMetaspaceSize指定\n\n默认值依赖于平台。windows下，-XX:MetaspaceSize=21M -XX:MaxMetaspaceSize=-1//即没有限制。\n\n与永久代不同，如果不指定大小，默认情况下，虚拟机会耗尽所有的可用系统内存。如果元数据区发生溢出，虚拟机一样会抛出异常OutOfMemoryError:Metaspace\n\n-XX:MetaspaceSize：设置初始的元空间大小。对于一个64位的服务器端JVM来说，其默认的-XX:MetaspaceSize值为21MB。这就是初始的高水位线，一旦触及这个水位线，Full GC将会被触发并卸载没用的类（即这些类对应的类加载器不再存活），然后这个高水位线将会重置。新的高水位线的值取决于GC后释放了多少元空间。如果释放的空间不足，那么在不超过MaxMetaspaceSize时，适当提高该值。如果释放空间过多，则适当降低该值。\n\n如果初始化的高水位线设置过低，上述高水位线调整情况会发生很多次。通过垃圾回收器的日志可以观察到Full GC多次调用。为了避免频繁地GC，建议将-XX:MetaspaceSize设置为一个相对较高的值。\n\n\n方法区的内部结构\n方法区（Method Area）与Java堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载 的类型信息、常量、静态变量、即时编译器编译后的代码缓存等数据。                                                                                                                                                                                                                    \n\n\n类信息对于每个加载的类型(类class、接口interface、枚举enum、注解annotation),JVM必须在方法区中存储一下类型信息:\n\n类型的完整有效名称(包名.类名)\n类型直接父类的完整有效名(对于interface或是java.lang.object，都没有父类)\n类型的修饰符(public，abstract，final的某个子集)\n类型直接接口的一个有序列表\n\n域(Field)信息JVM必须在方法区中保存类型的所有域的相关信息以及域的声明顺序\n域的相关信息包括: 域名称、域类型、域修饰符(public，private，protected，static，final，volatile，transient的某个子集)\n方法(Method)信息JVM必须保存所有方法的一下信息,同域信息一样包括声明顺序:\n\n方法名称\n方法返回类型(或void)\n方法参数的数量和类型(按顺序)\n方法的修饰符(public，private，protected，static，final，synchronized，native，abstract的一个子集)\n方法的字节码(bytecodes)、操作数栈、局部变量表及大小(abstract和native方法除外)\n异常表(abstract和native方法除外)\n每个异常处理的开始位置、结束位置、代码处理在程序计数器中的偏移地址、被捕获的异常类的常量池索引\n\n\n\nnon-final的类变量\n静态变量和类关联在一起，随着类的加载而加载，他们成为类数据在逻辑上的一部分\n\n类变量被类的所有实例共享，即使没有类实例时，你也可以访问它\n\n\npublic class MethodAreaTest &#123;\n    public static void main(String[] args) &#123;\n        Order order = new Order();\n        order.hello();\n        System.out.println(order.count);\n    &#125;\n&#125;\nclass Order &#123;\n    public static int count = 1;\n    public static void hello() &#123;\n        System.out.println(&quot;hello!&quot;);\n    &#125;\n&#125;\n\n补充说明：全局常量（static final）被声明为final的类变量的处理方法则不同，每个全局常量在编译的时候就会被分配了。\n运行时常量池/常量池\n方法区，内部包含了运行时常量池\n\n字节码文件，内部包含了常量池\n\n要弄清楚方法区，需要理解清楚ClassFile，因为加载类的信息都在方法区。\n\n要弄清楚方法区的运行时常量池，需要理解清楚ClassFile中的常量池。\n\n\n官方文档：https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html\n\n常量池一个java源文件中的类、接口，编译后产生一个字节码文件。而Java中的字节码需要数据支持，通常这种数据会很大以至于不能直接存到字节码里，换另一种方式，可以存到常量池，这个字节码包含了指向常量池的引用。在动态链接的时候会用到运行时常量池，之前有介绍。\n主要包含数据类型为:\n\n数量值\n字符串值\n类引用\n字段引用\n方法引用\n\n总结:常量池、可以看做是一张表，虚拟机指令根据这张常量表找到要执行的类名、方法名、参数类型、字面量等类型\n运行时常量池\n运行时常量池（Runtime Constant Pool）是方法区的一部分。\n\n常量池表（Constant Pool Table）是Class文件的一部分，用于存放编译期生成的各种字面量与符号引用，这部分内容将在类加载后存放到方法区的运行时常量池中。\n\n运行时常量池，在加载类和接口到虚拟机后，就会创建对应的运行时常量池。\n\nJVM为每个已加载的类型（类或接口）都维护一个常量池。池中的数据项像数组项一样，是通过索引访问的。\n\n运行时常量池中包含多种不同的常量，包括编译期就已经明确的数值字面量，也包括到运行期解析后才能够获得的方法或者字段引用。此时不再是常量池中的符号地址了，这里换为真实地址。\n\n运行时常量池，相对于Class文件常量池的另一重要特征是：具备动态性。\n\n运行时常量池类似于传统编程语言中的符号表（symboltable），但是它所包含的数据却比符号表要更加丰富一些。\n\n当创建类或接口的运行时常量池时，如果构造运行时常量池所需的内存空间超过了方法区所能提供的最大值，则JVM会抛OutOfMemoryError异常。\n\n\n方法区的演化\n\n\nJDK1.6及之前\n有永久代(Permanent Generation),静态变量存放在永久代上\n\n\n\nJDK1.7\n有永久代,但已经逐步’去永久代’,字符串常量池、静态变量移除,保存在堆中\n\n\nJDK1.8及之后\n无永久代,类型信息、字段、方法、常量保存在本地内存的元空间,但字符串常量池、静态变量仍在堆\n\n\n\n\n\n\n\n\n方法区的垃圾回收有些人认为方法区（如Hotspot虚拟机中的元空间或者永久代）是没有垃圾回收的,非也,《Java虚拟机规范》对方法区的约束是非常宽松的，提到过可以不要求虚拟机在方法区中实现垃圾收集。事实上也确实有未实现或未能完整实现方法区类型卸载的收集器存在（如JDK11时期的zGC收集器就不支持类卸载）.\n一般来说方法区中的回收效果难以令人满意,尤其是卸载类型,条件苛刻,但是这区域的回收有时又是必要的.以前sun公司的Bug列表中，曾出现过的若干个严重的Bug就是由于低版本的HotSpot虚拟机对此区域未完全回收而导致内存泄漏.\n方法区的垃圾收集只要针对两部分: 常量池中的废弃常量和不在使用的类型.\n先来说说方法区内常量池之中主要存放的两大类常量：字面量和符号引用。字面量比较接近Java语言层次的常量概念，如文本字符串、被声明为final的常量值等。而符号引用则属于编译原理方面的概念，包括下面三类常量：\n\n类和接口的全限定名\n\n字段的名称和描述符\n\n方法的名称和描述符\n\n\nHotSpot虚拟机对常量池的回收策略是很明确的，只要常量池中的常量没有被任何地方引用，就可以被回收。\n回收废弃常量和回收Java堆中的对象非常相似.\n判断常量是否”废弃”相对简单,但是要判定应该类型是否属于”不在被使用的类”的条件就十分苛刻,必须同时满足下列三个条件:\n\n 该类所有的实例都已经被回收，也就是Java堆中不存在该类及其任何派生子类的实例。 \n 加载该类的类加载器已经被回收，这个条件除非是经过精心设计的可替换类加载器的场景，如OSGi、JSP的重加载等，否则通常是很难达成的。 \n 该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。 \n\nJava虚拟机允许对满足上述三个条件的无用类进行回收,也止步于”被允许”,而不是像对象一样,没有引用就必然被回收,关于是否要对类型进行回收，HotSpot虚拟机提供了-Xnoclassgc参数进行控制，还可以使用-verbose:class 以及 -XX:+TraceClassLoading、-XX:+TraceClassUnLoading查看类加载和卸载信息\n在大量使用反射、动态代理、CGLib等字节码框架，动态生成JSP以及OSGi这类频繁自定义类加载器的场景中，通常都需要Java虚拟机具备类型卸载的能力，以保证不会对方法区造成过大的内存压力。\n常见面试题\n百度：\n说一下JVM内存模型吧，有哪些区？分别干什么的？\n蚂蚁金服：\nJava8的内存分代改进 JVM内存分哪几个区，每个区的作用是什么？\n一面：JVM内存分布/内存结构？栈和堆的区别？堆的结构？为什么两个survivor区？\n二面：Eden和survior的比例分配\n小米：\njvm内存分区，为什么要有新生代和老年代\n字节跳动：\n二面：Java的内存分区\n二面：讲讲jvm运行时数据库区 什么时候对象会进入老年代？\n京东：\nJVM的内存结构，Eden和Survivor比例。\nJVM内存为什么要分成新生代，老年代，持久代。\n新生代中为什么要分为Eden和survivor。\n天猫：\n一面：Jvm内存模型以及分区，需要详细到每个区放什么。\n一面：JVM的内存模型，Java8做了什么改\n拼多多：\nJVM内存分哪几个区，每个区的作用是什么？\n美团：\njava内存分配 jvm的永久代中会发生垃圾回收吗？\n一面：jvm内存分区，为什么要有新生代和老年代？\n\n对象实例化创建对象的方式\nnew：最常见的方式、Xxx的静态方法，XxxBuilder/XxxFactory的静态方法\n\nClass的newInstance方法：反射的方式，只能调用空参的构造器，权限必须是public\n\nConstructor的newInstance(XXX)：反射的方式，可以调用空参、带参的构造器，权限没有要求\n\n使用clone()：不调用任何的构造器，要求当前的类需要实现Cloneable接口，实现clone()\n\n使用序列化：从文件中、从网络中获取一个对象的二进制流\n\n第三方库 Objenesis\n\n\n创建对象的步骤\n判断对象对应的类是否加载、链接、初始化\n\n虚拟机遇到一条new指令，首先去检查这个指令的参数能否在Metaspace的常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已经被加载，解析和初始化（即判断类元信息是否存在）。\n如果没有，那么在双亲委派模式下，使用当前类加载器以ClassLoader + 包名 + 类名为key进行查找对应的 .class文件；\n\n如果没有找到文件，则抛出ClassNotFoundException异常\n\n如果找到，则进行类加载，并生成对应的Class对象\n\n\n\n\n为对象分配内存\n\n首先计算对象占用空间的大小，接着在堆中划分一块内存给新对象。如果实例成员变量是引用变量，仅分配引用变量空间即可，即4个字节大小\n如果内存规整：虚拟机将采用的是指针碰撞法（Bump The Point）来为对象分配内存。\n\n意思是所有用过的内存在一边，空闲的内存放另外一边，中间放着一个指针作为分界点的指示器，分配内存就仅仅是把指针指向空闲那边挪动一段与对象大小相等的距离罢了。如果垃圾收集器选择的是Serial ，ParNew这种基于压缩算法的，虚拟机采用这种分配方式。一般使用带Compact（整理）过程的收集器时，使用指针碰撞。\n\n如果内存不规整：虚拟机需要维护一个空闲列表（Free List）来为对象分配内存。\n\n已使用的内存和未使用的内存相互交错，那么虚拟机将采用的是空闲列表来为对象分配内存。意思是虚拟机维护了一个列表，记录上那些内存块是可用的，再分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的内容。\n选择哪种分配方式由Java堆是否规整所决定，而Java堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定。\n\n\n\n\n处理并发问题\n\n\n采用CAS失败重试、区域加锁保证更新的原子性\n\n每个线程预先分配一块TLAB：通过设置 -XX:+UseTLAB参数来设定\n\n\n\n\n初始化分配到的内存\n\n所有属性设置默认值，保证对象实例字段在不赋值时可以直接使用\n\n\n设置对象的对象头\n\n将对象的所属类（即类的元数据信息）、对象的HashCode和对象的GC信息、锁信息等数据存储在对象的对象头中。这个过程的具体设置方式取决于JVM实现。    \n\n\n执行init方法进行实例化\n\n在Java程序的视角看来，初始化才正式开始。初始化成员变量，执行实例化代码块，调用类的构造方法，并把堆内对象的首地址赋值给引用变量。\n因此一般来说（由字节码中跟随invokespecial指令所决定），new指令之后会接着就是执行方法，把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完成创建出来。\n\n\n\n给对象属性赋值的操作\n\n属性的默认初始化\n\n显式初始化\n\n代码块中初始化\n\n构造器中初始化\n\n\n对象内存布局\n消息头(Header) - PS:如果是数组,还需记录数组的长度\n运行时元数据(Mark Word)\n哈希值(HashCode)\nGC分代年龄\n锁状态标志\n线程持有的锁\n偏向线程ID\n偏向时间戳\n\n\n类型指针 - 执行类元数据InstanceKlass,确定该对象所属的类型\n\n\n实例数据(Instance Data)\n说明 - 它是对象真正存储的有效信息,包括程序代码中定义的各种类型的字段(包括从父类继承下来的和本身拥有的字段)\n规则\n相同宽度的字段总是被分配在一起\n父类中定义的变量会出现在子类之前\n如果CompactFields参数为true(默认为true): 子类的窄变量可能插入到父类变量的空袭\n\n\n\n\n对其填充(Padding)\n不是必须的,也没有特别含义,仅仅起到占位符的作用\n\n\n\n\n对象访问定位Java虚拟机规范中并没有定义应该通过什么方法去定位/访问到堆中对象的具体位置,所以对方访问方式是由虚拟机实现而定,主流有两种方式访问:句柄和直接指针\n\n如果使用句柄访问,在Java堆中就需要划分一块内存作为句柄池,栈帧中局部变量表中的对象存储句柄地址,而句柄中包含了对象的对象实例和类型数据的地址信息.\n\n\n\n如果使用直接指针访问的话,Java堆中对象的内存布局就必须考虑如何放置访问类型数据的相关信息,栈帧中局部变量表中的对象直接存储对象地址,如果访问对象本身的话,就不需要多一次间接访问的开销.\n\n\n这两种方式各有各的优点.\n使用句柄的话最大的好处是对象存储的是稳定的句柄地址,在对象被移动时(垃圾收集时移动对象是非常普遍的行为)只改变句柄中的实例数据指针.\n使用直接指针最大的好处是速度更快,节省了一次指针定位的时间开销,由于对象访 问在Java中非常频繁,因此这类开销积少成多也是一项极为可观的执行成本.\n对于HotSpot而言,它使用第二种方式进行对象访问(有例外情况，如果使用了Shenandoah收集器的 话也会有一次额外的转发),但纵观整个软件开发行业,各种语言,隔着框架中,使用句柄是十分常见的.\n三种 JVM\nSun 公司 HotSopt，也就是我们常用的\nBEA JRockit 一般用于前端商务和军事应用\nIBM J9VM 一般 IBM 硬件独占\n\nGC 题目：\nJVM 的内存模型和分区，详细到每个分区放什么？\n堆里面的分区有那些？Eden，from，to，老年区，说说他们的特点\nGC 的算法有那些？标记清除法，标记整理法，复制算法，引用计数法，怎么用的？\n轻 GC 和重 GC 分别在什么时候发生？\n\n引用计数法（很少用）：\n\n复制算法：\n好处：没用内存碎片\n坏处：浪费内存空间，多了一半空间永远是空的\n复制算法最佳使用场景：对象存活度较低的时候（也就是新生区\n\n标记清除法：\n标记/清除算法的基本思想就跟它的名字一样，分为“标记”和“清除”两个阶段：首先标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象。\n标记阶段：标记的过程其实就是前面介绍的可达性分析算法的过程，遍历所有的 GC Roots 对象，对从 GC Roots 对象可达的对象都打上一个标识，一般是在对象的 header 中，将其记录为可达对象；\n清除阶段：清除的过程是对堆内存进行遍历，如果发现某个对象没有被标记为可达对象（通过读取对象 header 信息），则将其回收。\n不足：\n\n标记和清除过程效率都不高\n会产生大量碎片，内存碎片过多可能导致无法给大对象分配内存。\n\n\n标记整理法：\n标记—整理算法和标记—清除算法一样，但是标记—整理算法不是把存活对象复制到另一块内存，而是把存活对象往内存的一端移动，然后直接回收边界以外的内存，因此其不会产生内存碎片。标记—整理算法提高了内存的利用率，并且它适合在收集对象存活时间较长的老年代。\n不足：\n效率不高，不仅要标记存活对象，还要整理所有存活对象的引用地址，在效率上不如复制算法。\n\nSTW机制JVM在执行CG回收或其他特殊任务时，会挂起除了JVM之外所有JAVA应用程序线程，表现为全局停顿，所有JAVA代码停止，native代码可以执行，但不能于JVM交互\n垃圾收集器总结内存效率：复制算法&gt;标记清除算法&gt;标记整理法 （时间复杂度）\n内存整齐度：复制算法=标记整理法&gt;标记清除算法\n内存利用率：标记整理法=标记清除法&gt;复制算法\n参考详细笔记：https://www.yuque.com/u21195183/jvm/\nSTW机制：https://www.csdn.net/tags/NtTakgwsMTEwODUtYmxvZwO0O0OO0O0O.html\nJVM：https://docs.oracle.com/javase/8/docs/technotes/tools/unix/java.html\n","categories":["Java"],"tags":["Jvm"]},{"title":"DotNetCore模型验证统一处理","url":"/2021/01/06/DotNetCore%E6%A8%A1%E5%9E%8B%E9%AA%8C%E8%AF%81%E7%BB%9F%E4%B8%80%E5%A4%84%E7%90%86/","content":"ASP.Net Core 模型验证统一处理判断验证状态时一般会在Action里判断ModelState.IsValid是否为true\npublic IActionResult Create([FromBody]CreateOrderDto dto)\n&#123;\n        if(ModelState.IsValid)\n        &#123;\n            //TODO:...\n        &#125;\n&#125;\n\n如果每个需要验证的Action里面都写这个判断岂不是太麻烦，我们是否可以在进入所有的Action之前都进行验证，如果错误，就直接返回错误信息，不去执行Action了，当然时可以的。我们可以利用MVC的ActionFilter即Action过滤器，在执行Action之前统一判断处理。\n这里通过ActionFilterAttribute过滤器来实现这个功能\n首先创建应该过滤器ValidateModelFilter\n    /// &lt;summary&gt;\n    /// 统一模型验证返回\n    /// &lt;/summary&gt;\n    public class ValidateModelFilter : ActionFilterAttribute\n    &#123;\n        public override void OnActionExecuting(ActionExecutingContext context)\n        &#123;\n            if (!context.ModelState.IsValid)\n            &#123;\n                var result = context.ModelState.Keys\n                        .SelectMany(key =&gt; context.ModelState[key].Errors.Select(x =&gt; new ValidationError(key, x.ErrorMessage)))\n                        .ToList();\n                var res = new &#123; code = &quot;10001&quot;, message = &quot;实体类验证错误&quot;, data = result &#125;;\n                context.Result = new ObjectResult(res);\n            &#125;\n        &#125;\n    &#125;\n\n    public class ValidationError\n    &#123;\n        [JsonProperty(NullValueHandling = NullValueHandling.Ignore)]\n        public string Field &#123; get; &#125;\n        public string Message &#123; get; &#125;\n        public ValidationError(string field, string message)\n        &#123;\n            Field = field != string.Empty ? field : null;\n            Message = message;\n        &#125;\n    &#125;\n\n然后将这个过滤器应用到全局设置，当然也可以局部应用\n            //全局注册异常过滤器\n            services.AddControllersWithViews(option =&gt; &#123;\n                option.Filters.Add&lt;ValidateModelFilter&gt;();\n            &#125;);\n\n最后不要忘记要禁用.NetCore默认的验证处理器\nservices.Configure&lt;ApiBehaviorOptions&gt;(options =&gt; options.SuppressModelStateInvalidFilter = true);\n\n","categories":["Net"],"tags":["DotNetCore"]},{"title":"腾讯云COS前端直传","url":"/2021/01/05/%E8%85%BE%E8%AE%AF%E4%BA%91COS%E5%89%8D%E7%AB%AF%E7%9B%B4%E4%BC%A0/","content":"腾讯云COS前端直传\n首先你需要创建应该储存桶，得到 Bucket（存储桶名称） 和 Region（地域名称）\n\n进入基础配置页面，设置跨域访问的基本设置，详情看文档\n\n获取临时密钥，服务端使用固定密钥SecretId、SecretKey 向 STS 服务获取临时密钥，得到tmpSecretId、tmpSecretKey、sessionToken。各语言Demo\n\n前端通过tmpSecretId、tmpSecretKey，计算签名。下列使用vue调用JavaScript SDK为示例：\n&lt;template&gt;\n  &lt;div class=&quot;hello&quot;&gt;\n    &lt;p class=&quot;fileT&quot;&gt;\n      选择文件 &lt;input accept=&quot;&quot; type=&quot;file&quot; ref=&quot;file&quot; id=&quot;upload&quot; /&gt;\n    &lt;/p&gt;\n    &lt;button class=&quot;sure&quot; @click=&quot;uploadFile()&quot;&gt;上传&lt;/button&gt;\n  &lt;/div&gt;\n&lt;/template&gt;\n\n&lt;script&gt;\nimport COS from &quot;cos-js-sdk-v5&quot;;\nimport axios from &quot;axios&quot;;\nexport default &#123;\n  components: &#123;&#125;,\n  data() &#123;\n    return &#123;&#125;;\n  &#125;,\n  name: &quot;HelloWorld&quot;,\n  methods: &#123;\n    getTime() &#123;\n      var date = new Date();\n      var seperator1 = &quot;-&quot;;\n      var year = date.getFullYear();\n      var month = date.getMonth() + 1;\n      var strDate = date.getDate();\n      if (month &gt;= 1 &amp;&amp; month &lt;= 9) &#123;\n        month = &quot;0&quot; + month;\n      &#125;\n      if (strDate &gt;= 0 &amp;&amp; strDate &lt;= 9) &#123;\n        strDate = &quot;0&quot; + strDate;\n      &#125;\n      var currentdate = year + seperator1 + month + seperator1 + strDate;\n      return currentdate;\n    &#125;,\n    //上传腾讯云\n    uploadFile() &#123;\n      let result = Object;\n      var cos = new COS(&#123;\n        // 必选参数\n        getAuthorization: function (options, callback) &#123;\n          axios.post(&quot;http://localhost:5010/api/COS/getToken&quot;).then((data) =&gt; &#123;\n            result = data.data;\n            console.log(result);\n            // this.$options.methods.uploadFile.bind(this)(data.data);\n            callback(&#123;\n              TmpSecretId: result.Credentials.TmpSecretId,\n              TmpSecretKey: result.Credentials.TmpSecretKey,\n              XCosSecurityToken: result.Credentials.Token,\n              StartTime: result.StartTime, // 时间戳，单位秒，如：1580000000\n              ExpiredTime: result.ExpiredTime, // 时间戳，单位秒，如：1580000900\n            &#125;);\n          &#125;);\n        &#125;,\n      &#125;);\n      var fileObj = document.getElementById(&quot;upload&quot;).files[0];\n      cos.putObject(\n        &#123;\n          Bucket: &quot;myblog-1302916147&quot; /* 必须 */,\n          Region: &quot;ap-guangzhou&quot; /* 存储桶所在地域，必须字段 */,\n          Key: this.$options.methods.getTime() + &quot;/123.jpg&quot; /* 必须 */,\n          StorageClass: &quot;STANDARD&quot;,\n          Body: fileObj, // 上传文件对象\n          onProgress: function (progressData) &#123;\n            console.log(JSON.stringify(progressData));\n          &#125;,\n        &#125;,\n        function (err, data) &#123;\n          console.log(err || data);\n        &#125;\n      );\n    &#125;,\n  &#125;,\n&#125;;\n&lt;/script&gt;\n\n&lt;style scoped&gt;\n&lt;/style&gt;\n\n\n\n","categories":["COS"],"tags":["HTML","腾讯云","Vue","COS"]},{"title":"JWT身份验证教程","url":"/2020/10/16/JWT%E8%BA%AB%E4%BB%BD%E9%AA%8C%E8%AF%81%E6%95%99%E7%A8%8B/","content":"JWT身份验证教程\n通过 NuGet 安装 Microsoft.AspNetCore.Authentication.JwtBearer\n\n\n\n打开 Startup.cs 在 ConfigureServices 添加如下代码\nservices.AddScoped&lt;IUserService, UserService&gt;();\n\n//将appsettings.json中的jwtsettings部分读取到jwtsettings中，给其他地方用\nservices.Configure&lt;JwtSettings&gt;(config.GetSection(&quot;JwtSettings&quot;));\n//由于初始化的时候我们就需要用，所有用bind方法读取配置\nvar jwtSettings = new JwtSettings();\nconfig.Bind(&quot;JwtSettings&quot;, jwtSettings);\n\n//添加身份验证\nservices.AddAuthentication(option =&gt;\n&#123;\n    //认证middleware配置\n    option.DefaultAuthenticateScheme = JwtBearerDefaults.AuthenticationScheme;\n    option.DefaultChallengeScheme = JwtBearerDefaults.AuthenticationScheme;\n&#125;).AddJwtBearer(o =&gt;\n&#123;\n    //jwt token参数设置\n    o.TokenValidationParameters = new TokenValidationParameters\n    &#123;\n        NameClaimType = JwtClaimTypes.Name,\n        RoleClaimType = JwtClaimTypes.Role,\n        //token颁发机构\n        ValidIssuer = jwtSettings.Issuer,\n        //颁发给谁\n        ValidAudience = jwtSettings.Audience,\n        //这里的key要加密\n        IssuerSigningKey = new SymmetricSecurityKey(Encoding.UTF8.GetBytes(jwtSettings.SecretKey))\n    &#125;;\n&#125;);\n\n\nConfigure 配置认证中间件\napp.UseAuthentication();//认证中间件\n\n\n创建登录用实体类，也可以直接使用 Identity Server 的，这里图个方便\npublic class LoginInput\n&#123;\n\n    public string Username &#123; get; set; &#125;\n\n    public string Password &#123; get; set; &#125;\n&#125;\n\n\n创建一个UserService类用于验证用户凭据和返回JWT令牌\n文件的顶部包含一个定义用户服务的接口，下面是实现该接口的具体用户服务类。\n身份验证成功后，该Authenticate()方法将使用JwtSecurityTokenHandler该类生成JWT（JSON Web令牌），该类将生成使用存储在appsettings.json中的密钥进行数字签名的令牌。\n标准中注册的声明 (建议但不强制使用) ：\n\niss: jwt签发者\nsub: jwt所面向的用户\naud: 接收jwt的一方\nexp: jwt的过期时间，这个过期时间必须要大于签发时间\nnbf: 定义在什么时间之前，该jwt都是不可用的.\niat: jwt的签发时间\njti: jwt的唯一身份标识，主要用来作为一次性token,从而回避重放攻击。\n\n public interface IUserService\n    &#123;\n        Task&lt;AuthenticateResponse&gt; Authenticate(LoginDto model);\n    &#125;\n\n    public class UserService : IUserService\n    &#123;\n        private readonly UserManager&lt;IdentityUser&gt; _userManager;\n\n        public JwtSettings _JwtSettings &#123; get; &#125;\n\n        public UserService(UserManager&lt;IdentityUser&gt; userManager, IOptions&lt;JwtSettings&gt; jwtSettings)\n        &#123;\n            this._userManager = userManager;\n            this._JwtSettings = jwtSettings.Value;\n        &#125;\n\n        /// &lt;summary&gt;\n        /// 进行身份验证\n        /// &lt;/summary&gt;\n        /// &lt;param name=&quot;model&quot;&gt;LoginDto模型&lt;/param&gt;\n        /// &lt;returns&gt;AuthenticateResponse&lt;/returns&gt;\n        public async Task&lt;AuthenticateResponse&gt; Authenticate(LoginDto model)\n        &#123;\n            var user = await _userManager.FindByNameAsync(model.UserName);\n\n            // 没用用户或密码错误返回null\n            if (user == null &amp;&amp; !await _userManager.CheckPasswordAsync(user, model.Password)) return null;\n\n            // 验证成功 生成jwt令牌\n            var token = generateJwtToken(user);\n\n            return new AuthenticateResponse(user, token);\n        &#125;\n\n        //获取Jwt Token\n        private string generateJwtToken(IdentityUser user)\n        &#123;\n            var tokenHandler = new JwtSecurityTokenHandler();\n            var tokenDescriptor = new SecurityTokenDescriptor\n            &#123;\n                Subject = new ClaimsIdentity(new[] &#123;\n                    new Claim(JwtClaimTypes.Audience, _JwtSettings.Audience),\n                    new Claim(JwtClaimTypes.Issuer, _JwtSettings.Issuer),\n                    new Claim(JwtClaimTypes.Name, user.UserName),\n                    new Claim(&quot;id&quot;, user.Id.ToString())\n                &#125;),\n                Expires = DateTime.UtcNow.AddDays(1),//有效日期\n                SigningCredentials = new SigningCredentials(new SymmetricSecurityKey(Encoding.UTF8.GetBytes(_JwtSettings.SecretKey)), SecurityAlgorithms.HmacSha256Signature)\n            &#125;;\n            var token = tokenHandler.CreateToken(tokenDescriptor);\n            return tokenHandler.WriteToken(token);\n        &#125;\n    &#125;\n\n\n添加登录控制器\n    [Route(&quot;api/[controller]&quot;)]\n    [ApiController]\n    public class UserController : ControllerBase\n    &#123;\n        private readonly IUserService userService;\n\n        public UserController(IUserService userService)\n        &#123;\n            this.userService = userService;\n        &#125;\n        \n        /// &lt;summary&gt; \n        /// 实现用户登录 post: /api/user/Login/model\n        /// &lt;/summary&gt;\n        /// &lt;param name=&quot;model&quot;&gt;LoginInput&lt;/param&gt;\n        /// &lt;returns&gt;&lt;/returns&gt;\n        [HttpPost]\n        [Route(&quot;Login&quot;)]\n        [AllowAnonymous]\n        public async Task&lt;IActionResult&gt; Login(LoginInput model)\n        &#123;\n            var response = await userService.Authenticate(model);\n\n            if (response == null)\n                return BadRequest(new &#123; message = &quot;用户名或密码错误&quot; &#125;);\n\n            return Ok(response);\n        &#125;\n    &#125;\n\n\nappsettings.json\n  &quot;JwtSettings&quot;: &#123;\n    &quot;Issuer&quot;: &quot;https://localhost:44336&quot;,\n    &quot;Audience&quot;: &quot;https://localhost:44336&quot;,\n    &quot;SecretKey&quot;: &quot;Hello-key----------&quot;//注意 必须达到16位\n  &#125;\n\n\n\n","categories":["Net"],"tags":["DotNetCore","JWT"]},{"title":"WPF使用CefSharp","url":"/2020/09/25/WPF%E4%BD%BF%E7%94%A8CefSharp/","content":"WPF中使用CefSharp（.net core 3.1）\n首先使用NuGet安装CefSharp.WPF\n\n指定特定的平台，x64或者x86，默认是Any CPU，不进行配置的话，CefSharp是不支持Any CPU的\n\n打开.csproj文件添加如下标签\n  &lt;ItemGroup&gt;\n    &lt;Reference Update=&quot;CefSharp&quot;&gt;\n      &lt;Private&gt;true&lt;/Private&gt;\n    &lt;/Reference&gt;\n    &lt;Reference Update=&quot;CefSharp.Core&quot;&gt;\n      &lt;Private&gt;true&lt;/Private&gt;\n    &lt;/Reference&gt;\n    &lt;Reference Update=&quot;CefSharp.Wpf&quot;&gt;\n      &lt;Private&gt;true&lt;/Private&gt;\n    &lt;/Reference&gt;\n  &lt;/ItemGroup&gt;\n\n\nWPF使用\nxmlns:cefSharpWPF=&quot;clr-namespace:CefSharp.Wpf;assembly=CefSharp.Wpf&quot;      \n&lt;cefSharpWPF:ChromiumWebBrowser x:Name=&quot;cefSp&quot;&gt;&lt;/cefSharpWPF:ChromiumWebBrowser&gt;\n\n\n\n","categories":["WPF"],"tags":["CefSharp","DotNetCore","WPF"]},{"title":"Docker安装RabbitMQ","url":"/2020/09/15/Docker%E5%AE%89%E8%A3%85RabbitMQ/","content":"Docker 下安装 RabbitMQ获取镜像\n#指定版本，该版本包含了web控制页面\ndocker pull rabbitmq:management\n\n允许镜像\n#方式一：默认guest 用户，密码也是 guest\ndocker run -d --hostname my-rabbit --name rabbit -p 15672:15672 -p 5672:5672 rabbitmq:management\n\n#方式二：设置用户名和密码\ndocker run -d --hostname my-rabbit --name rabbit -e RABBITMQ_DEFAULT_USER=user -e RABBITMQ_DEFAULT_PASS=password -p 15672:15672 -p 5672:5672 rabbitmq:management\n\n访问 UI 界面\nhttp://localhost:15672/\n\n","categories":["Docker"],"tags":["Docker","RabbitMQ"]},{"title":"EF Core 软删除","url":"/2020/09/15/EFCore%E8%BD%AF%E5%88%A0%E9%99%A4/","content":"EF CORE 软删除向应用添加软删除有如下步骤：\n\n向需要软删除的实体类添加软删除属性\n\n向 DbContext 中添加代码，以对这些实体类应用查询过滤器\n\n如何设置/重置软删除\n\n\n1.添加软删除属性对于标准的软删除实现，你需要一个布尔标志来控制软删除，例如，这里有一个名叫 SoftDeleted 属性的 Book 实体。\npublic class Book : ISoftDelete\n&#123;\n    public int BookId &#123; get; set; &#125;\n    public string Title &#123; get; set; &#125;\n    //... 其它无关属性\n\n    public bool SoftDeleted &#123; get; set; &#125;\n&#125;\n\n你可以通过它的名字SoftDeleted来区分软删除属性，如果它的值是true则该实体删除了，这意味着当你创建一个新实体时，它不会被软删除。\n我还添加了一个 Book 类的ISoftDelete接口（第 1 行），这个接口表示该类必须有一个可以读写的公共SoftDeleted属性。这个接口将使得在DbContext中配置软删除查询过滤器变得更加容易。\n2.配置查询过滤器你必须告诉 EF Core 哪个实体类需要一个查询过滤器，该过滤器是查询表达式，用来把不需要被看到的实体过滤掉。你可以在 DbContext 中使用以下代码手动完成此操作。\npublic class EfCoreContext : DbContext\n&#123;\n    public EfCoreContext(DbContextOptions&lt;EfCoreContext&gt; option)\n        : base(options)\n    &#123;&#125;\n\n    protected override OnModelCreating(ModelBuilder modelBuilder)\n    &#123;\n        // 省略其它和软删除无关的代码\n\n        modelBuilder.Entity&lt;Book&gt;().HasQueryFilter(p =&gt; !p.SoftDeleted);\n    &#125;\n&#125;\n\n这很好，但是让我向你展示一种自动添加查询过滤器的方法。\n在 DbContext 中的 OnModelCreating 方法中，你可以通过 Fluent API 配置 EF Core。但是也有一种方法可以判断每个实体类并决定如何配置它。在下面的代码中，你可以看到 foreach 循环依次遍历每个实体类，检查实体类是否实现了 ISoftDelete 接口，如果实现了，它将调用我创建的扩展方法来应用正确的软删除过滤器配置。\nprotected override void OnModelCreating(ModelBuilder modelBuilder)\n&#123;\n    // 省略其它无关的代码\n\n    foreach (var entityType in modelBuilder.Model.GetEntityTypes())\n    &#123;\n        // 省略其它无关的代码\n\n        if (typeof(ISoftDelete).IsAssignableFrom(entityType.ClrType))\n        &#123;\n            entityType.AddSoftDeleteQueryFilter();\n        &#125;\n    &#125;\n&#125;\n\n有许多配置可以直接应用于 GetEntityTypes 方法返回的类型，但是设置查询过滤器需要更多的工作。这是因为查询过滤器中的 LINQ 查询需要实体类的类型来创建正确的 LINQ 表达式。为此，我创建了一个小型扩展类，它可以动态创建正确的 LINQ 表达式来配置查询过滤器。\npublic static class SoftDeleteQueryExtension\n&#123;\n    public static void AddSoftDeleteQueryFilter(\n        this IMutableEntityType entityData)\n    &#123;\n        var methodToCall = typeof(SoftDeleteQueryExtension)\n            .GetMethod(nameof(GetSoftDeleteFilter),\n                BindingFlags.NonPublic | BindingFlags.Static)\n            .MakeGenericMethod(entityData.ClrType);\n        var filter = methodToCall.Invoke(null, new object[] &#123; &#125;);\n        entityData.SetQueryFilter((LambdaExpression)filter);\n    &#125;\n\n    private static LambdaExpression GetSoftDeleteFilter&lt;TEntity&gt;()\n        where TEntity : class, ISoftDelete\n    &#123;\n        Expression&lt;Func&lt;TEntity, bool&gt;&gt; filter = x =&gt; !x.SoftDeleted;\n        return filter;\n    &#125;\n&#125;\n\n我真的很喜欢这个操作，因为它可以节省我的时间，也避免我忘记配置每一个查询过滤器。\n3.如何设置/重置软删除将“软删除”属性设置为 true 很容易，对应的场景是用户选择一个条目并单击(软)“删除”，这会返回实体的主键。用代码实现如下：\nvar entity = context.Books.Single(x =&gt; x.BookId == id);\nentity.SoftDeleted = true;\ncontext.SaveChanges();\n\n重置软删除属性在实际的业务场景中有点复杂。首先，你很可能想要向用户显示一个已删除实体的列表——把它想象成显示某个实体类类型的实例回收站，例如 Book。要做到这一点，需要在你的查询中使用IgnoreQueryFilters方法，这意味着你将得到所有的实体（包括那些没有被软删除的和被软删除的），然后再根据需要选出那些 SoftDeleted 属性为 true 的。\nvar softDelEntities = _context.Books.IgnoreQueryFilters()\n    .Where(x =&gt; x.SoftDeleted).ToList();\n\n相应的，当你收到一个重设 SoftDeleted 属性的请求时（它通常包含实体类的主键），则要加载此条目时，需要在查询中使用IgnoreQueryFilters方法。\nvar entity = context.Books.IgnoreQueryFilters()\n     .Single(x =&gt; x.BookId == id);\nentity.SoftDeleted = false;\ncontext.SaveChanges();\n\n使用软删除注意事项首先，需要说的是查询过滤器是非常安全的。我的意思是，如果查询过滤器返回 false，那么特定的实体/行将不会包含在查询（包括 Find 和 Include 等）返回的结果集中。你可以使用直接 SQL 绕过它，但除此之外，EF Core 会隐藏你软删除的数据。\n但有几点你需要注意。\n小心软删除过滤器与其它过滤器的混合使用查询过滤器非常适合于软删除，但是查询过滤器更适合于控制对数据组的访问。例如，假设您想要构建一个 Web 应用程序来为多个公司提供服务，比如工资单。在这种情况下，你需要确保 A 公司看不到 B 公司的数据，反之亦然。这种类型的系统称为多租户应用程序，而查询过滤器非常适合此类场景。\n问题是，每个实体类型只允许使用一个查询过滤器，因此，如果您想在多租户系统中使用软删除，那么您必须将这两个部分结合起来形成查询过滤器——下面是查询过滤器的示例：\nmodelBuilder.Entity&lt;MyEntity&gt;()\n    .HasQueryFilter(x =&gt; !x.SoftDeleted\n      &amp;&amp; x.TenantId == currentTenantId);\n\n这看上去很好，但是当你使用IgnoreQueryFilters方法忽略软删除标记进行查询时，它会忽略整个查询过滤器，包括多租户部分。因此，如果不小心，还会显示多租户数据！\n答案是为自己构建一个特定于应用程序的IgnoreSoftDeleteFilter方法，如下所示：\npublic static IQueryable&lt;TEntity&gt; IgnoreSoftDeleteFilter&lt;TEntity&gt;(\n    this IQueryable&lt;TEntity&gt; baseQuery, string currentTenantId)\n    where TEntity : class, ITenantId\n&#123;\n    return baseQuery.IgnoreQueryFilters()\n        .Where(x =&gt; x.TenantId == currentTenantId)\n&#125;\n\n这将忽略所有筛选器，然后把多租户筛选器添加回去。这将使它更容易更安全地处理显示/重置被软删除的实体。\n更多的看这里吧:连接\n","categories":["DotNetCore"],"tags":["EFCore"]},{"title":"Docker安装MySql","url":"/2020/09/15/Docker%E5%AE%89%E8%A3%85MySql/","content":"Docker 安装 Mysqldocker pull mysql\n\ndocker run --name mysql  -p 3307:3306 -e MYSQL_ROOT_PASSWORD=123456 -d mysql\n\n#进入容器内部  mysql 是上边运行时为容器取的别名 也可以用id替代\ndocker exec -it dockermysql bash\n\n# 给用于授予权限\ngrant all privileges on *.*  to &#39;root&#39;@&#39;%&#39; ;\n\n# 刷新权限\nflush privileges;\n\n#Mysql远程连接报错：authentication plugin caching_sha2\nALTER USER &#39;root&#39;@&#39;%&#39; IDENTIFIED WITH mysql_native_password BY &#39;密码&#39;;\n\n","categories":["Docker"],"tags":["Docker","MySql"]},{"title":"Docker安装","url":"/2020/09/15/Docker%E5%AE%89%E8%A3%85/","content":"Docker 安装\n更新 Ubuntu 的 apt 源索引\nsudo apt-get update\n\n\n安装包允许 apt 通过 HTTPS 使用仓库\nsudo dpkg --configure -a\nsudo apt-get install apt-transport-https ca-certificates curl software-properties-common\n\n\n添加 Docker 官方 GPG key\ncurl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add -\n\n\n设置 Docker 稳定版仓库\nsudo add-apt-repository &quot;deb [arch=amd64] https://download.docker.com/linux/ubuntu $(lsb_release -cs) stable&quot;\n\n\n更新 apt 源索引\nsudo apt-get update\n\n\n安装最新版本 Docker CE（社区版）\nsudo apt-get install docker-ce\n\n\n查看安装 Docker 的版本\ndocker --version\n\n\n检查 Docker CE 是否安装正确\nsudo docker run hello-world\n\n\n配置 Docker 镜像加速\nsudo mkdir -p /etc/docker\nsudo tee /etc/docker/daemon.json &lt;&lt;-&#39;EOF&#39;\n&#123;\n  &quot;registry-mirrors&quot;: [&quot;https://rd0abcx3.mirror.aliyuncs.com&quot;]\n&#125;\nEOF\nsudo systemctl daemon-reload\nsudo systemctl restart docker\n\n\n\n","categories":["Docker"],"tags":["Docker"]},{"title":"Redis主从连接","url":"/2020/09/15/Redis%E4%B8%BB%E4%BB%8E%E8%BF%9E%E6%8E%A5/","content":"主从连接\n方法一:客户端发送命令\nslaveof &lt;masterip&gt; &lt;masterport&gt;\n\n\n方法二:启动服务器参数\nredis-server --slaveof &lt;masterip&gt; &lt;masterport&gt;\n\n\n方法三:服务器配置\nslaveof &lt;masterip&gt; &lt;masterport&gt;\n\n\n\n主从断开连接slaveof no one\n\n授权访问\nmaster 配置文件设置密码\nrequirepass &lt;password&gt;\n\n\nmaster 客户端发生命令设置密码\nconfig set requirepass &lt;password&gt;\nconfig get requirepass\n\n\nslave 客户端发送命令设置密码\nauth &lt;password&gt;\n\n\nslave 配置文件设置密码\nmasterauth &lt;password&gt;\n\n\n启动客户端设置密码\nredis-cli -a &lt;password&gt;\n\n\n\n数据同步阶段 master 说明\n如果 master 数据量巨大，数据同步阶段应避开流量高峰期，避免造成 master 阻塞，影响业务正常执行\n\n复制缓冲区大小设定不合理，会导致数据溢出。如进行全量复制周期太长，进行部分复制时发现数据已经存在丢失的情况，必须进行第二次全量复制，致使 slave 陷入死循环状态。\nrepl-backlog-size 1mb\n\n\nmaster 单机内存占用主机内存的比例不应过大，建议使用 50%-70%的内存，留下 30%-50%的内存用于执行 bgsave 命令和创建复制缓冲区\n\n\n数据同步阶段 slave 说明\n为避免 slave 进行全量复制、部分复制时服务器响应阻塞或数据不同步，建议关闭此期间的对外服务\nslave-server-stale-data yes|no\n\n\n数据同步阶段，master 发送给 slave 信息可以理解 master 是 slave 的一个客户端，主动向 slave 发送命令\n\n多个 slave 同时对 master 请求数据同步，master 发送的 RDB 文件增多，会对带宽造成巨大冲击，如果 master 带宽不足，因此数据同步需要根据业务需求，适量错峰\n\nslave 过多时，建议调整拓扑结构，由一主多从结构变为树状结构，中间的节点既是 master，也是 slave。注意使用树状结构时，由于层级深度，导致深度越高的 slave 与最顶层 master 间数据同步延迟较大，数据一致性变差，应谨慎选择\n\n\n复制缓冲区\n概念：复制缓冲区，又名复制积压缓中区，是一个先进先出（FIFO）的队列，用于存储服务器执行过的命令，每次传播命令，master 都会将传播的命令记录下来，并存储在复制缓冲区\n由来：每台服务器启动时，如果开启有 AOF 或被连接成为 master 节点，即创建复制缓冲区·\n作用：用于保存 master 收到的所有指令（仅影响数据变更的指令，例 set,select)\n数据来源：当 master 接收到主客户端的指令时，除了将指令执行，会将该指令存储到缓冲区中\n\n主从服务器复制偏移量(offset)\n概念：一个数字，描述复制缓冲区中的指令字节位置\n分类：\nmaster 复制偏移量：记录发送给所有 slave 的指令字节对应的位置（多个）\nslave 复制偏移量：记录 slave 接收 master 发送过来的指令字节对应的位置（一个）\n\n\n数据来源：\nmaster 端：发送一次记录一次\nslave 端：接收一次记录一次\n\n\n作用：同步信息，比对 master 与 slave 的差异，当 slave 断线后，恢复数据使用\n\n\n心跳机制\n进入命令传播阶段候，master 与 slave 间需要进行信息交换，使用心跳机制进行维护，实现双方连接保持在线\nmaster 心跳：\n​ 指令：PING\n周期：由 repl-ping-slave-period 决定，默认 10 秒\n作用：判断 slave 是否在线\n查询：INFO replication 获取 slave 最后一次连接时间间隔，lag 项维持在 0 或 1 视为正常\n\n\nslave 心跳任务\n指令：REPLCONF ACK{offset}\n周期：1 秒\n作用 1：汇报 slave 自己的复制偏移量，获取最新的数据变更指令\n作用 2：判断 master 是否在线\n\n\n\n心跳阶段注意事项\n当 slave 多数掉线，或延迟过高时，master 为保障数据稳定性，将拒绝所有信息同步操作\nmin-slaves-to-write 2\nmin-slaves-max-lag 10\n\nslave 数量少于 2 个，或所有 slave 的延迟都大于等于 10 秒，强制关闭 master 写功能，停止数据同步\n\nslave 数量由 slave 发送 REPLCONF ACK 命令做确认\n\nslave 延迟由 slave 发送 REPLCONF ACK 命令做确认\n\n\n\n\nrepl-timeout\n\nrepl-ping-slave-period\n\n","categories":["Redis"],"tags":["Redis"]},{"title":"Redis哨兵","url":"/2020/09/15/Redis%E5%93%A8%E5%85%B5/","content":"\n将宕机的 master 下线，找到一个 slave 作为 master，通知所有 slave 连接新的 master，启动新的 master 与 slave，全量复制 xN+部分复制 xN\n#配置文件名称 sentinel.conf\n\n#启动哨兵进程端口\nport 26379\n#哨兵进程服务临时文件夹，默认为/tmp，要保证有可写入的权限\ndir /tmp\n\n# 禁止保护模式\nprotected-mode no\n# 配置监听的主服务器，这里sentinel monitor代表监控，mymaster代表服务器的名称，可以自定义，192.168.11.128代表监控的主服务器，6379代表端口，2代表只有两个或两个以 上 的哨兵认为主服务器不可用的时候，才会进行failover操作。\nsentinel monitor mymaster 192.168.11.128 6379 2\n\n#指定哨兵在监控Redis服务时，当Redis服务在一个默认毫秒数内都无法回答时，单个哨兵认为的主观下线时间，默认为30000（30秒）\nsentinel down-after-milliseconds 30000\n\n#指定可以有多少个Redis服务同步新的主机，一般而言，这个数字越小同步时间越长，而越大，则对网络资源要求越高\nsentinel parallel-syncs myaster 1\n\n#指定故障切换允许的毫秒数，超过这个时间，就认为故障切换失败，默认为3分钟\nsentinel failover-timeout 180000\n\n# sentinel author-pass定义服务的密码，mymaster是服务名称，123456是Redis服务器密码\n# sentinel auth-pass &lt;master-name&gt; &lt;password&gt;\nsentinel auth-pass mymaster 123456\n\n\n启动哨兵\nredis-sentinel sentinel-端口号.conf\n\n\n\n","categories":["Redis"],"tags":["Redis"]},{"title":"Redis集群","url":"/2020/09/15/Redis%E9%9B%86%E7%BE%A4/","content":"Cluster 配置\n设置加入 cluster，成为其中的节点\ncluster-enabled yes|no\n\n\ncluster 配置文件名，该文件属于自动生成，仅用于快速查找文件并查询文件内容\ncluster-config-file &lt;filename&gt;\n\n\n节点服务响应超时时间，用于判定该节点是否下线或切换为从节点\ncluster-node-timeout &lt;milliseconds&gt;\n\n\nmaster 连接的 slave 最小数量\ncluster-migration-barrier &lt;count&gt;\n\n\n\nCluster 节点操作命令\n查看集群节点信息\ncluster nodes\n\n\n进入一个从节点 redis，切换其主节点\ncluster replicate &lt;master-id&gt;\n\n\n发现一个新节点，新增主节点\ncluster meet ip:port\n\n\n忽略一个没有 solt 的节点\ncluster forget &lt;id&gt;\n\n\n手动故障转移\ncluster failover\n\n\n\n","categories":["Redis"],"tags":["Redis"]},{"title":"Redis高级数据类型","url":"/2020/09/15/Redis%E9%AB%98%E7%BA%A7%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/","content":"Bitmaps\n获取指定 key 对应偏移量上的 bit 值\ngetbit key offset\n\n\n设置指定 key 对应偏移量上的 bit 值，value 只能说 0 或 1\nsetbit ket offset value\n\n\n对指定 key 按位进行交、并、非、异或操作，并将结果保存到 destKet 中\nbitop op destKet key1 [key2...]\n\n\nand:交\n\nor:并\n\nnot:非\n\nxor:异或\n\n\n\n统计指定 ket 中 1 的数量\nbitcount key [start end]\n\n\n\nHyperLogLog用于进行基数统计，不是集合，不保存数据，只记录数量而不是具体数据\n核心是基数估计算法，最终数据存在一定误差\n误差范围:基数估计的结果是一个带有 0.81 标准错误的近似值\n耗空间小，美国 hyperloglog 占用 12K 的内存用于标记基数\npfadd 命令不是一次性分配 12K 内存使用，会随着基数的增加内存逐渐增大\npfmerge 命令合并后占用储存空间为 12K，无论合并之前数据量是多少\n\n添加数据\npfadd ket  element [element...]\n\n\n统计数据\npfcount ket [key...]\n\n\n合并数据\npfmerge destkey sourcekey [sourcekey...]\n\n\n\nGEO\n添加坐标点\ngeoadd key longitude latitude member [longitude latitude member ...]\n\n\n获取坐标点\ngeopos key member [member ...]\n\n\n计算坐标点距离\ngeodist key member1 member2 [unit]\n\n\n根据坐标求范围内的数据\ngeoradius ket longitude latitude radius m|km|ft|mi [withdist] [withhash] [withhash] [count count]\n\n\n根据点求范围内的数据\ngeoradiusbymember key member radius m|km|ft|mi [withdist] [withhash] [withhash] [count count]\n\n\n获取指定点对应的坐标 hash 值\ngeohash key member [member ...]\n\n\n\n","categories":["Redis"],"tags":["Redis"]},{"title":"Redis Config配置","url":"/2020/09/15/Redis%20Config%E9%85%8D%E7%BD%AE/","content":"\n设置服务器以守护进程的方式允许\ndaemonize yes|no\n\n\n绑定主机地址\nbind 127.0.0.1\n\n\n设置服务器端口号\nport 6379\n\n\n设置数据库数量\ndatabases 16\n\n\n设置服务器以指定日志记录级别\nloglevel debug|verbose|notice|warning\n\n\n日志记录文件名\nlogfile 端口号.log\n\n\n设置同一时间最大客户端连接数，默认无限制。当客户端连接达到上限，Redis 会关闭新的连接\nmaxclients 0\n\n\n客户端闲置等待最大时长，达到最大值后关闭连接。如需关闭该功能，设置为 0\ntimeout 300\n\n\n导入并加载指定配置文件信息，用于快速创建 Redis 公共配置较多的 Redis 实例配置文件，便于维护\ninclude /path/server-端口号.conf\n\n\n\n","categories":["Redis"],"tags":["Redis"]}]